<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Variant - Note of C++</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Note of C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DingWH03/note-c-plus-plus" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/DingWH03/note-c-plus-plus/edit/master/src/Utilities/Variant.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stdvariant"><a class="header" href="#stdvariant"><code>std::variant</code></a></h1>
<p><code>std::variant</code> 是 C++17 引入的 <strong>类型安全联合（type-safe union）</strong>。在任一时刻，<code>variant&lt;...&gt;</code> 要么保存其候选类型列表中的某一类型的对象（active alternative），要么在异常情况等导致的特殊情形下处于<strong>无值</strong>状态（<code>valueless_by_exception()</code>）。</p>
<p>头文件：</p>
<pre><code class="language-cpp">#include &lt;variant&gt;
</code></pre>
<h2 id="1-模板定义"><a class="header" href="#1-模板定义">1. 模板定义</a></h2>
<pre><code class="language-cpp">template&lt; class... Types &gt;
class variant;
</code></pre>
<ul>
<li>模板参数为 <code>Types...</code>：每个 <code>T</code> 必须满足 <strong>Destructible</strong>（能被析构）。</li>
<li><strong>不允许</strong>持有引用类型、数组类型或 <code>void</code>。</li>
<li>可以重复出现相同类型（例如 <code>variant&lt;int,int&gt;</code> 合法），也可以出现不同 cv 限定的同一基础类型（如 <code>int</code> 与 <code>const int</code>）。</li>
<li><strong>注意</strong>：如果你用同一个具体类型多次，基于类型的访问（<code>std::get&lt;T&gt;</code> / <code>get_if&lt;T&gt;</code>）会变得<strong>歧义 / 编译失败</strong>（只能用索引或明确 <code>in_place_type</code>/<code>in_place_index</code>）。</li>
<li>默认构造：<strong>默认构造会构造第一个候选类型的默认值</strong>，如果第一个候选类型不可默认构造，则 <code>variant</code> 本身也不可默认构造。可以把 <code>std::monostate</code> 放在首位以保证可默认构造。</li>
</ul>
<h2 id="2-存储与对象布局"><a class="header" href="#2-存储与对象布局">2. 存储与对象布局</a></h2>
<ul>
<li><code>variant</code> 内部<strong>存储了 discriminator（索引）与一个能容纳最大候选类型的缓冲区</strong>；当 <code>variant</code> 持有某个类型 <code>T</code> 时，一个 <code>T</code> 对象会嵌套（placement-new）在该缓冲区内。</li>
<li>因此 <code>variant</code> 的大小≈（max sizeof(alternatives)）+ 对齐 + discriminator 大小。</li>
<li>在异常情况下（构造/赋值期间）有可能变为 <strong>valueless_by_exception</strong>（见下文）。</li>
</ul>
<h2 id="3-主要成员函数--重载"><a class="header" href="#3-主要成员函数--重载">3. 主要成员函数 / 重载</a></h2>
<blockquote>
<p>下面列出常用操作、签名（伪签名风格）与行为说明与例子。</p>
</blockquote>
<h3 id="构造与析构"><a class="header" href="#构造与析构">构造与析构</a></h3>
<ul>
<li>
<p><code>variant()</code></p>
<ul>
<li>默认构造：构造第一个候选类型的默认值（若可行）。</li>
<li>否则 <code>variant</code> 不可默认构造。</li>
</ul>
</li>
<li>
<p><code>variant(const variant&amp;)</code> / <code>variant(variant&amp;&amp;)</code></p>
<ul>
<li>拷贝 / 移动构造。条件：候选类型支持相应操作；若某些候选类型不可拷贝/移动，相应操作会被删除。</li>
<li>如果在移动过程中抛出异常，可能导致 <code>valueless_by_exception</code>（取决于具体实现与异常传播）。</li>
</ul>
</li>
<li>
<p>converting constructors（从某个值构造）</p>
<ul>
<li>如果传入 <code>U</code> 可明确/唯一地构造某个候选类型，<code>variant</code> 会构造该候选。若存在二义性（能构造多个候选），编译失败。</li>
</ul>
</li>
<li>
<p>in-place 构造（直接在 variant 内就地构造）</p>
<pre><code class="language-cpp">variant(in_place_type&lt;T&gt;, Args&amp;&amp;...);
variant(in_place_index&lt;I&gt;, Args&amp;&amp;...);
</code></pre>
<ul>
<li><code>in_place_type_t</code> / <code>in_place_index_t</code> 用于在 variant 内直接构造目标 alternative，避免先创建临时再赋值。</li>
</ul>
</li>
<li>
<p><code>~variant()</code></p>
<ul>
<li>默认析构：会调用当前活动 alternative 的析构函数（如果有值）。</li>
</ul>
</li>
</ul>
<h3 id="赋值operator"><a class="header" href="#赋值operator">赋值（operator=）</a></h3>
<ul>
<li>
<p><code>variant&amp; operator=(const variant&amp;);</code></p>
</li>
<li>
<p><code>variant&amp; operator=(variant&amp;&amp;);</code></p>
<ul>
<li>这两个做拷贝/移动赋值。赋值行为在不同情况下（同类型 index / 不同 index）会调用相应 alternative 的赋值/析构+构造。</li>
<li>赋值过程中若抛异常，可能使 <code>variant</code> 进入 <code>valueless_by_exception</code>。</li>
</ul>
</li>
<li>
<p><code>template&lt;class T&gt; variant&amp; operator=(T&amp;&amp;);</code></p>
<ul>
<li>converting assignment：当 <code>T</code> 可以唯一构造某个候选类型时，执行相应赋值/替换。</li>
</ul>
</li>
<li>
<p><code>variant&amp; operator=(std::monostate)</code> 等（视候选类型而定）。</p>
</li>
</ul>
<h3 id="观察器observers"><a class="header" href="#观察器observers">观察器（Observers）</a></h3>
<ul>
<li>
<p><code>std::size_t index() const noexcept;</code></p>
<ul>
<li>返回当前活动的候选类型的零基索引（0..N-1）。</li>
<li>如果处于 <code>valueless_by_exception</code>，返回 <code>variant_npos</code>（常为 <code>std::size_t(-1)</code>）。</li>
</ul>
</li>
<li>
<p><code>bool valueless_by_exception() const noexcept;</code></p>
<ul>
<li>如果 <code>variant</code> 处于无值状态（例如在变更 active alternative 时异常导致）返回 <code>true</code>。</li>
</ul>
</li>
</ul>
<h3 id="修改modifiers"><a class="header" href="#修改modifiers">修改（Modifiers）</a></h3>
<ul>
<li>
<p><code>template&lt;class T, class... Args&gt; T&amp; emplace(Args&amp;&amp;...);</code></p>
<ul>
<li><code>emplace&lt;T&gt;(args...)</code>：在 <code>variant</code> 中就地构造类型 <code>T</code>（T 必须是某个 alternative）；会销毁旧的 active 值（若有），然后就地构造新值。</li>
<li>异常安全：如果构造抛出，<code>variant</code> 可能进入 <code>valueless_by_exception</code>（取决于实现与被替换对象的销毁时机）。</li>
</ul>
</li>
<li>
<p><code>template&lt;size_t I, class... Args&gt; variant&amp; emplace(in_place_index_t&lt;I&gt;, Args&amp;&amp;...);</code></p>
<ul>
<li>使用索引 I 就地构造。</li>
</ul>
</li>
<li>
<p><code>void swap(variant&amp; other) noexcept( /* depends */ );</code></p>
<ul>
<li>交换两个 variant 的状态与内容。noexcept 与具体候选类型的 swap/移动操作相关。</li>
</ul>
</li>
</ul>
<h3 id="访问get--get_if"><a class="header" href="#访问get--get_if">访问（get / get_if）</a></h3>
<ul>
<li>
<p><code>std::get&lt;T&gt;(variant&amp;)</code> / <code>std::get&lt;I&gt;(variant&amp;)</code></p>
<ul>
<li><code>get&lt;T&gt;</code>（按类型访问）要求 <code>T</code> 在候选类型中<strong>唯一</strong>，否则编译错误。</li>
<li><code>get&lt;I&gt;</code>（按索引访问）直接访问索引为 <code>I</code> 的候选类型。</li>
<li>若 <code>variant</code> 当前不保存请求的 alternative，<code>std::get</code> 会 <strong>抛出 <code>std::bad_variant_access</code>（运行时异常）</strong>。</li>
</ul>
</li>
<li>
<p><code>std::get_if&lt;T&gt;(&amp;variant)</code> / <code>std::get_if&lt;I&gt;(&amp;variant)</code></p>
<ul>
<li><code>get_if</code> 返回指向当前值的指针（非 <code>nullptr</code> 表示匹配），失败时返回 <code>nullptr</code>。不会抛异常，通常是更安全的访问方式。</li>
<li>有 <code>const</code> / 非 <code>const</code> 重载：<code>const T* get_if&lt;const T&gt;(&amp;const variant)</code> 等。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-cpp">std::variant&lt;int,std::string&gt; v = "hi";
if (auto p = std::get_if&lt;std::string&gt;(&amp;v)) {
    std::cout &lt;&lt; *p &lt;&lt; "\n";
}
try {
    std::cout &lt;&lt; std::get&lt;int&gt;(v); // 抛出 std::bad_variant_access
} catch (const std::bad_variant_access&amp; e) { ... }
</code></pre>
<h3 id="访问辅助stdholds_alternativetv"><a class="header" href="#访问辅助stdholds_alternativetv">访问辅助：<code>std::holds_alternative&lt;T&gt;(v)</code></a></h3>
<ul>
<li>返回 <code>true</code> 当且仅当 <code>v</code> 当前持有类型 <code>T</code>（同 <code>get_if&lt;T&gt;</code> 非空）。<code>T</code> 必须唯一出现在 alternatives 中。</li>
</ul>
<h3 id="访问索引常量"><a class="header" href="#访问索引常量">访问索引常量</a></h3>
<ul>
<li>
<p><code>constexpr std::size_t variant_npos = /* often size_t(-1) */;</code></p>
<ul>
<li>表示无效索引（用于 <code>index()</code> 返回值在 <code>valueless_by_exception()</code> 时）。</li>
</ul>
</li>
</ul>
<h2 id="4-访问与遍历stdvisitvisitor-模式"><a class="header" href="#4-访问与遍历stdvisitvisitor-模式">4. 访问与遍历：<code>std::visit</code>（Visitor 模式）</a></h2>
<h3 id="非成员-stdvisit自-c17-起"><a class="header" href="#非成员-stdvisit自-c17-起">非成员 <code>std::visit</code>（自 C++17 起）</a></h3>
<p>签名（概念）：</p>
<pre><code class="language-cpp">template &lt;class Visitor, class... Variants&gt;
decltype(auto) visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars);
</code></pre>
<ul>
<li><code>std::visit</code> 会将 visitor（可调用对象）以当前 variant（或多个 variants）的活动值作为参数调用。</li>
<li>当传入多个 <code>variant</code> 时，visitor 会被调用，参数顺序与 <code>variant</code> 顺序对应。</li>
<li>如果任一 <code>variant</code> 为 <code>valueless_by_exception()</code>，<code>std::visit</code> 通常会抛出 <code>std::bad_variant_access</code>。</li>
<li>返回值类型由 visitor 决定（可以返回 <code>void</code> 或其他类型）。</li>
<li>常用技巧：用 <code>overloaded</code> （多个 lambda 继承合并）来实现多分支处理：</li>
</ul>
<pre><code class="language-cpp">// helper
template&lt;class... Fs&gt; struct overloaded : Fs... { using Fs::operator()...; };
template&lt;class... Fs&gt; overloaded(Fs...) -&gt; overloaded&lt;Fs...&gt;;

// 使用
std::variant&lt;int,std::string&gt; v = 42;
std::visit(overloaded {
    [](int i){ std::cout&lt;&lt;"int "&lt;&lt;i&lt;&lt;"\n"; },
    [](const std::string&amp; s){ std::cout&lt;&lt;"str "&lt;&lt;s&lt;&lt;"\n"; }
}, v);
</code></pre>
<h3 id="成员-visitc26-提案member-visit"><a class="header" href="#成员-visitc26-提案member-visit">成员 <code>visit</code>（C++26 提案：member visit）</a></h3>
<ul>
<li>C++26 引入（或将引入）<code>v.visit(visitor)</code> 的成员形式作为便捷写法（请注意你使用的编译器/标准支持情况）。非成员 <code>std::visit</code> 在 C++17 就有。</li>
</ul>
<h2 id="5-比较运算与哈希"><a class="header" href="#5-比较运算与哈希">5. 比较运算与哈希</a></h2>
<ul>
<li>
<p><code>operator==</code> 等（C++17 起）与 <code>operator&lt;=&gt;</code>（C++20）有定义：通常两个 <code>variant</code> 先比较是否都 <code>valueless_by_exception()</code>，再比较 <code>index()</code>，在 index 相同时比较包含的值（按对应类型的比较运算）。</p>
<ul>
<li><code>==</code>：若两者 <code>index()</code> 相同且 contained values 相等 =&gt; true；若两个都 valueless =&gt; true；否则 false。</li>
<li><code>&lt;</code> / <code>&gt;</code>：若 <code>index()</code> 不同，通常以 <code>index()</code> 的大小决定排序；若相同，则调用 contained type 的 <code>&lt;</code>。</li>
<li>详细边界（valueless 等）以标准详细定义为准，但通常结果符合“按 index 首先排序，然后按值比较”的直觉。</li>
</ul>
</li>
<li>
<p><code>std::hash&lt;std::variant&lt;...&gt;&gt;</code> 在标准库有特化（要求所有候选类型可哈希）。</p>
</li>
</ul>
<h2 id="6-辅助类型与特性type-traits--helper-classes"><a class="header" href="#6-辅助类型与特性type-traits--helper-classes">6. 辅助类型与特性（type traits / helper classes）</a></h2>
<ul>
<li>
<p><code>std::monostate</code>（C++17）</p>
<ul>
<li>一个空占位类型，常用于将 <code>variant</code> 设置为默认可构造：<code>std::variant&lt;std::monostate, T1, T2&gt;</code>。</li>
</ul>
</li>
<li>
<p><code>std::bad_variant_access</code>（C++17）</p>
<ul>
<li>当用 <code>std::get&lt;T&gt;</code> / <code>std::get&lt;I&gt;</code> 访问但 <code>variant</code> 未持有该 alternative 时抛出。</li>
</ul>
</li>
<li>
<p><code>std::variant_size&lt;Variant&gt;</code> / <code>std::variant_size_v&lt;Variant&gt;</code>（C++17）</p>
<ul>
<li>编译期获取候选类型数量（常量表达式）。</li>
<li>例： <code>std::variant_size_v&lt;std::variant&lt;int,double&gt;&gt; == 2</code>。</li>
</ul>
</li>
<li>
<p><code>std::variant_alternative&lt;I, Variant&gt;::type</code> / <code>std::variant_alternative_t&lt;I, Variant&gt;</code>（C++17）</p>
<ul>
<li>编译期获取索引 <code>I</code> 对应的类型（类型别名）。</li>
<li>例： <code>std::variant_alternative_t&lt;0,std::variant&lt;int,double&gt;&gt;</code> 等于 <code>int</code>。</li>
</ul>
</li>
<li>
<p><code>variant_npos</code>：表示无值索引（如 <code>index()</code> 在 valueless 时返回此值）。</p>
</li>
</ul>
<h2 id="7-异常安全与-valueless_by_exception"><a class="header" href="#7-异常安全与-valueless_by_exception">7. 异常安全与 <code>valueless_by_exception</code></a></h2>
<ul>
<li>
<p>在某些变更 active alternative 的操作中（例如赋值、就地构造时），如果构造/移动/复制新的 alternative 的构造函数抛出异常，而旧对象已被销毁，<code>variant</code> 可能无法恢复到原先状态，从而进入 <code>valueless_by_exception()</code>。</p>
</li>
<li>
<p>一旦处于 <code>valueless_by_exception()</code>：</p>
<ul>
<li><code>index()</code> 返回 <code>variant_npos</code>；</li>
<li><code>std::get</code> 抛出 <code>std::bad_variant_access</code>；</li>
<li><code>std::get_if</code> 返回 <code>nullptr</code>；</li>
<li>一些操作（比如 <code>std::visit</code>）会抛出 <code>bad_variant_access</code>（取决于实现）。</li>
</ul>
</li>
<li>
<p>预防策略：当替换可能抛异常的类型时，优先使用 <code>emplace</code> 并在必要时进行异常处理；确保候选类型的构造/移动操作尽可能 <code>noexcept</code>，可以降低进入无值状态的风险。</p>
</li>
</ul>
<h2 id="8-常用例子"><a class="header" href="#8-常用例子">8. 常用例子</a></h2>
<p>基本使用与 get/get_if/holds_alternative</p>
<pre><code class="language-cpp">std::variant&lt;int,std::string&gt; v = "hello";
if (std::holds_alternative&lt;std::string&gt;(v)) {
    std::cout &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; "\n";
}
if (auto p = std::get_if&lt;int&gt;(&amp;v)) {
    std::cout &lt;&lt; "int: " &lt;&lt; *p &lt;&lt; "\n";
} else {
    std::cout &lt;&lt; "not int\n";
}
</code></pre>
<p>emplace / in_place</p>
<pre><code class="language-cpp">std::variant&lt;std::monostate, std::string, std::vector&lt;int&gt;&gt; v;
v.emplace&lt;std::string&gt;("abc");              // 就地构造 std::string
v.emplace&lt;std::vector&lt;int&gt;&gt;(3, 42);         // 就地构造 vector(3,42)
v.emplace&lt;in_place_index_t&lt;1&gt;&gt;("xyz");      // 使用索引就地构造（index=1 =&gt; std::string）
</code></pre>
<p>visit 与 overloaded 工具</p>
<pre><code class="language-cpp">auto handle = overloaded {
    [](int i){ std::cout&lt;&lt;"int "&lt;&lt;i&lt;&lt;"\n"; },
    [](const std::string&amp; s){ std::cout&lt;&lt;"str "&lt;&lt;s&lt;&lt;"\n"; }
};
std::variant&lt;int,std::string&gt; v = 10;
std::visit(handle, v);
</code></pre>
<p>使用 monostate 使可默认构造</p>
<pre><code class="language-cpp">std::variant&lt;std::monostate, std::string&gt; v; // 默认构造后 v 持有 monostate
</code></pre>
<h2 id="9-实用建议--常见误用"><a class="header" href="#9-实用建议--常见误用">9. 实用建议 / 常见误用</a></h2>
<ul>
<li><strong>不要把 <code>variant</code> 作为替代所有情况</strong>：类型过多会导致代码复杂和 visitor 分支膨胀。若候选类型集合非常大或松散，考虑设计别的抽象（多态/策略等）。</li>
<li><strong>当候选类型有重复的具体类型时，避免 <code>get&lt;T&gt;</code></strong>：因为会编译错误；使用 <code>get&lt;index&gt;</code> 或 <code>in_place_type</code> 显式选择。</li>
<li><strong>注意异常安全</strong>：替换 active alternative（赋值、emplace）如果构造抛异常，可能进入 <code>valueless_by_exception</code>；为关键路径确保候选类型的移动/复制构造尽可能 <code>noexcept</code>。</li>
<li><strong>避免把对 <code>variant</code> 的访问当作频繁反射</strong>：大量类型判断/切换会影响可读性和性能（虽然 <code>variant</code> 本质上是常数时间的判定与访问，但分支与 visitor 的实现复杂度需考虑）。</li>
<li>std::variant 类似于 Rust 的 enum，都能表示“一种类型中的多种可能”。
不同点在于Rust 的 enum 语法更简洁，且模式匹配是强制的；C++ 的 std::variant 需要 std::visit 或 get 来显式处理。</li>
</ul>
<h2 id="10-标准特性备注"><a class="header" href="#10-标准特性备注">10. 标准/特性备注</a></h2>
<ul>
<li><code>std::variant</code> 自 C++17 引入（特性宏：<code>__cpp_lib_variant</code> 等）。</li>
<li>标准后续对 <code>variant</code> 做过修订（例如 <code>std::visit</code> 扩展、constexpr 能力增强等）。例如有成员形式 <code>visit</code>（C++26 提议/扩展），以及使 <code>variant</code> 更多操作支持 <code>constexpr</code>（不同标准版本的支持程度由编译器/标准库实现决定）。</li>
<li>使用时注意你的编译器和标准库版本对 <code>variant</code> 的各项特性的支持情况（尤其是 <code>constexpr</code>、成员 <code>visit</code> 等较新特性）。</li>
</ul>
<h2 id="11-快速-api-参考"><a class="header" href="#11-快速-api-参考">11. 快速 API 参考</a></h2>
<ul>
<li>头文件：<code>&lt;variant&gt;</code></li>
<li>构造：<code>variant()</code>, <code>variant(in_place_type_t&lt;T&gt;, ...)</code>, <code>variant(in_place_index_t&lt;I&gt;, ...)</code>, converting constructors</li>
<li>赋值：<code>operator=(variant)</code>, <code>operator=(T&amp;&amp;)</code>（converting）</li>
<li>访问：<code>std::get&lt;T&gt;(v)</code>, <code>std::get&lt;I&gt;(v)</code>, <code>std::get_if&lt;T&gt;(&amp;v)</code>, <code>std::get_if&lt;I&gt;(&amp;v)</code></li>
<li>情况检测：<code>v.index()</code>, <code>v.valueless_by_exception()</code>, <code>std::holds_alternative&lt;T&gt;(v)</code></li>
<li>就地构造：<code>v.emplace&lt;T&gt;(args...)</code>, <code>v.emplace&lt;in_place_index_t&lt;I&gt;&gt;(args...)</code></li>
<li>访问模式：<code>std::visit(visitor, v1, v2, ...)</code>，C++26 可能支持成员 <code>v.visit(visitor)</code></li>
<li>辅助类型：<code>std::monostate</code>, <code>std::bad_variant_access</code>, <code>std::variant_size</code>, <code>std::variant_alternative_t</code>, <code>std::hash&lt;std::variant&lt;...&gt;&gt;</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Utilities/Any.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../STL.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Utilities/Any.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../STL.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
