<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Note of C++</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Note of C++</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DingWH03/note-c-plus-plus" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>该文档记录部分(不太准确的)C++知识。</p>
<p>大部分知识均<strong>不完善</strong>，不是手册，仅仅作为笔记。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c语言面试题汇总"><a class="header" href="#c语言面试题汇总">C++语言面试题汇总</a></h1>
<ol>
<li>
<p><code>volatile</code>关键字有什么作用？</p>
<p><a href="./Basis/Types/Fundamental_Types.html#volatile">数据类型-基本数据类型-修饰符</a></p>
</li>
<li>
<p><code>const</code>和<code>constexpr</code>关键字有什么作用，有什么区别？</p>
<p><a href="./Basis/Types/Fundamental_Types.html#const">数据类型-基本数据类型-修饰符</a></p>
</li>
<li>
<p><code>static</code>关键字有什么作用？和C语言中的有什么区别？</p>
<p><a href="./Basis/Types/Fundamental_Types.html#static">数据类型-基本数据类型-修饰符</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="运行环境与基础概念"><a class="header" href="#运行环境与基础概念">运行环境与基础概念</a></h1>
<p>初识C++应知必会的基础概念。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-程序结构program-structure"><a class="header" href="#c-程序结构program-structure">C++ 程序结构（Program Structure）</a></h1>
<h2 id="引言"><a class="header" href="#引言">引言</a></h2>
<p>C++ 程序的结构决定了它的组织方式、执行流程和可维护性。
从最小的“Hello, World!”程序开始，我们可以认识一个 C++ 程序通常包含的<strong>头文件、命名空间、函数定义、语句块</strong>等组成部分。</p>
<h2 id="一个最小可运行的-c-程序"><a class="header" href="#一个最小可运行的-c-程序">一个最小可运行的 C++ 程序</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;   // 头文件：引入输入输出库
using namespace std;  // 使用标准命名空间

int main() {          // 主函数：程序执行入口
    cout &lt;&lt; "Hello, World!" &lt;&lt; endl;  // 输出语句
    return 0;         // 返回值：表示程序是否成功结束
}
</code></pre>
<h3 id="程序执行流程说明"><a class="header" href="#程序执行流程说明">程序执行流程说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>行号</th><th>内容</th><th>说明</th></tr></thead><tbody>
<tr><td>1</td><td><code>#include &lt;iostream&gt;</code></td><td>预处理指令，引入标准输入输出库</td></tr>
<tr><td>2</td><td><code>using namespace std;</code></td><td>告诉编译器默认使用 <code>std</code> 命名空间</td></tr>
<tr><td>3</td><td><code>int main() {</code></td><td>主函数是程序的入口点（返回类型必须是 <code>int</code>）</td></tr>
<tr><td>4</td><td><code>cout &lt;&lt; "Hello, World!" &lt;&lt; endl;</code></td><td>使用 <code>cout</code> 输出字符串并换行</td></tr>
<tr><td>5</td><td><code>return 0;</code></td><td>返回 <code>0</code> 表示程序正常结束</td></tr>
</tbody></table>
</div>
<h2 id="程序的基本组成部分"><a class="header" href="#程序的基本组成部分">程序的基本组成部分</a></h2>
<p>一个完整的 C++ 程序通常由以下几个部分组成：</p>
<ol>
<li>
<p><strong>预处理指令（Preprocessor Directives）</strong>
在编译前由预处理器执行，例如：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#define PI 3.14159
</code></pre>
</li>
<li>
<p><strong>命名空间（Namespace）</strong>
命名空间用于避免名称冲突：</p>
<pre><code class="language-cpp">namespace myspace {
    int x = 10;
}
</code></pre>
</li>
<li>
<p><strong>主函数 <code>main()</code></strong>
所有可执行 C++ 程序都必须有且仅有一个 <code>main()</code> 函数。</p>
</li>
<li>
<p><strong>函数定义（Functions）</strong>
函数是代码逻辑的基本单元，示例：</p>
<pre><code class="language-cpp">int add(int a, int b) {
    return a + b;
}
</code></pre>
</li>
<li>
<p><strong>变量与语句（Variables &amp; Statements）</strong>
程序的逻辑通过语句执行，通过变量存储数据。</p>
<pre><code class="language-cpp">int sum = add(2, 3);
cout &lt;&lt; sum &lt;&lt; endl;
</code></pre>
</li>
</ol>
<h2 id="c-程序的执行入口"><a class="header" href="#c-程序的执行入口">C++ 程序的执行入口</a></h2>
<ul>
<li>
<p>程序从 <code>main()</code> 函数开始执行。</p>
</li>
<li>
<p><code>main()</code> 的返回值会传递给操作系统。</p>
</li>
<li>
<p>常见的两种形式：</p>
<pre><code class="language-cpp">int main() {
    // 无参数版本
    return 0;
}

int main(int argc, char* argv[]) {
    // 带命令行参数的版本
    // argc 表示参数数量
    // argv 表示参数数组
    return 0;
}
</code></pre>
</li>
</ul>
<h2 id="程序的语句块与作用域"><a class="header" href="#程序的语句块与作用域">程序的语句块与作用域</a></h2>
<p>语句块使用花括号 <code>{}</code> 表示，定义一个新的作用域（scope）：</p>
<pre><code class="language-cpp">int x = 10;
{
    int x = 20;   // 内层作用域的 x 隐藏外层变量
    cout &lt;&lt; x;    // 输出 20
}
cout &lt;&lt; x;        // 输出 10
</code></pre>
<p>作用域是 C++ 的重要概念，影响变量的可见性与生命周期。</p>
<h2 id="程序结构的逻辑层次层级模型"><a class="header" href="#程序结构的逻辑层次层级模型">程序结构的逻辑层次（层级模型）</a></h2>
<div class="table-wrapper"><table><thead><tr><th>层级</th><th>名称</th><th>说明</th></tr></thead><tbody>
<tr><td>顶层</td><td>预处理部分</td><td>定义宏、引入头文件</td></tr>
<tr><td>全局层</td><td>命名空间、全局变量、函数声明</td><td></td></tr>
<tr><td>主函数层</td><td>程序入口、主流程</td><td></td></tr>
<tr><td>函数层</td><td>逻辑实现与局部变量</td><td></td></tr>
<tr><td>语句层</td><td>执行单元（表达式、控制语句等）</td><td></td></tr>
</tbody></table>
</div>
<p>这是一种从外到内的逻辑组织结构。良好的层级划分有助于程序的模块化。</p>
<h2 id="程序文件结构大型项目"><a class="header" href="#程序文件结构大型项目">程序文件结构（大型项目）</a></h2>
<p>在真实项目中，一个 C++ 程序通常被拆分为多个文件：</p>
<pre><code class="language-text">project/
├── main.cpp        // 程序入口
├── math/
│   ├── add.cpp
│   └── add.h
└── utils/
    ├── log.cpp
    └── log.h
</code></pre>
<p>通过 <strong>头文件 (.h/.hpp)</strong> 声明接口，<strong>源文件 (.cpp)</strong> 实现功能：</p>
<ul>
<li>
<p>add.h</p>
<pre><code class="language-cpp">#ifndef ADD_H
#define ADD_H

int add(int a, int b);

#endif
</code></pre>
</li>
<li>
<p>add.cpp</p>
<pre><code class="language-cpp">#include "add.h"
int add(int a, int b) {
    return a + b;
}
</code></pre>
</li>
<li>
<p>main.cpp</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include "add.h"

int main() {
    std::cout &lt;&lt; add(3, 4) &lt;&lt; std::endl;
    return 0;
}
</code></pre>
</li>
</ul>
<blockquote>
<p>大型工程中，通常直接或间接地使用<code>Cmake</code>或<code>make</code>进行编译和项目管理。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-程序的编译与运行compilation-and-execution"><a class="header" href="#c-程序的编译与运行compilation-and-execution">C++ 程序的编译与运行（Compilation and Execution）</a></h1>
<h2 id="引言-1"><a class="header" href="#引言-1">引言</a></h2>
<p>C++ 是一种 <strong>编译型语言（compiled language）</strong>。
这意味着在执行程序之前，必须先将源代码 (<code>.cpp</code>) 转换为计算机可以理解的机器指令（可执行文件）。</p>
<p>整个过程通常包括以下几个阶段：</p>
<pre><code class="language-text">源代码 (.cpp)
   ↓
预处理（Preprocessing）
   ↓
编译（Compilation）
   ↓
汇编（Assembly）
   ↓
链接（Linking）
   ↓
可执行文件（Executable）
   ↓
运行（Execution）
</code></pre>
<h2 id="编译过程的四个主要阶段"><a class="header" href="#编译过程的四个主要阶段">编译过程的四个主要阶段</a></h2>
<div class="table-wrapper"><table><thead><tr><th>阶段</th><th>作用</th><th>示例命令</th><th>输出文件</th></tr></thead><tbody>
<tr><td>预处理（Preprocessing）</td><td>展开宏、包含头文件、删除注释</td><td><code>g++ -E main.cpp -o main.i</code></td><td><code>main.i</code></td></tr>
<tr><td>编译（Compilation）</td><td>将预处理后的代码转换为汇编代码</td><td><code>g++ -S main.i -o main.s</code></td><td><code>main.s</code></td></tr>
<tr><td>汇编（Assembly）</td><td>将汇编代码转换为机器指令（目标文件）</td><td><code>g++ -c main.s -o main.o</code></td><td><code>main.o</code></td></tr>
<tr><td>链接（Linking）</td><td>将多个目标文件与库链接生成可执行文件</td><td><code>g++ main.o -o main</code></td><td><code>main</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>可以通过这些命令观察 C++ 源码在每个阶段的输出，理解“编译器到底做了什么”。</p>
</blockquote>
<h2 id="完整编译命令示例"><a class="header" href="#完整编译命令示例">完整编译命令示例</a></h2>
<p>最常用的编译命令只需一行：</p>
<pre><code class="language-bash">g++ main.cpp -o main
</code></pre>
<ul>
<li><code>g++</code>：GNU C++ 编译器（GCC 的 C++ 前端）</li>
<li><code>main.cpp</code>：源文件</li>
<li><code>-o main</code>：指定输出文件名（不写则默认为 <code>a.out</code>）</li>
</ul>
<p>运行程序：</p>
<pre><code class="language-bash">./main
</code></pre>
<p>输出：</p>
<pre><code class="language-text">Hello, World!
</code></pre>
<h2 id="多文件编译示例"><a class="header" href="#多文件编译示例">多文件编译示例</a></h2>
<p>大型项目通常由多个源文件组成：</p>
<pre><code class="language-text">project/
├── main.cpp
├── add.cpp
└── add.h
</code></pre>
<h3 id="编译方式一一步完成"><a class="header" href="#编译方式一一步完成">编译方式一：一步完成</a></h3>
<pre><code class="language-bash">g++ main.cpp add.cpp -o main
</code></pre>
<h3 id="编译方式二分步编译"><a class="header" href="#编译方式二分步编译">编译方式二：分步编译</a></h3>
<pre><code class="language-bash">g++ -c main.cpp -o main.o
g++ -c add.cpp -o add.o
g++ main.o add.o -o main
</code></pre>
<blockquote>
<p>分步编译的好处是：当部分文件修改时，只需重新编译变动的部分，而不是整个项目。</p>
</blockquote>
<h2 id="运行机制详解"><a class="header" href="#运行机制详解">运行机制详解</a></h2>
<p>C++ 程序编译完成后，会生成一个<strong>可执行文件</strong>（如 <code>main</code> 或 <code>main.exe</code>）。
程序的运行流程如下：</p>
<pre><code class="language-text">操作系统加载可执行文件
   ↓
执行程序的入口函数 main()
   ↓
程序逻辑执行
   ↓
return 返回值传递给操作系统
</code></pre>
<p>返回值 <code>0</code> 通常表示正常退出，非零值表示错误或异常终止。</p>
<h2 id="编译器与构建工具"><a class="header" href="#编译器与构建工具">编译器与构建工具</a></h2>
<div class="table-wrapper"><table><thead><tr><th>工具</th><th>说明</th><th>适用平台</th></tr></thead><tbody>
<tr><td><strong>g++</strong></td><td>GNU 编译器套件中的 C++ 编译器</td><td>Linux / macOS / Windows（MinGW）</td></tr>
<tr><td><strong>clang++</strong></td><td>LLVM 项目的 C++ 编译器，语法检查友好</td><td>跨平台</td></tr>
<tr><td><strong>MSVC (cl.exe)</strong></td><td>微软的 C++ 编译器</td><td>Windows</td></tr>
<tr><td><strong>CMake</strong></td><td>构建系统生成工具，可跨平台生成编译脚本</td><td>所有平台</td></tr>
<tr><td><strong>Makefile</strong></td><td>编译自动化脚本，用于管理依赖</td><td>Linux / macOS</td></tr>
</tbody></table>
</div>
<h2 id="使用-ide-进行编译运行"><a class="header" href="#使用-ide-进行编译运行">使用 IDE 进行编译运行</a></h2>
<h3 id="常见-ide"><a class="header" href="#常见-ide">常见 IDE</a></h3>
<div class="table-wrapper"><table><thead><tr><th>IDE</th><th>编译器</th><th>特点</th></tr></thead><tbody>
<tr><td>Visual Studio</td><td>MSVC</td><td>Windows 下功能最全</td></tr>
<tr><td>CLion</td><td>CMake + g++/clang++</td><td>跨平台支持强</td></tr>
<tr><td>VS Code</td><td>可结合 <code>g++</code>、<code>clang++</code></td><td>轻量灵活</td></tr>
<tr><td>Qt Creator</td><td>qmake / CMake</td><td>适用于图形界面开发</td></tr>
</tbody></table>
</div>
<h3 id="在-ide-中执行的隐含步骤"><a class="header" href="#在-ide-中执行的隐含步骤">在 IDE 中执行的隐含步骤</a></h3>
<p>当你点击“运行（Run）”时，IDE 实际执行了以下操作：</p>
<ol>
<li>调用编译器生成目标文件；</li>
<li>执行链接步骤生成可执行程序；</li>
<li>启动该可执行文件并显示输出。</li>
</ol>
<h2 id="常见编译选项"><a class="header" href="#常见编译选项">常见编译选项</a></h2>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>-o &lt;file&gt;</code></td><td>指定输出文件名</td><td><code>g++ main.cpp -o app</code></td></tr>
<tr><td><code>-Wall</code></td><td>启用所有警告信息</td><td><code>g++ -Wall main.cpp</code></td></tr>
<tr><td><code>-g</code></td><td>生成调试信息</td><td><code>g++ -g main.cpp</code></td></tr>
<tr><td><code>-O2</code></td><td>优化等级 2，提高执行效率</td><td><code>g++ -O2 main.cpp</code></td></tr>
<tr><td><code>-std=c++17</code></td><td>指定 C++ 标准版本</td><td><code>g++ -std=c++17 main.cpp</code></td></tr>
<tr><td><code>-I &lt;dir&gt;</code></td><td>添加头文件搜索路径</td><td><code>g++ -I include main.cpp</code></td></tr>
<tr><td><code>-L &lt;dir&gt;</code></td><td>添加库文件路径</td><td><code>g++ -L lib -lmylib main.cpp</code></td></tr>
<tr><td><code>-D &lt;macro&gt;</code></td><td>定义宏</td><td><code>g++ -DDEBUG main.cpp</code></td></tr>
</tbody></table>
</div>
<h2 id="扩展"><a class="header" href="#扩展">扩展</a></h2>
<ul>
<li>
<p><strong>交叉编译 (Cross Compilation)</strong>：在一台机器上为另一架构（如 ARM、RISC-V）生成可执行程序。
示例：</p>
<pre><code class="language-bash">riscv64-linux-gnu-g++ main.cpp -o main_rv
</code></pre>
</li>
<li>
<p><strong>静态链接 vs 动态链接</strong>：</p>
<ul>
<li>静态链接 (<code>.a</code>)：在编译时嵌入库文件。</li>
<li>动态链接 (<code>.so</code> / <code>.dll</code>)：运行时动态加载库。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-注释comments"><a class="header" href="#c-注释comments">C++ 注释（Comments）</a></h1>
<h2 id="1-概述"><a class="header" href="#1-概述">1. 概述</a></h2>
<p>注释用于解释程序逻辑、记录设计思路、说明接口功能或在调试时暂时屏蔽代码。
C++ 编译器在编译阶段会忽略注释内容，它们不会出现在目标文件中。
良好的注释能显著提升代码的可读性与可维护性。</p>
<h2 id="2-注释的基本类型"><a class="header" href="#2-注释的基本类型">2. 注释的基本类型</a></h2>
<p>C++ 提供两种常见的注释形式：</p>
<h3 id="21-单行注释single-line-comment"><a class="header" href="#21-单行注释single-line-comment">2.1 单行注释（Single-line Comment）</a></h3>
<p>以 <code>//</code> 开头，直到行尾结束。</p>
<pre><code class="language-cpp">// 输出欢迎信息
std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;

// 在行末添加说明
int count = 10;  // 循环次数
</code></pre>
<p>适用于简短说明或临时调试。</p>
<h3 id="22-多行注释multi-line-comment"><a class="header" href="#22-多行注释multi-line-comment">2.2 多行注释（Multi-line Comment）</a></h3>
<p>以 <code>/*</code> 开始，以 <code>*/</code> 结束，可以跨越多行。</p>
<pre><code class="language-cpp">/*
此部分用于初始化程序资源。
包括：
1. 配置加载
2. 内存分配
3. 日志系统启动
*/
initialize_system();
</code></pre>
<p>注意：多行注释 <strong>不支持嵌套</strong>，即不能在 <code>/* ... */</code> 内再次使用 <code>/* ... */</code>。</p>
<h2 id="3-注释编写原则"><a class="header" href="#3-注释编写原则">3. 注释编写原则</a></h2>
<ol>
<li><strong>准确</strong>：注释必须与代码逻辑一致。</li>
<li><strong>必要</strong>：解释“为什么这样做”，而非“代码做了什么”。</li>
<li><strong>简洁</strong>：避免冗长或与代码重复的描述。</li>
<li><strong>及时</strong>：修改代码时应同步更新注释。</li>
<li><strong>一致</strong>：保持统一的注释风格与格式。</li>
</ol>
<p>示例：</p>
<pre><code class="language-cpp">// 不推荐：重复代码逻辑
int x = x + 1; // x 加 1

// 推荐：说明设计目的
// 自增以保持计数连续性
x++;
</code></pre>
<h2 id="4-文档化注释documentation-comments"><a class="header" href="#4-文档化注释documentation-comments">4. 文档化注释（Documentation Comments）</a></h2>
<p>在较大的工程中，可以通过特殊格式的注释自动生成接口文档。
常用工具为 <strong>Doxygen</strong>，支持从源码中提取函数、类、参数等说明信息。</p>
<h3 id="41-格式示例"><a class="header" href="#41-格式示例">4.1 格式示例</a></h3>
<pre><code class="language-cpp">/**
 * @brief 计算两个整数的和
 * @param a 第一个整数
 * @param b 第二个整数
 * @return 两数之和
 */
int add(int a, int b) {
    return a + b;
}
</code></pre>
<p>或者：</p>
<pre><code class="language-cpp">/// 计算矩形面积
/// @param width 宽度
/// @param height 高度
/// @return 面积
double area(double width, double height);
</code></pre>
<h3 id="42-常用标签"><a class="header" href="#42-常用标签">4.2 常用标签</a></h3>
<div class="table-wrapper"><table><thead><tr><th>标签</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>@brief</code></td><td>简要说明</td><td><code>@brief 初始化系统资源</code></td></tr>
<tr><td><code>@param</code></td><td>参数说明</td><td><code>@param path 配置文件路径</code></td></tr>
<tr><td><code>@return</code></td><td>返回值说明</td><td><code>@return 初始化是否成功</code></td></tr>
<tr><td><code>@note</code></td><td>备注说明</td><td><code>@note 必须在主线程调用</code></td></tr>
<tr><td><code>@warning</code></td><td>警告信息</td><td><code>@warning 该函数非线程安全</code></td></tr>
<tr><td><code>@todo</code></td><td>待办事项</td><td><code>@todo 增加异常处理</code></td></tr>
</tbody></table>
</div>
<h2 id="5-实际使用规范"><a class="header" href="#5-实际使用规范">5. 实际使用规范</a></h2>
<p>在团队开发或课程项目中，建议采用以下注释习惯：</p>
<ol>
<li><strong>文件头部</strong>：说明文件用途、作者、日期。</li>
<li><strong>函数前</strong>：使用文档注释描述功能、参数与返回值。</li>
<li><strong>代码内部</strong>：仅在逻辑复杂处添加必要注释。</li>
<li><strong>调试阶段</strong>：临时屏蔽代码时使用 <code>//</code>，不保留旧逻辑。</li>
</ol>
<p>示例：</p>
<pre><code class="language-cpp">/**
 * @file user_manager.cpp
 * @brief 用户管理模块
 * @author Ding
 * @date 2025-10-13
 */

/// 初始化用户系统
/// @return 初始化是否成功
bool init_user_system() {
    // TODO: 支持从配置文件加载默认用户
    return true;
}
</code></pre>
<h2 id="6-调试与维护中的注释"><a class="header" href="#6-调试与维护中的注释">6. 调试与维护中的注释</a></h2>
<ul>
<li>
<p><strong>调试时临时屏蔽代码</strong></p>
<pre><code class="language-cpp">// 禁用日志输出
// std::cout &lt;&lt; "Debug info" &lt;&lt; std::endl;
</code></pre>
</li>
<li>
<p><strong>避免保留废弃代码</strong></p>
<pre><code class="language-cpp">// 不推荐：应使用版本控制系统管理
// old_function();
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名规则-naming-conventions"><a class="header" href="#命名规则-naming-conventions">命名规则 (Naming Conventions)</a></h1>
<p>命名规则是代码风格的重要组成部分，它能显著提高代码的可读性、可维护性和团队协作效率。在 C++ 社区中，存在多种主流命名规范（如 Google Style、LLVM Style）。</p>
<h2 id="核心原则"><a class="header" href="#核心原则">核心原则</a></h2>
<ol>
<li>
<p><strong>一致性 (Consistency)：</strong>
在一个项目或代码库中，一旦选定了一种命名风格，就必须始终如一地使用它，避免混用多种风格导致的混乱。</p>
</li>
<li>
<p><strong>描述性 (Descriptive)：</strong>
名称应清晰地描述其所代表的实体的用途或含义，便于其他开发者理解代码。</p>
</li>
<li>
<p><strong>避免歧义 (Avoid Ambiguity)：</strong>
避免使用容易引起误解的缩写或模糊单词，例如 <code>tmp</code>、<code>data</code> 等，必要时增加上下文信息。</p>
</li>
</ol>
<h2 id="常用命名风格"><a class="header" href="#常用命名风格">常用命名风格</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">风格名称</th><th style="text-align: left">描述</th><th style="text-align: left">示例</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>PascalCase</strong> / 大驼峰</td><td style="text-align: left">每个单词首字母大写，不使用分隔符。通常用于类型名称。</td><td style="text-align: left"><code>MyClassName</code></td></tr>
<tr><td style="text-align: left"><strong>camelCase</strong> / 小驼峰</td><td style="text-align: left">第一个单词首字母小写，其余单词首字母大写。通常用于变量和函数。</td><td style="text-align: left"><code>calculateSum</code></td></tr>
<tr><td style="text-align: left"><strong>snake_case</strong> / 下划线</td><td style="text-align: left">所有字母小写，单词之间用下划线 <code>_</code> 分隔。</td><td style="text-align: left"><code>current_balance</code></td></tr>
<tr><td style="text-align: left"><strong>UPPER_CASE</strong> / 全大写</td><td style="text-align: left">所有字母大写，单词之间用下划线 <code>_</code> 分隔。通常用于常量或宏。</td><td style="text-align: left"><code>MAX_SIZE</code></td></tr>
</tbody></table>
</div>
<h2 id="命名实体规范"><a class="header" href="#命名实体规范">命名实体规范</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">实体类型</th><th style="text-align: left">推荐风格</th><th style="text-align: left">示例</th><th style="text-align: left">备注</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>类 (Class)</strong></td><td style="text-align: left">PascalCase</td><td style="text-align: left"><code>Customer</code>, <code>FileManager</code></td><td style="text-align: left">类名通常是<strong>名词</strong>。</td></tr>
<tr><td style="text-align: left"><strong>结构体 (Struct)</strong></td><td style="text-align: left">PascalCase</td><td style="text-align: left"><code>Point2D</code>, <code>StudentInfo</code></td><td style="text-align: left">与类一致，都是用户自定义类型。</td></tr>
<tr><td style="text-align: left"><strong>函数/方法 (Function)</strong></td><td style="text-align: left">camelCase</td><td style="text-align: left"><code>calculateArea()</code>, <code>getFileSize()</code></td><td style="text-align: left">通常是<strong>动词或动宾短语</strong>，表示行为。</td></tr>
<tr><td style="text-align: left"><strong>局部变量 (Local Variable)</strong></td><td style="text-align: left">camelCase</td><td style="text-align: left"><code>age</code>, <code>totalCount</code>, <code>isValid</code></td><td style="text-align: left">保持简洁、描述清晰。</td></tr>
<tr><td style="text-align: left"><strong>成员变量 (Member Variable)</strong></td><td style="text-align: left">camelCase + 后缀或前缀</td><td style="text-align: left"><code>m_value</code> 或 <code>value_</code></td><td style="text-align: left">用于区分成员变量和局部变量，提高可读性。</td></tr>
<tr><td style="text-align: left"><strong>常量 (Constants)</strong></td><td style="text-align: left">UPPER_CASE</td><td style="text-align: left"><code>MAX_ITEMS</code>, <code>PI_VALUE</code></td><td style="text-align: left">用于 <code>#define</code> 或 <code>const/constexpr</code> 编译期常量。</td></tr>
<tr><td style="text-align: left"><strong>枚举 (Enums/Enum Class)</strong></td><td style="text-align: left">PascalCase</td><td style="text-align: left"><code>ColorType</code></td><td style="text-align: left">枚举类型使用 PascalCase。</td></tr>
<tr><td style="text-align: left"><strong>枚举值 (Enum Values)</strong></td><td style="text-align: left">PascalCase 或 UPPER_CASE</td><td style="text-align: left"><code>Red</code>, <code>Green</code> 或 <code>COLOR_RED</code>, <code>COLOR_GREEN</code></td><td style="text-align: left">建议加类型前缀避免冲突。</td></tr>
<tr><td style="text-align: left"><strong>命名空间 (Namespace)</strong></td><td style="text-align: left">snake_case 或 全小写</td><td style="text-align: left"><code>my_project</code>, <code>network</code></td><td style="text-align: left">命名空间通常是项目名或模块名。</td></tr>
<tr><td style="text-align: left"><strong>宏 (Macros)</strong></td><td style="text-align: left">UPPER_CASE</td><td style="text-align: left"><code>#define DEBUG_MODE</code></td><td style="text-align: left">宏是全局预处理符号，必须与变量/常量区分。</td></tr>
</tbody></table>
</div>
<h2 id="命名限制与最佳实践"><a class="header" href="#命名限制与最佳实践">命名限制与最佳实践</a></h2>
<h3 id="1-c-保留标识符"><a class="header" href="#1-c-保留标识符">1. C++ 保留标识符</a></h3>
<p>C++ 标准保留了某些名称供编译器和标准库使用，用户代码<strong>禁止使用</strong>：</p>
<h4 id="11-全局范围global-scope保留"><a class="header" href="#11-全局范围global-scope保留">1.1 全局范围（Global Scope）保留</a></h4>
<ul>
<li><strong>包含两个连续下划线 <code>__</code> 的名称</strong>
示例：<code>__myVar</code>, <code>My__Class</code></li>
<li><strong>以下划线 <code>_</code> 开头，紧跟大写字母</strong>
示例：<code>_PrivateMember</code>, <code>_Max_Value</code></li>
</ul>
<h4 id="12-全局命名空间global-namespace保留"><a class="header" href="#12-全局命名空间global-namespace保留">1.2 全局命名空间（Global Namespace）保留</a></h4>
<ul>
<li><strong>以下划线 <code>_</code> 开头的名称</strong>
示例：<code>_name</code>, <code>_a_local_var</code>
在局部作用域内可能安全，但全局范围内使用会违反标准。最佳实践：<strong>避免任何下划线开头的自定义名称</strong>。</li>
</ul>
<h4 id="13-关键字-keywords"><a class="header" href="#13-关键字-keywords">1.3 关键字 (Keywords)</a></h4>
<p>绝对禁止使用 C++ 关键字作为标识符：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">C++ 关键字（部分）</th><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>alignas</code></td><td style="text-align: left"><code>decltype</code></td><td style="text-align: left"><code>if</code></td><td style="text-align: left"><code>return</code></td></tr>
<tr><td style="text-align: left"><code>auto</code></td><td style="text-align: left"><code>do</code></td><td style="text-align: left"><code>inline</code></td><td style="text-align: left"><code>short</code></td></tr>
<tr><td style="text-align: left"><code>bool</code></td><td style="text-align: left"><code>double</code></td><td style="text-align: left"><code>int</code></td><td style="text-align: left"><code>sizeof</code></td></tr>
<tr><td style="text-align: left"><code>break</code></td><td style="text-align: left"><code>else</code></td><td style="text-align: left"><code>long</code></td><td style="text-align: left"><code>struct</code></td></tr>
<tr><td style="text-align: left"><code>case</code></td><td style="text-align: left"><code>enum</code></td><td style="text-align: left"><code>namespace</code></td><td style="text-align: left"><code>switch</code></td></tr>
<tr><td style="text-align: left"><code>char</code></td><td style="text-align: left"><code>extern</code></td><td style="text-align: left"><code>new</code></td><td style="text-align: left"><code>template</code></td></tr>
<tr><td style="text-align: left"><code>class</code></td><td style="text-align: left"><code>float</code></td><td style="text-align: left"><code>private</code></td><td style="text-align: left"><code>this</code></td></tr>
<tr><td style="text-align: left"><code>const</code></td><td style="text-align: left"><code>for</code></td><td style="text-align: left"><code>public</code></td><td style="text-align: left"><code>try</code></td></tr>
<tr><td style="text-align: left"><code>continue</code></td><td style="text-align: left"><code>goto</code></td><td style="text-align: left"><code>register</code></td><td style="text-align: left"><code>void</code></td></tr>
<tr><td style="text-align: left"><code>default</code></td><td style="text-align: left"><code>thread_local</code></td><td style="text-align: left"><code>virtual</code></td><td style="text-align: left"><code>while</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>C++11/14/17/20 新增</strong>：<code>constexpr</code>, <code>noexcept</code>, <code>override</code>, <code>concept</code></p>
</blockquote>
<h3 id="2-命名技巧与长度"><a class="header" href="#2-命名技巧与长度">2. 命名技巧与长度</a></h3>
<ul>
<li>
<p><strong>避免单字母名称</strong>：除循环迭代器（<code>i, j, k</code>）和数学变量（<code>x, y, z</code>）外，应使用描述性名称。</p>
<p><strong>差：</strong> <code>int s;</code>
<strong>好：</strong> <code>int studentCount;</code></p>
</li>
<li>
<p><strong>避免匈牙利命名法</strong>：现代 C++ 不推荐通过前缀标注类型，如 <code>iAge</code>、<code>szName</code>。类型信息已由编译器和 IDE 提供。</p>
</li>
<li>
<p><strong>布尔值命名</strong>：布尔变量或函数应以动词开头，清晰表达状态。
示例：<code>bool isValid;</code>, <code>bool hasError();</code>, <code>bool isFinished;</code></p>
</li>
<li>
<p><strong>Getter/Setter 命名</strong>：遵循约定提高可读性。</p>
<ul>
<li>Getter: <code>getValue()</code> 或 <code>value()</code> (变量名 <code>value_</code>)</li>
<li>Setter: <code>setValue(int newValue)</code> 或 <code>set_value(int newValue)</code></li>
</ul>
</li>
</ul>
<h3 id="3-文件命名规范"><a class="header" href="#3-文件命名规范">3. 文件命名规范</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">风格</th><th style="text-align: left">头文件 (.h)</th><th style="text-align: left">源文件 (.cpp)</th><th style="text-align: left">备注</th></tr></thead><tbody>
<tr><td style="text-align: left">PascalCase</td><td style="text-align: left"><code>FileManager.h</code></td><td style="text-align: left"><code>FileManager.cpp</code></td><td style="text-align: left">常用于 Qt 等 IDE/框架，与类名一致</td></tr>
<tr><td style="text-align: left">snake_case</td><td style="text-align: left"><code>file_manager.h</code></td><td style="text-align: left"><code>file_manager.cc</code></td><td style="text-align: left"><strong>Google 风格推荐</strong>，更便于跨平台和工具链使用</td></tr>
</tbody></table>
</div>
<p><strong>头文件保护 (Header Guards)</strong>：确保文件内容只被编译一次。推荐使用 <strong>全大写 + 项目/目录/文件名</strong> 的宏。</p>
<pre><code class="language-cpp">// network/tcp_socket.h
#ifndef MYPROJECT_NETWORK_TCP_SOCKET_H
#define MYPROJECT_NETWORK_TCP_SOCKET_H

// ... 代码 ...

#endif // MYPROJECT_NETWORK_TCP_SOCKET_H
</code></pre>
<h3 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h3>
<pre><code class="language-cpp">// 1. 类型 (PascalCase)
class EmployeeManager {
private:
    // 2. 成员变量 (推荐使用后缀，避免保留标识符)
    int employee_count_;

    // 错误示范（应避免）
    // int __bad_var;           // 双下划线
    // int _AnotherBadVar;      // 下划线开头 + 大写
    // int _safe_in_local_scope; // 全局范围不安全

public:
    // 3. 函数/方法 (camelCase)
    bool isValidEmployee(const std::string&amp; name) {
        // 4. 局部变量 (camelCase)
        int maxHours = 40;

        if (this-&gt;employee_count_ &lt; maxHours) { // 使用 this-&gt; 或后缀区分成员
            return true;
        }
        return false;
    }
};

// 5. 宏常量 (UPPER_CASE)
#define MAX_BUFFER_SIZE 1024
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<p>在 C++ 中，<strong>数据类型（Data Types）</strong> 是程序设计的基础，它定义了变量在内存中的存储方式、可表示的取值范围以及能进行的操作。
理解数据类型不仅是掌握语法的关键，也是进行性能优化、内存管理和类型安全编程的前提。</p>
<p>C++ 的类型系统丰富而严格，既包含直接映射到硬件的<strong>基本类型（Fundamental Types）</strong>，也支持由这些类型构建的<strong>派生类型（Derived Types）</strong>，此外还提供了面向对象与泛型编程所需的抽象类型系统。</p>
<p>本章将系统介绍 C++ 中的数据类型体系结构，内容包括：</p>
<ul>
<li>
<p><a href="Basis/./Types/Fundamental_Types.html">基本数据类型</a>：
描述整型、浮点型、布尔型、空类型等语言内建类型及其修饰符（<code>signed</code>、<code>unsigned</code>、<code>long</code> 等）。</p>
</li>
<li>
<p><a href="Basis/./Types/Derived_Types.html">派生数据类型</a>：
介绍数组、指针、引用、函数、结构体、类、枚举等由基本类型组合或扩展而来的类型。</p>
</li>
<li>
<p><a href="Basis/./Types/Character.html">字符串类型</a>：
涵盖 C 风格字符串 (<code>char[]</code>) 与 C++ 字符串类 (<code>std::string</code>、<code>std::wstring</code>) 的使用与区别。</p>
</li>
<li>
<p><a href="Basis/./Types/Type_Conversion.html">类型转换</a>：
探讨隐式与显式类型转换、C 风格转换与 C++ 四种安全转换（<code>static_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code>、<code>dynamic_cast</code>）。</p>
</li>
<li>
<p><a href="Basis/./Types/Deducing_Types.html">类型推导</a>：
说明 <code>auto</code>、<code>decltype</code>、模板参数推导等机制如何简化类型声明并保持类型安全。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本数据类型"><a class="header" href="#基本数据类型">基本数据类型</a></h1>
<h2 id="c-基本数据类型"><a class="header" href="#c-基本数据类型">C++ 基本数据类型</a></h2>
<div class="table-wrapper"><table><thead><tr><th>数据类型</th><th>描述</th><th>大小（字节）</th><th>范围/取值示例</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>布尔类型，表示真或假</td><td>1</td><td><code>true</code> 或 <code>false</code></td></tr>
<tr><td><code>char</code></td><td>字符类型，通常用于存储 ASCII 字符</td><td>1</td><td>-128 到 127 或 0 到 255（取决于有符号或无符号）</td></tr>
<tr><td><code>signed char</code></td><td>有符号字符类型</td><td>1</td><td>-128 到 127</td></tr>
<tr><td><code>unsigned char</code></td><td>无符号字符类型</td><td>1</td><td>0 到 255</td></tr>
<tr><td><code>wchar_t</code></td><td>宽字符类型，用于存储 Unicode 字符</td><td>2 或 4</td><td>取决于平台，通常 2 或 4 字节</td></tr>
<tr><td><code>char16_t</code></td><td>16 位 Unicode 字符类型（C++11）</td><td>2</td><td>0 到 65,535</td></tr>
<tr><td><code>char32_t</code></td><td>32 位 Unicode 字符类型（C++11）</td><td>4</td><td>0 到 4,294,967,295</td></tr>
<tr><td><code>short</code></td><td>短整型</td><td>2</td><td>-32,768 到 32,767</td></tr>
<tr><td><code>unsigned short</code></td><td>无符号短整型</td><td>2</td><td>0 到 65,535</td></tr>
<tr><td><code>int</code></td><td>整型</td><td>4</td><td>-2,147,483,648 到 2,147,483,647</td></tr>
<tr><td><code>unsigned int</code></td><td>无符号整型</td><td>4</td><td>0 到 4,294,967,295</td></tr>
<tr><td><code>long</code></td><td>长整型</td><td>4 或 8</td><td>取决于平台</td></tr>
<tr><td><code>unsigned long</code></td><td>无符号长整型</td><td>4 或 8</td><td>取决于平台</td></tr>
<tr><td><code>long long</code></td><td>长长整型（C++11）</td><td>8</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr>
<tr><td><code>unsigned long long</code></td><td>无符号长长整型（C++11）</td><td>8</td><td>0 到 18,446,744,073,709,551,615</td></tr>
<tr><td><code>float</code></td><td>单精度浮点数</td><td>4</td><td>约 ±3.4e±38（6-7 位有效数字）</td></tr>
<tr><td><code>double</code></td><td>双精度浮点数</td><td>8</td><td>约 ±1.7e±308（15 位有效数字）</td></tr>
<tr><td><code>long double</code></td><td>扩展精度浮点数</td><td>8、12 或 16</td><td>取决于平台</td></tr>
</tbody></table>
</div>
<h2 id="c-修饰符"><a class="header" href="#c-修饰符">C++ 修饰符</a></h2>
<div class="table-wrapper"><table><thead><tr><th>修饰符</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>signed</code></td><td>有符号类型（默认）</td><td><code>signed int x = -10;</code></td></tr>
<tr><td><code>unsigned</code></td><td>无符号类型</td><td><code>unsigned int y = 10;</code></td></tr>
<tr><td><code>short</code></td><td>短整型</td><td><code>short int z = 100;</code></td></tr>
<tr><td><code>long</code></td><td>长整型</td><td><code>long int a = 100000;</code></td></tr>
<tr><td><code>static</code></td><td>静态存储期，或内部链接，或类级别共享</td><td><code>static int count = 0;</code></td></tr>
<tr><td><code>const</code></td><td>常量，值不可修改</td><td><code>const int b = 5;</code></td></tr>
<tr><td><code>constexpr</code></td><td>编译期常量，值在编译时计算，可用于常量表达式和元编程</td><td><code>constexpr int size = 10;</code></td></tr>
<tr><td><code>volatile</code></td><td>变量可能被意外修改，禁止编译器优化</td><td><code>volatile int c = 10;</code></td></tr>
<tr><td><code>mutable</code></td><td>类成员可以在 <code>const</code> 对象中修改</td><td><code>mutable int counter;</code></td></tr>
<tr><td><code>extern</code></td><td>声明一个在其他源文件中定义的变量或函数，用于跨文件共享全局符号</td><td><code>extern int global_var;</code></td></tr>
<tr><td><code>register</code></td><td>建议编译器将变量存放在 CPU 寄存器中以提高访问速度（现代编译器多已自动优化）</td><td><code>register int counter = 0;</code></td></tr>
</tbody></table>
</div>
<h2 id="c11-新增数据类型"><a class="header" href="#c11-新增数据类型">C++11 新增数据类型</a></h2>
<div class="table-wrapper"><table><thead><tr><th>数据类型</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>auto</code></td><td>自动类型推断</td><td><code>auto x = 10;</code></td></tr>
<tr><td><code>decltype</code></td><td>获取表达式的类型</td><td><code>decltype(x) y = 20;</code></td></tr>
<tr><td><code>nullptr</code></td><td>空指针常量</td><td><code>int* ptr = nullptr;</code></td></tr>
<tr><td><code>std::initializer_list</code></td><td>初始化列表类型</td><td><code>std::initializer_list&lt;int&gt; list = {1, 2, 3};</code></td></tr>
<tr><td><code>std::tuple</code></td><td>元组类型，可以存储多个不同类型的值</td><td><code>std::tuple&lt;int, float, char&gt; t(1, 2.0, 'a');</code></td></tr>
</tbody></table>
</div>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<h3 id="宽字符类型-wchar_t"><a class="header" href="#宽字符类型-wchar_t"><strong>宽字符类型 (<code>wchar_t</code>)</strong></a></h3>
<p><code>wchar_t</code> 是 C++ 中用于存储宽字符的类型，广泛应用于需要处理 Unicode 字符集的程序中。与普通的 <code>char</code> 类型（通常用于存储 ASCII 字符）不同，<code>wchar_t</code> 的设计目的是为了支持更大的字符集，特别是 Unicode。由于 <code>wchar_t</code> 需要存储更多的字符信息，因此其大小取决于平台，通常在 2 或 4 字节之间。在一些平台上，<code>wchar_t</code> 被定义为 2 字节（16 位），在其他平台上则可能是 4 字节（32 位）。使用 <code>wchar_t</code> 可以轻松处理如中文、日文等非拉丁字符。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    wchar_t wide_char = L'我';  // 使用 wchar_t 存储一个 Unicode 字符
    std::wcout &lt;&lt; wide_char &lt;&lt; std::endl;  // 输出：我
    return 0;
}
</code></pre>
<h3 id="char16_t-和-char32_t"><a class="header" href="#char16_t-和-char32_t"><strong><code>char16_t</code> 和 <code>char32_t</code></strong></a></h3>
<p><code>char16_t</code> 和 <code>char32_t</code> 是 C++11 引入的专门用于存储 Unicode 字符的类型，分别表示 16 位和 32 位字符类型。<code>char16_t</code> 是为了支持 UTF-16 编码而设计的，而 <code>char32_t</code> 是为了支持 UTF-32 编码。<code>char16_t</code> 用 2 字节来存储一个字符，而 <code>char32_t</code> 用 4 字节存储一个字符。这两种类型能够直接表示 Unicode 字符，而无需进行额外的编码转换。</p>
<p><code>char16_t</code> 和 <code>char32_t</code> 提供了对更广泛字符集的支持，尤其适合那些需要处理全球化文本的应用程序。<code>char16_t</code> 和 <code>char32_t</code> 作为 Unicode 字符的表示方式，分别与 UTF-16 和 UTF-32 编码兼容，能够表示包括基本多语言平面（BMP）以及更高平面字符在内的所有 Unicode 字符。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    char16_t char16 = u'你';  // 使用 char16_t 存储一个 UTF-16 编码的字符
    char32_t char32 = U'你';  // 使用 char32_t 存储一个 UTF-32 编码的字符

    std::wcout &lt;&lt; "char16_t: " &lt;&lt; char16 &lt;&lt; std::endl;
    std::wcout &lt;&lt; "char32_t: " &lt;&lt; char32 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<h3 id="volatile"><a class="header" href="#volatile"><code>volatile</code></a></h3>
<p>在现代 CPU 中通常包含多个核心，每个核心都有独立的缓存。多个核心可能同时缓存了同一段主存的数据。一般情况下，缓存和主存的数据是一致的，但在多线程并发场景下，由于缓存写回策略的影响，数据的修改可能无法及时同步到主存，从而导致数据不一致的问题。</p>
<p><code>volatile</code> 关键字用于告诉编译器：某个变量的值可能随时被外部因素（如其他线程、硬件设备或中断）修改，因此缓存中的值并不可靠。出于这个原因，编译器在访问该变量时不会进行过度优化，而是强制每次都从内存中读取最新的值。</p>
<ol>
<li>
<p>可见性
<code>volatile</code> 保证变量的值在不同线程或不同硬件环境下始终是“最新可见”的。即使某个核心或寄存器中有缓存数据，访问 <code>volatile</code> 变量时也必须直接从内存或硬件中获取，而不是使用缓存副本。</p>
</li>
<li>
<p>不可优化
在编译阶段，为了提高执行效率，编译器会进行多种优化。例如：</p>
<pre><code class="language-cpp">int flag = 0;
while (flag == 0) {
    // 等待 flag 改变
}
</code></pre>
<p>若 <code>flag</code> 未被声明为 <code>volatile</code>，编译器可能认为 <code>flag</code> 始终等于 0，于是直接将循环优化为 <code>while(false)</code>，导致死循环。</p>
<p>使用 <code>volatile</code> 可以禁止类似的优化，包括 <strong>消除优化</strong>、<strong>传播优化</strong> 和 <strong>合并优化</strong>，从而保证变量的读写行为不会被错误简化。</p>
</li>
<li>
<p>顺序性
<code>volatile</code> 还会在一定程度上影响指令的顺序。编译器在处理 <code>volatile</code> 变量时，会保证读写操作不会因乱序优化而颠倒，从而维持必要的执行顺序。</p>
</li>
</ol>
<p><code>volatile</code> 在嵌入式编程和多线程编程中尤为重要：</p>
<ul>
<li><strong>多线程共享变量</strong>：确保不同线程读取到的值保持一致。</li>
<li><strong>中断处理</strong>：中断可能随时修改某个变量，主程序通过 <code>volatile</code> 保证能正确检测到变化。</li>
<li><strong>硬件寄存器访问</strong>：在嵌入式系统中，硬件寄存器的值可能在后台自动更新，必须通过 <code>volatile</code> 确保每次访问都直接读取硬件寄存器的当前值。</li>
</ul>
<p>尽管 <code>volatile</code> 在保证可见性、防止编译器优化、维持一定顺序性方面很有用，但它并不是并发编程的“万能钥匙”，主要局限性如下：</p>
<ol>
<li>
<p><strong>不保证原子性</strong></p>
<ul>
<li>
<p><code>volatile</code> 仅保证读写操作不会被优化和缓存，但不能保证复合操作的原子性。</p>
</li>
<li>
<p>例如：</p>
<pre><code class="language-cpp">volatile int counter = 0;
counter++; // 实际分解为：读取 -&gt; 修改 -&gt; 写回
</code></pre>
<p>在多线程环境下可能发生竞态条件，导致结果错误。</p>
</li>
</ul>
</li>
<li>
<p><strong>不等同于内存屏障（Memory Barrier）</strong></p>
<ul>
<li><code>volatile</code> 的“顺序性”只作用于编译器层面，防止指令在编译时被重排。</li>
<li>但在 CPU 的指令执行层面，仍然可能发生硬件乱序执行。若需要在多线程同步中严格保证内存访问顺序，还需要使用更强的同步原语（如 C++ 中的 <code>std::atomic</code> 或内存屏障指令）。</li>
</ul>
</li>
<li>
<p><strong>性能开销</strong></p>
<ul>
<li>每次访问 <code>volatile</code> 变量都要从内存中读取最新值，无法使用寄存器缓存，可能造成一定性能损失。</li>
</ul>
</li>
<li>
<p><strong>局限于特定场景</strong></p>
<ul>
<li>
<p><code>volatile</code> 更适合用于：</p>
<ul>
<li>标志位（如中断标志、任务完成标志）。</li>
<li>硬件寄存器访问。</li>
</ul>
</li>
<li>
<p>但在复杂的多线程共享数据同步场景下，仅依赖 <code>volatile</code> 是不够的，往往需要互斥锁、原子操作或更高级的同步机制。</p>
</li>
</ul>
</li>
</ol>
<h3 id="mutable"><a class="header" href="#mutable"><code>mutable</code></a></h3>
<p><code>mutable</code> 关键字是用来修饰类的成员变量的，意味着即使该对象是常量（<code>const</code>），这些成员变量也可以被修改。通常，<code>mutable</code> 用于那些希望在 <code>const</code> 方法中进行修改的成员变量，比如用于缓存的成员变量。通过 <code>mutable</code>，我们可以在 <code>const</code> 方法中修改这些成员，而不会破坏 <code>const</code> 对象的常量性。</p>
<p>以下示例展示了在 <code>const</code> 方法中修改 <code>mutable</code> 成员变量的情况：</p>
<pre><code class="language-cpp">class MyClass {
public:
    mutable int cache;  // 使用 mutable 修饰的成员变量

    MyClass() : cache(0) {}

    void updateCache() const {
        // 即使 updateCache 是 const 方法，cache 依然可以被修改
        cache++;
    }
};

int main() {
    const MyClass obj;
    obj.updateCache();  // 可在 const 对象上调用
    std::cout &lt;&lt; obj.cache &lt;&lt; std::endl;  // 输出：1
    return 0;
}
</code></pre>
<h3 id="decltype"><a class="header" href="#decltype"><code>decltype</code></a></h3>
<p><code>decltype</code> 是 C++11 引入的一个关键字，用于获取表达式的类型，而不需要显式地声明变量的类型。它通常用于模板编程中，或者当我们不确定某个表达式的类型时。<code>decltype</code> 可以非常方便地获取复杂类型，尤其是当类型通过复杂的表达式推导出来时。</p>
<p>例如，以下代码通过 <code>decltype</code> 获取了变量 <code>x</code> 的类型，并且通过 <code>auto</code> 使得代码更加简洁：</p>
<pre><code class="language-cpp">int x = 5;
decltype(x) y = 10;  // y 的类型是 int，因为 x 是 int

auto z = x + y;  // z 的类型由编译器推断，类型为 int
</code></pre>
<h3 id="stdinitializer_list"><a class="header" href="#stdinitializer_list"><code>std::initializer_list</code></a></h3>
<p><code>std::initializer_list</code> 是 C++11 引入的一个模板类，用于支持初始化列表。它允许在创建对象时通过花括号 <code>{}</code> 来传递多个值。<code>initializer_list</code> 主要用于支持类的构造函数接收不定数量的参数，或者将多个值传递给函数，特别适用于那些需要接收多个初始值的容器类型。</p>
<pre><code class="language-cpp">#include &lt;initializer_list&gt;
#include &lt;iostream&gt;

void printList(std::initializer_list&lt;int&gt; list) {
    for (auto i : list) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}

int main() {
    printList({1, 2, 3, 4, 5});  // 使用 initializer_list
    return 0;
}
</code></pre>
<h3 id="stdtuple"><a class="header" href="#stdtuple"><code>std::tuple</code></a></h3>
<p><code>std::tuple</code> 是 C++11 引入的一个模板类，允许存储多个不同类型的元素。与数组和 <code>std::vector</code> 不同，<code>tuple</code> 允许每个元素拥有不同的类型。<code>std::tuple</code> 是一个非常强大的工具，可以将多个不同类型的值打包在一起，并在需要时访问这些值。它常用于函数返回多个不同类型的值，或在需要将多种类型的参数组合起来时使用。</p>
<pre><code class="language-cpp">#include &lt;tuple&gt;
#include &lt;iostream&gt;

int main() {
    std::tuple&lt;int, double, char&gt; t(1, 3.14, 'A');

    std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; ", ";  // 1
    std::cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; ", ";  // 3.14
    std::cout &lt;&lt; std::get&lt;2&gt;(t) &lt;&lt; std::endl;  // A

    // 修改 tuple 的元素
    std::get&lt;0&gt;(t) = 42;
    std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; std::endl;  // 42

    return 0;
}
</code></pre>
<h3 id="static"><a class="header" href="#static"><code>static</code></a></h3>
<p><code>static</code> 关键字在 C++ 中有三种主要用途，取决于它所修饰的对象和作用域，而在C语言中由于不支持类从而只支持修饰<strong>局部静态变量</strong>和<strong>外部静态变量、函数</strong>。</p>
<h4 id="1-局部变量函数内--改变存储期"><a class="header" href="#1-局部变量函数内--改变存储期">1. 局部变量（函数内）- 改变存储期</a></h4>
<p>当 <code>static</code> 用于函数内的局部变量时，它改变了变量的<strong>存储期</strong>（Storage Duration）。</p>
<ul>
<li><strong>存储期</strong>：<code>static</code> 局部变量在程序运行期间<strong>只会被初始化一次</strong>，且生命周期与整个程序相同（静态存储期），但其<strong>作用域</strong>仍限定在定义它的函数内部。</li>
<li><strong>用途</strong>：用于记录函数被调用的次数，或者在多次调用中保持某个状态。</li>
</ul>
<!-- end list -->
<pre><code class="language-cpp">void func() {
    static int count = 0; // 只在程序启动时初始化一次
    count++;
    std::cout &lt;&lt; "Count: " &lt;&lt; count &lt;&lt; std::endl;
}
// 每次调用 func()，count 都会递增，而不是重置为 0
</code></pre>
<h4 id="2-全局变量和函数文件作用域--改变链接性"><a class="header" href="#2-全局变量和函数文件作用域--改变链接性">2. 全局变量和函数（文件作用域）- 改变链接性</a></h4>
<p>当 <code>static</code> 用于全局变量或普通函数时，它改变了它们的<strong>链接性</strong>（Linkage）。</p>
<ul>
<li><strong>链接性</strong>：将默认的<strong>外部链接</strong>（External Linkage，可以在其他源文件访问）改为<strong>内部链接</strong>（Internal Linkage）。</li>
<li><strong>用途</strong>：使变量或函数只在其定义的**当前翻译单元（源文件）**中可见和可用，避免与其他源文件中的同名标识符发生冲突。</li>
</ul>
<!-- end list -->
<pre><code class="language-cpp">// file1.cpp
static int global_data = 10; // 只能在 file1.cpp 中访问
static void helper_func() {  // 只能在 file1.cpp 中调用
    // ...
}
</code></pre>
<h4 id="3-类成员成员变量和成员函数--类级别共享"><a class="header" href="#3-类成员成员变量和成员函数--类级别共享">3. 类成员（成员变量和成员函数）- 类级别共享</a></h4>
<p>当 <code>static</code> 用于类内部的成员时，它使成员成为<strong>类级别</strong>的共享资源，而不是每个对象独有的资源。</p>
<ul>
<li><strong>静态成员变量</strong>：
<ul>
<li>该变量为<strong>所有</strong>类的对象所共享，<strong>只存在一个副本</strong>。</li>
<li>它必须在<strong>类外部</strong>进行定义和初始化（除非是 <code>const static</code> 整数类型）。</li>
<li>可以通过类名或对象访问。</li>
</ul>
</li>
<li><strong>静态成员函数</strong>：
<ul>
<li>它不依赖于任何特定的类对象。</li>
<li>它<strong>不能</strong>直接访问非静态的成员变量或成员函数（因为它没有 <code>this</code> 指针）。</li>
<li>通常用于访问和操作静态成员变量，或作为工具函数。</li>
</ul>
</li>
</ul>
<!-- end list -->
<pre><code class="language-cpp">class MyClass {
public:
    static int object_count; // 静态成员变量声明

    MyClass() {
        object_count++;
    }

    static int get_count() { // 静态成员函数
        return object_count;
    }
};

// 在类外定义和初始化静态成员
int MyClass::object_count = 0;

int main() {
    MyClass obj1;
    MyClass obj2;
    // 使用类名直接访问静态成员
    std::cout &lt;&lt; MyClass::get_count() &lt;&lt; std::endl; // 输出：2
    return 0;
}
</code></pre>
<h3 id="auto"><a class="header" href="#auto"><code>auto</code></a></h3>
<p><code>auto</code> 是 C++11 引入的一个关键字，允许编译器自动推导出变量的类型。<code>auto</code> 使得代码更加简洁，并且减少了显式指定类型的需求，尤其在处理复杂类型时非常有用。<code>auto</code> 通常用于变量声明时，让编译器根据赋值的表达式自动推断类型，这在迭代器和模板编程中尤其常见。</p>
<pre><code class="language-cpp">int main() {
    auto x = 10;  // x 的类型是 int
    auto y = 3.14;  // y 的类型是 double

    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<h3 id="const"><a class="header" href="#const"><code>const</code></a></h3>
<p>在 C 语言和 C++ 中，<code>const</code> 都用于限定变量为“只读”。
但是 C++ 对 <code>const</code> 的支持更为强大和灵活，它不仅影响编译器的检查机制，还会在类型系统中起作用。</p>
<ol>
<li>
<p>基本特性</p>
<ul>
<li>
<p>在 C 中，<code>const</code> 修饰的变量默认是只读存储（readonly），但本质上仍然是变量，而不是常量。</p>
<pre><code class="language-c">const int x = 10;
int *p = (int*)&amp;x; // 通过强制转换依然能修改
*p = 20;           // UB（未定义行为）
</code></pre>
</li>
<li>
<p>在 C++ 中，<code>const</code> 更严格，编译器会将其视为类型的一部分。</p>
<pre><code class="language-cpp">const int x = 10;
x = 20;  // 编译错误，禁止修改
</code></pre>
</li>
</ul>
</li>
<li>
<p>修饰位置</p>
<p><code>const</code> 可以修饰不同对象，表达不同含义：</p>
<ul>
<li>
<p>修饰变量：值不可修改。</p>
</li>
<li>
<p>修饰指针：</p>
<pre><code class="language-cpp">const int *p;  // 指向常量的指针（*p 不可改，p 可改）
int *const p;  // 常量指针（p 不可改，*p 可改）
const int *const p; // 指向常量的常量指针
</code></pre>
</li>
<li>
<p>修饰函数参数：保证函数体内不会修改该参数。</p>
</li>
<li>
<p>修饰成员函数：表示该成员函数不会修改对象的成员变量，本质上是修饰<strong>this指针</strong>。</p>
</li>
</ul>
</li>
<li>
<p>作用域与链接</p>
<ul>
<li>在 C 中，<code>const</code> 全局变量默认是 <strong>外部链接</strong>，除非显式加 <code>static</code>使得在本文件可见。</li>
<li>在 C++ 中，<code>const</code> 全局变量默认是 <strong>内部链接</strong>（只在本翻译单元内可见），若要在多个文件共享，需加 <code>extern</code>。</li>
</ul>
</li>
<li>
<p>局限性</p>
<ul>
<li><code>const</code> 并不保证编译期求值，它仅仅保证“运行时不能被修改”。</li>
<li>如果需要编译期常量（如数组大小、模板参数），在 C++11 之前通常使用 <code>#define</code> 或 <code>enum hack</code>。</li>
</ul>
</li>
</ol>
<h3 id="constexpr"><a class="header" href="#constexpr"><code>constexpr</code></a></h3>
<p><code>constexpr</code> 是 C++11 引入的关键字，用于声明“编译期常量表达式”。它不仅意味着值不可变，更重要的是：
编译器必须在编译期对其进行求值（只要表达式满足常量表达式要求）。</p>
<ol>
<li>
<p>基本特性</p>
<ul>
<li>
<p><code>constexpr</code> 变量一定是常量，并且能在编译期被计算：</p>
<pre><code class="language-cpp">constexpr int size = 10;
int arr[size]; // 合法
</code></pre>
</li>
<li>
<p>与 <code>const</code> 不同，<code>constexpr</code> 要求初始化表达式必须是编译期可计算的常量。</p>
</li>
</ul>
</li>
<li>
<p>函数支持</p>
<ul>
<li>
<p><code>constexpr</code> 还可以修饰函数：</p>
<pre><code class="language-cpp">constexpr int square(int x) {
    return x * x;
}
int arr[square(5)]; // 在编译期计算为 25
</code></pre>
</li>
<li>
<p>这样的函数可以在编译期使用，也可以在运行时调用（若传入非常量参数）。</p>
</li>
</ul>
</li>
<li>
<p>类与构造函数</p>
<ul>
<li>C++11 起，<code>constexpr</code> 可以修饰构造函数，表示该类的对象可以在编译期生成常量。</li>
<li>C++14/17 对 <code>constexpr</code> 的限制逐步放宽，例如允许有分支、循环，更接近普通函数。</li>
</ul>
</li>
<li>
<p>区别于 <code>const</code></p>
<ul>
<li><code>const</code>：运行期常量（只读），初始化表达式可以是运行时值，可以使用<code>const_cast</code>去除限定。</li>
<li><code>constexpr</code>：编译期常量，初始化表达式必须在编译期可求值。</li>
</ul>
<p>对比示例：</p>
<pre><code class="language-cpp">const int a = std::time(nullptr); // 合法，运行期决定
constexpr int b = std::time(nullptr); // 错误，不能在编译期求值
</code></pre>
</li>
</ol>
<h3 id="extern"><a class="header" href="#extern"><code>extern</code></a></h3>
<p><code>extern</code> 关键字用于<strong>声明</strong>而非定义变量或函数。
它通常出现在多文件项目中，用于在一个文件中访问另一个文件定义的全局变量或函数。</p>
<ul>
<li>
<p>作用：</p>
<ul>
<li>告诉编译器“该变量或函数在别处定义”；</li>
<li>不会为其分配存储空间（除非在定义处）；</li>
<li>避免重复定义全局符号。</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">// file1.cpp
int count = 10;  // 定义全局变量

// file2.cpp
#include &lt;iostream&gt;
extern int count;  // 声明外部变量（非定义）
int main() {
    std::cout &lt;&lt; count &lt;&lt; std::endl;  // 输出 10
    return 0;
}
</code></pre>
<ul>
<li>
<p>在C++中：</p>
<p>C++ 默认情况下，<code>const</code> 全局变量具有内部链接（<code>internal linkage</code>），也就是仅在本文件内可见。
若希望跨文件共享一个常量变量，必须结合 <code>extern</code> 使用：</p>
<pre><code class="language-cpp">// file1.cpp
extern const int BUFFER_SIZE = 1024;

// file2.cpp
extern const int BUFFER_SIZE;  // 声明外部常量
</code></pre>
</li>
<li>
<p>与函数结合使用：</p>
<p>对于函数来说，<code>extern</code> 是默认属性，即所有非 <code>static</code> 函数都具有外部链接性，因此通常可省略：</p>
<pre><code class="language-cpp">extern void foo();  // 与 void foo(); 等价
</code></pre>
</li>
</ul>
<h3 id="register"><a class="header" href="#register"><code>register</code></a></h3>
<p><code>register</code> 是早期 C/C++ 时代用于<strong>提升变量访问速度</strong>的关键字，提示编译器将变量存储在 CPU 寄存器中，而非内存中。</p>
<ul>
<li>
<p>特点：</p>
<ul>
<li>变量可能被存放在 CPU 寄存器中，而非内存；</li>
<li>不能对 <code>register</code> 变量使用取地址操作符 <code>&amp;</code>；</li>
<li>仅能修饰局部变量或函数参数；</li>
<li>在现代编译器中通常<strong>被自动优化机制取代</strong>，因此多用于教学或历史理解。</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    register int i;  // 建议编译器将 i 放入寄存器中
    for (i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<ul>
<li>
<p><strong>局限性：</strong></p>
<ul>
<li>编译器不保证一定会将其放入寄存器；</li>
<li>不能取地址（即 <code>&amp;i</code> 是非法的）；</li>
<li>在现代 C++ 中几乎没有实际性能提升，优化器会自动选择合适的寄存器分配策略。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="派生数据类型"><a class="header" href="#派生数据类型">派生数据类型</a></h1>
<h2 id="c派生数据类型"><a class="header" href="#c派生数据类型">C++派生数据类型</a></h2>
<p>在 C++ 中，<strong>派生数据类型（Derived Types）</strong> 是由基本数据类型或其他派生类型构建而来的类型。
它们扩展了语言的表达能力，使得开发者能够通过组合与抽象创建更复杂的数据结构与行为模型。</p>
<p>派生类型包括数组、指针、引用、函数、结构体、类、联合体以及枚举类型等。</p>
<div class="table-wrapper"><table><thead><tr><th>数据类型</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td>数组</td><td>相同类型元素的集合</td><td><code>int arr[5] = {1, 2, 3, 4, 5};</code></td></tr>
<tr><td>指针</td><td>存储变量内存地址的类型</td><td><code>int* ptr = &amp;x;</code></td></tr>
<tr><td>引用</td><td>变量的别名</td><td><code>int&amp; ref = x;</code></td></tr>
<tr><td>函数</td><td>函数类型，表示函数的签名</td><td><code>int func(int a, int b);</code></td></tr>
<tr><td>结构体</td><td>用户定义的数据类型，可以包含多个不同类型的成员</td><td><code>struct Point { int x; int y; };</code></td></tr>
<tr><td>类</td><td>用户定义的数据类型，支持封装、继承和多态</td><td><code>class MyClass { ... };</code></td></tr>
<tr><td>联合体</td><td>多个成员共享同一块内存</td><td><code>union Data { int i; float f; };</code></td></tr>
<tr><td>枚举</td><td>用户定义的整数常量集合</td><td><code>enum Color { RED, GREEN, BLUE };</code></td></tr>
</tbody></table>
</div>
<h2 id="数组array"><a class="header" href="#数组array">数组（Array）</a></h2>
<p>数组用于存储<strong>相同类型元素的固定长度序列</strong>，在内存中是连续存放的。</p>
<pre><code class="language-cpp">int numbers[5] = {1, 2, 3, 4, 5};
std::cout &lt;&lt; numbers[2]; // 输出 3
</code></pre>
<ul>
<li>
<p><strong>下标从 0 开始</strong>，越界访问会导致未定义行为（Undefined Behavior）。</p>
</li>
<li>
<p>在函数参数中，数组会<strong>退化为指针</strong>：</p>
<pre><code class="language-cpp">void printArray(int arr[], int size); // 等价于 void printArray(int* arr, int size);
</code></pre>
</li>
<li>
<p>若需要安全的动态数组，请使用 <code>std::vector</code>。</p>
</li>
</ul>
<h2 id="指针pointer"><a class="header" href="#指针pointer">指针（Pointer）</a></h2>
<p>指针是存储变量地址的变量，是 C++ 的核心特性之一。</p>
<pre><code class="language-cpp">int a = 10;
int* p = &amp;a;    // 指针p指向a
std::cout &lt;&lt; *p; // 输出10
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li><code>*</code> 用于定义或解引用指针；</li>
<li><code>&amp;</code> 用于取地址；</li>
<li>指针类型必须与目标对象类型一致；</li>
<li><code>nullptr</code> 表示空指针（C++11 引入）。</li>
</ul>
<p><strong>常见错误：</strong></p>
<ul>
<li>
<p>解引用空指针或野指针会导致崩溃；</p>
</li>
<li>
<p>动态内存需成对使用：</p>
<pre><code class="language-cpp">int* p = new int(5);
delete p;
</code></pre>
</li>
</ul>
<p>推荐使用智能指针（<code>std::unique_ptr</code>, <code>std::shared_ptr</code>）来避免内存泄漏。</p>
<h2 id="引用reference"><a class="header" href="#引用reference">引用（Reference）</a></h2>
<p>引用是另一个变量的<strong>别名</strong>，必须在定义时初始化。</p>
<pre><code class="language-cpp">int value = 10;
int&amp; ref = value;
ref = 20; // value 也变为 20
</code></pre>
<ul>
<li>
<p>引用不能为空；</p>
</li>
<li>
<p>绑定后不能再更改引用目标；</p>
</li>
<li>
<p>常用于函数参数传递以避免拷贝：</p>
<pre><code class="language-cpp">void modify(int&amp; x) { x *= 2; }
</code></pre>
</li>
</ul>
<p>C++11 还引入了 <strong>右值引用 (<code>T&amp;&amp;</code>)</strong>，用于支持移动语义和完美转发。</p>
<h2 id="函数类型function-type"><a class="header" href="#函数类型function-type">函数类型（Function Type）</a></h2>
<p>函数本身也是一种类型，其类型由<strong>返回值类型</strong>和<strong>参数类型列表</strong>组成。</p>
<pre><code class="language-cpp">int add(int a, int b) { return a + b; }
</code></pre>
<p>函数类型也可通过<strong>指针或引用</strong>使用：</p>
<pre><code class="language-cpp">int (*funcPtr)(int, int) = add;
std::cout &lt;&lt; funcPtr(2, 3); // 输出5
</code></pre>
<p>C++11 提供了更安全的函数封装：</p>
<ul>
<li><code>std::function</code>：可存储任意可调用对象；</li>
<li><code>auto</code> 和 Lambda 表达式使函数类型推导更简洁。</li>
</ul>
<h2 id="结构体struct"><a class="header" href="#结构体struct">结构体（struct）</a></h2>
<p>结构体是用户自定义的复合类型，可包含多个不同类型的成员。</p>
<pre><code class="language-cpp">struct Point {
    int x;
    int y;
};

Point p1 = {10, 20};
std::cout &lt;&lt; p1.x &lt;&lt; ", " &lt;&lt; p1.y;
</code></pre>
<ul>
<li>默认成员访问权限是 <strong>public</strong>；</li>
<li>可以包含成员函数；</li>
<li>可以与类（<code>class</code>）结合使用面向对象设计。</li>
</ul>
<h2 id="类class"><a class="header" href="#类class">类（class）</a></h2>
<p>类是 C++ 的核心概念之一，支持 <strong>封装（Encapsulation）</strong>、<strong>继承（Inheritance）</strong> 和 <strong>多态（Polymorphism）</strong>。</p>
<pre><code class="language-cpp">class Rectangle {
private:
    int width, height;

public:
    Rectangle(int w, int h) : width(w), height(h) {}
    int area() const { return width * height; }
};
</code></pre>
<ul>
<li>成员默认为 <strong>private</strong>；</li>
<li>支持构造函数、析构函数、运算符重载等；</li>
<li>是对象与抽象数据类型的基础。</li>
</ul>
<blockquote>
<p><a href="Basis/Types/../CLass&amp;Object.html">类与对象</a>是C++语言极为重要的内容。</p>
</blockquote>
<h2 id="联合体union"><a class="header" href="#联合体union">联合体（union）</a></h2>
<p>联合体（<code>union</code>）允许多个成员<strong>共用同一块内存</strong>。</p>
<pre><code class="language-cpp">union Data {
    int i;
    float f;
    char c;
};

Data d;
d.i = 10;
std::cout &lt;&lt; d.i; // 输出10
d.f = 3.14;       // i 被覆盖
</code></pre>
<ul>
<li>占用的内存大小等于最大成员的大小；</li>
<li>只能同时存储一个有效成员；</li>
<li>可用于节省内存或实现类型复用。</li>
</ul>
<h2 id="枚举类型enum"><a class="header" href="#枚举类型enum">枚举类型（enum）</a></h2>
<p>枚举用于定义一组具名的整数常量，提高代码可读性与类型安全。</p>
<p>创建枚举类型时，使用关键字 <code>enum</code>。其一般形式为：</p>
<pre><code class="language-cpp">enum 枚举名 {
     标识符[=整型常数],
     标识符[=整型常数],
     ...
     标识符[=整型常数]
} 枚举变量;
</code></pre>
<p>例如，下面的代码定义了一个颜色枚举，变量 <code>c</code> 的类型为 <code>color</code>。最后，<code>c</code> 被赋值为 <code>blue</code>：</p>
<pre><code class="language-cpp">enum color { red, green, blue } c;
c = blue;
</code></pre>
<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。然而，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<code>green</code> 的值为 5：</p>
<pre><code class="language-cpp">enum color { red, green=5, blue };
</code></pre>
<p>在此示例中，<code>blue</code> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，而 <code>red</code> 的值仍然为 0。</p>
<p>C++11 引入 <strong>强类型枚举</strong>：</p>
<pre><code class="language-cpp">enum class Status { OK, ERROR };
Status s = Status::OK;
</code></pre>
<blockquote>
<p>强类型枚举不会隐式转换为整数，作用域也更加安全。</p>
</blockquote>
<h2 id="c类型别名"><a class="header" href="#c类型别名">C++类型别名</a></h2>
<p>类型别名可通过 <code>typedef</code> 或 <code>using</code> 定义。</p>
<div class="table-wrapper"><table><thead><tr><th>关键字</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>typedef</code></td><td>为已有类型定义别名</td><td><code>typedef int MyInt;</code></td></tr>
<tr><td><code>using</code></td><td>C++11 引入的新语法</td><td><code>using MyInt = int;</code></td></tr>
</tbody></table>
</div>
<p>示例：</p>
<pre><code class="language-cpp">typedef unsigned long ulong_t;
using ushort_t = unsigned short;
</code></pre>
<p><code>using</code> 语法更直观，且支持模板别名：</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
using Vec = std::vector&lt;T&gt;;
Vec&lt;int&gt; v = {1, 2, 3};
</code></pre>
<h2 id="c标准库类型"><a class="header" href="#c标准库类型">C++标准库类型</a></h2>
<div class="table-wrapper"><table><thead><tr><th>数据类型</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>std::string</code></td><td>字符串类型</td><td><code>std::string s = "Hello";</code></td></tr>
<tr><td><code>std::vector</code></td><td>动态数组</td><td><code>std::vector&lt;int&gt; v = {1, 2, 3};</code></td></tr>
<tr><td><code>std::array</code></td><td>固定大小数组（C++11 引入）</td><td><code>std::array&lt;int, 3&gt; a = {1, 2, 3};</code></td></tr>
<tr><td><code>std::pair</code></td><td>存储两个值的容器</td><td><code>std::pair&lt;int, float&gt; p(1, 2.0);</code></td></tr>
<tr><td><code>std::map</code></td><td>键值对容器</td><td><code>std::map&lt;int, std::string&gt; m;</code></td></tr>
<tr><td><code>std::set</code></td><td>唯一值集合</td><td><code>std::set&lt;int&gt; s = {1, 2, 3};</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>std::string类型的详细介绍见<a href="Basis/Types/./Character.html">字符串类型</a>章节，其他标准库类型见<a href="Basis/Types/../../STL.html">STL</a>章节。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-字符串类型"><a class="header" href="#c-字符串类型">C++ 字符串类型</a></h1>
<p>C++ 提供了两种主要的字符串表示方式：C 风格字符串和 C++ 引入的 <code>string</code> 类类型。尽管 C++ 中 <code>string</code> 类型在许多情况下更为常用，但 C 风格字符串仍然是 C++ 中的一个重要组成部分，特别是在需要与旧有的 C 库代码兼容时。</p>
<h2 id="c-风格字符串"><a class="header" href="#c-风格字符串">C 风格字符串</a></h2>
<p>C 风格的字符串源自 C 语言，并在 C++ 中继续得到支持。这种字符串表示方式实际上是一个以 null 字符 <code>\0</code> 结尾的字符数组。C 风格字符串的本质是一个一维字符数组，末尾的 null 字符标识了字符串的结束。</p>
<h3 id="c-风格字符串的定义与初始化"><a class="header" href="#c-风格字符串的定义与初始化">C 风格字符串的定义与初始化</a></h3>
<p>您可以通过以下方式定义并初始化一个 C 风格字符串：</p>
<pre><code class="language-cpp">char site[6] = {'H', 'E', 'L', 'L', 'O', '\0'};
</code></pre>
<p>也可以使用更简便的方式进行初始化：</p>
<pre><code class="language-cpp">char site[] = "HELLO";
</code></pre>
<p>在这种情况下，C++ 编译器会自动在字符串的末尾添加 null 字符 <code>\0</code>，无需显式地写出。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
   char s[] = "HELLO"; // 字符串自动以 '\0' 结束

   cout &lt;&lt; s &lt;&lt; endl;

   return 0;
}
</code></pre>
<p>输出：</p>
<pre><code class="language-text">HELLO
</code></pre>
<h3 id="c-风格字符串的常用操作函数"><a class="header" href="#c-风格字符串的常用操作函数">C 风格字符串的常用操作函数</a></h3>
<p>C 风格字符串有许多函数可以进行常见的操作。以下是常用的几个字符串操作函数：</p>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>目的</th></tr></thead><tbody>
<tr><td><code>strcpy(s1, s2)</code></td><td>复制字符串 <code>s2</code> 到字符串 <code>s1</code>。</td></tr>
<tr><td><code>strcat(s1, s2)</code></td><td>将字符串 <code>s2</code> 连接到字符串 <code>s1</code> 的末尾。</td></tr>
<tr><td><code>strlen(s1)</code></td><td>返回字符串 <code>s1</code> 的长度（不包括 <code>\0</code>）。</td></tr>
<tr><td><code>strcmp(s1, s2)</code></td><td>比较两个字符串 <code>s1</code> 和 <code>s2</code>，返回值为 0 时相同，负值表示 <code>s1 &lt; s2</code>，正值表示 <code>s1 &gt; s2</code>。</td></tr>
<tr><td><code>strchr(s1, ch)</code></td><td>返回指针，指向字符串 <code>s1</code> 中字符 <code>ch</code> 的首次出现位置。</td></tr>
<tr><td><code>strstr(s1, s2)</code></td><td>返回指针，指向字符串 <code>s1</code> 中子字符串 <code>s2</code> 的首次出现位置。</td></tr>
</tbody></table>
</div>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main() {
   char str1[13] = "hello";
   char str2[13] = "world";
   char str3[13];
   int len;

   // 复制 str1 到 str3
   strcpy(str3, str1);
   cout &lt;&lt; "strcpy(str3, str1): " &lt;&lt; str3 &lt;&lt; endl;

   // 连接 str1 和 str2
   strcat(str1, str2);
   cout &lt;&lt; "strcat(str1, str2): " &lt;&lt; str1 &lt;&lt; endl;

   // 计算连接后的长度
   len = strlen(str1);
   cout &lt;&lt; "strlen(str1): " &lt;&lt; len &lt;&lt; endl;

   return 0;
}
</code></pre>
<p>输出：</p>
<pre><code class="language-text">strcpy(str3, str1): hello
strcat(str1, str2): helloworld
strlen(str1): 10
</code></pre>
<h2 id="c-中的-string-类"><a class="header" href="#c-中的-string-类">C++ 中的 <code>string</code> 类</a></h2>
<p>C++ 标准库提供了 <code>string</code> 类，它是 C 风格字符串的现代替代品。<code>string</code> 类提供了丰富的成员函数，支持字符串的动态操作，简化了字符串处理过程，并且避免了 C 风格字符串的许多潜在问题。</p>
<h3 id="string-类基本操作"><a class="header" href="#string-类基本操作"><code>string</code> 类基本操作</a></h3>
<p>C++ 中的 <code>string</code> 类提供了方便的字符串处理方法，使得字符串操作变得更加高效和直观。以下是一些常见的操作。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
   string str1 = "hello";
   string str2 = "world";
   string str3;
   int len;

   // 复制 str1 到 str3
   str3 = str1;
   cout &lt;&lt; "str3: " &lt;&lt; str3 &lt;&lt; endl;

   // 连接 str1 和 str2
   str3 = str1 + str2;
   cout &lt;&lt; "str1 + str2: " &lt;&lt; str3 &lt;&lt; endl;

   // 计算连接后的总长度
   len = str3.size();
   cout &lt;&lt; "str3.size(): " &lt;&lt; len &lt;&lt; endl;

   return 0;
}
</code></pre>
<p>输出：</p>
<pre><code class="language-text">str3: hello
str1 + str2: helloworld
str3.size(): 10
</code></pre>
<h3 id="string-类的常用成员函数"><a class="header" href="#string-类的常用成员函数"><code>string</code> 类的常用成员函数</a></h3>
<p><code>string</code> 类提供了多种函数来执行常见的字符串操作，常见的成员函数包括：</p>
<ul>
<li><code>append(str)</code>：将 <code>str</code> 追加到当前字符串末尾。</li>
<li><code>insert(pos, str)</code>：在位置 <code>pos</code> 处插入字符串 <code>str</code>。</li>
<li><code>erase(pos, len)</code>：从位置 <code>pos</code> 开始，删除 <code>len</code> 个字符。</li>
<li><code>substr(pos, len)</code>：返回从位置 <code>pos</code> 开始的长度为 <code>len</code> 的子字符串。</li>
<li><code>find(str)</code>：返回子字符串 <code>str</code> 在当前字符串中首次出现的位置。</li>
<li><code>replace(pos, len, str)</code>：将当前位置 <code>pos</code> 开始的 <code>len</code> 个字符替换为字符串 <code>str</code>。</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
    string str = "Hello, world!";

    // 获取子字符串
    string sub = str.substr(7, 5);  // 从位置 7 开始，获取 5 个字符
    cout &lt;&lt; "Substring: " &lt;&lt; sub &lt;&lt; endl;

    // 查找字符 'w' 在字符串中的位置
    size_t pos = str.find('w');
    cout &lt;&lt; "'w' found at: " &lt;&lt; pos &lt;&lt; endl;

    // 替换子字符串
    str.replace(7, 5, "C++");
    cout &lt;&lt; "After replace: " &lt;&lt; str &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>输出：</p>
<pre><code class="language-text">Substring: world
'w' found at: 7
After replace: Hello, C++!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h1>
<p>类型转换是将一个数据类型的值转换为另一种数据类型的值。在 C++ 中，类型转换主要有四种方式：静态转换、动态转换、常量转换和重新解释转换。每种转换方式有其特定的应用场景和注意事项。</p>
<h2 id="静态转换static-cast"><a class="header" href="#静态转换static-cast">静态转换（Static Cast）</a></h2>
<p>静态转换用于将一个数据类型的值强制转换为另一种类型，通常适用于类型之间存在一定的相似性。例如，可以将 <code>int</code> 类型转换为 <code>float</code> 类型。静态转换并不会进行运行时的类型检查，因此在某些情况下，它可能会导致运行时错误，尤其是在转换较为复杂的对象时。</p>
<p>例如：</p>
<pre><code class="language-cpp">int i = 10;
float f = static_cast&lt;float&gt;(i);  // 将 int 转换为 float
</code></pre>
<h2 id="动态转换dynamic-cast"><a class="header" href="#动态转换dynamic-cast">动态转换（Dynamic Cast）</a></h2>
<p>动态转换是 C++ 中用于在继承体系中进行类型转换的方式。它通常用于将基类指针或引用转换为派生类指针或引用，特别是在涉及多态的场景中。与静态转换不同，动态转换会在运行时检查转换是否合法，确保程序的类型安全。如果转换失败，对于指针类型，它会返回 <code>nullptr</code>，而对于引用类型，则会抛出 <code>std::bad_cast</code> 异常。</p>
<p>例如：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Base {
public:
    virtual ~Base() = default;  // 基类必须有虚函数
};

class Derived : public Base {
public:
    void show() {
        std::cout &lt;&lt; "Derived class method" &lt;&lt; std::endl;
    }
};

int main() {
    Base* ptr_base = new Derived;  // 基类指针指向派生类对象

    // 将基类指针转换为派生类指针
    Derived* ptr_derived = dynamic_cast&lt;Derived*&gt;(ptr_base);

    if (ptr_derived) {
        ptr_derived-&gt;show();  // 成功转换，调用派生类方法
    } else {
        std::cout &lt;&lt; "Dynamic cast failed!" &lt;&lt; std::endl;
    }

    delete ptr_base;
    return 0;
}
</code></pre>
<p>输出：</p>
<pre><code class="language-text">Derived class method
</code></pre>
<p>在转换引用时，也可以使用 <code>dynamic_cast</code>，不过如果转换失败，它会抛出异常：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

class Base {
public:
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    void show() {
        std::cout &lt;&lt; "Derived class method" &lt;&lt; std::endl;
    }
};

int main() {
    Derived derived_obj;
    Base&amp; ref_base = derived_obj;  // 基类引用绑定到派生类对象

    try {
        Derived&amp; ref_derived = dynamic_cast&lt;Derived&amp;&gt;(ref_base);
        ref_derived.show();  // 成功转换，调用派生类方法
    } catch (const std::bad_cast&amp; e) {
        std::cout &lt;&lt; "Dynamic cast failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p>输出：</p>
<pre><code class="language-text">Derived class method
</code></pre>
<p>动态转换提供了更高的安全性，确保在程序运行时可以正确地进行类型检查。尽管如此，它相对于静态转换而言，性能开销较高，因为需要进行类型验证。</p>
<h2 id="常量转换const-cast"><a class="header" href="#常量转换const-cast">常量转换（Const Cast）</a></h2>
<p>常量转换（<code>const_cast</code>）用于去除对象的 <code>const</code> 限定符，从而使得一个 <code>const</code> 对象能够被修改。它并不会改变对象的实际类型，只是去掉了 <code>const</code> 属性。这种转换通常用于需要修改原本被声明为常量的对象时，尽管这种做法应谨慎使用。</p>
<p>例如：</p>
<pre><code class="language-cpp">const int i = 10;
int&amp; r = const_cast&lt;int&amp;&gt;(i);  // 去除 const 限定符
</code></pre>
<p>此代码将 <code>const int</code> 转换为普通的 <code>int</code>，使得对 <code>i</code> 的修改变得可能。但请注意，修改一个原本是常量的对象可能导致未定义的行为。</p>
<h2 id="重新解释转换reinterpret-cast"><a class="header" href="#重新解释转换reinterpret-cast">重新解释转换（Reinterpret Cast）</a></h2>
<p>重新解释转换（<code>reinterpret_cast</code>）允许将一个数据类型的值重新解释为另一种数据类型的值。它通常用于在指针类型之间进行转换，不会进行任何类型检查，因此可能会导致未定义的行为。这种转换应谨慎使用，特别是在不同类型之间进行转换时，必须确保数据在内存中的表示是兼容的。</p>
<p>例如：</p>
<pre><code class="language-cpp">int i = 10;
float f = reinterpret_cast&lt;float&amp;&gt;(i);  // 将 int 转换为 float
</code></pre>
<p>这段代码通过 <code>reinterpret_cast</code> 将 <code>int</code> 类型的数据重新解释为 <code>float</code> 类型。然而，重新解释转换的使用非常危险，因为它不会检查类型是否真正兼容。如果目标类型与原类型不兼容，可能会导致程序崩溃或者数据损坏。因此，<code>reinterpret_cast</code> 应该仅在非常确定数据类型兼容的情况下使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自动类型推导"><a class="header" href="#自动类型推导">自动类型推导</a></h1>
<p>在 C++ 中，自动类型推导（type inference）允许编译器根据初始化表达式推断变量的类型，从而减少显式指定类型的需求。C++11 引入了 <code>auto</code> 关键字，它使得变量声明更加简洁和灵活，同时也有助于避免类型错误。</p>
<h2 id="auto-关键字的基本使用"><a class="header" href="#auto-关键字的基本使用"><code>auto</code> 关键字的基本使用</a></h2>
<p><code>auto</code> 关键字让编译器根据初始化表达式推导出变量的类型。在声明变量时，使用 <code>auto</code> 代替类型名称，编译器将自动推断类型。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    auto x = 42;  // 自动推导类型为 int
    auto y = 3.14;  // 自动推导类型为 double

    std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; ", y: " &lt;&lt; y &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>在这个例子中，<code>auto</code> 自动推导出 <code>x</code> 的类型为 <code>int</code>，<code>y</code> 的类型为 <code>double</code>，根据其初始化值。无需显式地指定类型。</p>
<p>输出：</p>
<pre><code class="language-text">x: 42, y: 3.14
</code></pre>
<h2 id="auto-与容器"><a class="header" href="#auto-与容器"><code>auto</code> 与容器</a></h2>
<p><code>auto</code> 在处理容器时非常有用，尤其是当容器类型复杂且冗长时，使用 <code>auto</code> 可以简化代码并提高可读性。C++11 引入了范围-based <code>for</code> 循环，配合 <code>auto</code> 使用可以轻松地遍历容器。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};

    // 使用 auto 遍历容器
    for (auto&amp; v : vec) {
        std::cout &lt;&lt; v &lt;&lt; " ";
    }

    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>在此示例中，<code>auto</code> 用来自动推导容器元素的类型。由于我们希望修改容器中的元素，所以使用了 <code>auto&amp;</code> 来获取元素的引用。</p>
<p>输出：</p>
<pre><code class="language-text">1 2 3 4 5
</code></pre>
<h2 id="auto-和指针"><a class="header" href="#auto-和指针"><code>auto</code> 和指针</a></h2>
<p>在使用指针时，<code>auto</code> 也可以自动推导出指针的类型。注意，<code>auto</code> 仅推导出变量本身的类型，而不推导出指针指向的类型。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int num = 100;
    int* ptr = &amp;num;

    // 使用 auto 推导指针类型
    auto p = ptr;  // p 将是 int* 类型

    std::cout &lt;&lt; "p points to: " &lt;&lt; *p &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>在这个例子中，<code>auto</code> 推导出变量 <code>p</code> 的类型为 <code>int*</code>，与原始指针 <code>ptr</code> 类型相同。</p>
<p>输出：</p>
<pre><code class="language-text">p points to: 100
</code></pre>
<h2 id="auto-与函数返回类型"><a class="header" href="#auto-与函数返回类型"><code>auto</code> 与函数返回类型</a></h2>
<p><code>auto</code> 不仅可以用于变量声明，还可以用于函数的返回类型。当返回类型较为复杂或需要根据返回的表达式推导时，<code>auto</code> 可以简化代码。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

auto get_sum(const std::vector&lt;int&gt;&amp; vec) {
    int sum = 0;
    for (auto v : vec) {
        sum += v;
    }
    return sum;  // 返回类型由 auto 自动推导
}

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    std::cout &lt;&lt; "Sum: " &lt;&lt; get_sum(vec) &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>在这个示例中，<code>auto</code> 用于函数 <code>get_sum</code> 的返回类型，编译器根据 <code>sum</code> 变量的类型推导出返回值的类型。</p>
<p>输出：</p>
<pre><code class="language-text">Sum: 15
</code></pre>
<h2 id="auto-与模板"><a class="header" href="#auto-与模板"><code>auto</code> 与模板</a></h2>
<p><code>auto</code> 也可以与模板结合使用，尤其是在模板函数中，允许推导类型从而使得函数更加灵活。使用 <code>auto</code> 可以避免显式指定模板参数，从而简化模板代码。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

template &lt;typename T&gt;
auto add(T a, T b) {
    return a + b;  // 返回类型自动推导
}

int main() {
    std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl;    // 输出 3
    std::cout &lt;&lt; add(1.5, 2.5) &lt;&lt; std::endl; // 输出 4.0

    return 0;
}
</code></pre>
<p>在这个示例中，<code>auto</code> 自动推导 <code>add</code> 函数的返回类型，无论是整型还是浮点型，都能正确处理。</p>
<p>输出：</p>
<pre><code class="language-text">3
4
</code></pre>
<h2 id="注意"><a class="header" href="#注意">注意</a></h2>
<ol>
<li>
<p><code>auto</code> 不能用于函数参数类型
<code>auto</code> 只能用于变量声明和返回类型，不能用于函数的参数类型。例如，以下代码是错误的：</p>
<pre><code class="language-cpp">auto add(auto a, auto b) { // 错误，auto 不能用于函数参数类型
    return a + b;
}
</code></pre>
</li>
<li>
<p><code>auto</code> 与引用、常量结合
当使用 <code>auto</code> 时，变量的类型是根据初始化表达式的类型来推导的。如果需要引用或常量，应该明确使用 <code>auto&amp;</code> 或 <code>const auto&amp;</code> 来推导引用类型或常量类型。</p>
<pre><code class="language-cpp">const auto&amp; ref = some_variable; // 推导为 const 引用
</code></pre>
</li>
<li>
<p>类型推导的限制
编译器根据初始化表达式推导类型，但不能从不完整的类型推导。因此，必须确保变量在声明时能够通过表达式推导出类型。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量与常量"><a class="header" href="#变量与常量">变量与常量</a></h1>
<h2 id="一基本概念"><a class="header" href="#一基本概念">一、基本概念</a></h2>
<p>在 C++ 中，<strong>变量 (Variable)</strong> 是内存中的一块可命名的存储空间，用于保存数据值。
<strong>常量 (Constant)</strong> 则是在程序执行期间<strong>不能被修改</strong>的值。</p>
<p>变量与常量是程序存储数据和表达逻辑的基础。</p>
<h2 id="二变量-variable"><a class="header" href="#二变量-variable">二、变量 (Variable)</a></h2>
<h3 id="1-定义变量"><a class="header" href="#1-定义变量">1. 定义变量</a></h3>
<p>变量在使用前必须定义。定义时需指定类型，并可选地赋初值。</p>
<pre><code class="language-cpp">int age = 20;        // 定义并初始化一个整型变量
double weight;       // 定义一个浮点型变量，但未初始化
char grade = 'A';    // 定义并初始化一个字符型变量
</code></pre>
<blockquote>
<p>建议始终初始化变量，避免使用未定义的值（否则可能产生未定义行为）。</p>
</blockquote>
<h3 id="2-变量的命名规则"><a class="header" href="#2-变量的命名规则">2. 变量的命名规则</a></h3>
<p>变量的命名要求符合一定的命名规则，具体可参考<a href="Basis/./Concept/Naming_Rules.html">命名规则</a>，可简要总结为：</p>
<ol>
<li>
<p>只能包含字母、数字和下划线 <code>_</code></p>
</li>
<li>
<p>不能以数字开头</p>
</li>
<li>
<p>区分大小写 (<code>score</code> 与 <code>Score</code> 不同)</p>
</li>
<li>
<p>不能使用 C++ 关键字 (<code>int</code>, <code>return</code> 等)</p>
</li>
<li>
<p>应体现变量含义，例如：</p>
<pre><code class="language-cpp">int studentCount;  // 好
int sc;            // 不推荐
</code></pre>
</li>
</ol>
<h3 id="3-变量的作用域与生命周期"><a class="header" href="#3-变量的作用域与生命周期">3. 变量的作用域与生命周期</a></h3>
<h4 id="1作用域-scope"><a class="header" href="#1作用域-scope">(1)作用域 (Scope)</a></h4>
<p>变量的可见范围取决于其定义位置：</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>定义位置</th><th>可见范围</th></tr></thead><tbody>
<tr><td>局部变量</td><td>函数或代码块内</td><td>仅在当前函数或块中可见</td></tr>
<tr><td>全局变量</td><td>所有函数外部</td><td>在整个文件中可见</td></tr>
</tbody></table>
</div>
<pre><code class="language-cpp">int globalVar = 10;  // 全局变量

void func() {
    int localVar = 5;  // 局部变量
}
</code></pre>
<h4 id="2生命周期-lifetime"><a class="header" href="#2生命周期-lifetime">(2)生命周期 (Lifetime)</a></h4>
<ul>
<li><strong>局部变量</strong>：进入作用域时创建，离开作用域时销毁。</li>
<li><strong>全局变量/静态变量</strong>：程序启动时创建，程序结束时销毁。</li>
</ul>
<pre><code class="language-cpp">void counter() {
    static int count = 0; // 静态局部变量，只初始化一次
    count++;
    std::cout &lt;&lt; count &lt;&lt; std::endl;
}
</code></pre>
<h3 id="4-变量的存储类型说明符"><a class="header" href="#4-变量的存储类型说明符">4. 变量的存储类型说明符</a></h3>
<div class="table-wrapper"><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody>
<tr><td><code>auto</code></td><td>自动类型推断（C++11 引入）</td></tr>
<tr><td><code>register</code></td><td>建议编译器将变量存储在寄存器中（已过时）</td></tr>
<tr><td><code>static</code></td><td>使局部变量在函数多次调用间保持值不变</td></tr>
<tr><td><code>extern</code></td><td>引用外部定义的变量</td></tr>
<tr><td><code>mutable</code></td><td>允许在 <code>const</code> 对象中修改该成员（仅类成员有效）</td></tr>
</tbody></table>
</div>
<pre><code class="language-cpp">extern int count; // 声明外部变量
auto x = 3.14;    // 类型自动推断为 double
</code></pre>
<blockquote>
<p>还有更多的变量修饰符，详见<a href="Basis/./Types/Fundamental_Types.html">基本数据类型</a>。</p>
</blockquote>
<h2 id="三常量-constant"><a class="header" href="#三常量-constant">三、常量 (Constant)</a></h2>
<h3 id="1-字面值常量-literal-constant"><a class="header" href="#1-字面值常量-literal-constant">1. 字面值常量 (Literal Constant)</a></h3>
<p>直接出现在代码中的固定值：</p>
<pre><code class="language-cpp">123          // 整数常量
3.14         // 浮点常量
'a'          // 字符常量
"Hello"      // 字符串常量
true, false  // 布尔常量
</code></pre>
<blockquote>
<p>有时候会以宏定义的方式存在，例如<code>#define pi 3.14</code>，在预处理阶段完成替换处理，本质上还是字面值常量。</p>
<p>使用宏替换的方式，被替换的常量在编译出来的二进制中会重复存在，因此使用<code>constexpr</code>会提高空间利用率。</p>
</blockquote>
<h3 id="2-const-常量"><a class="header" href="#2-const-常量">2. <code>const</code> 常量</a></h3>
<p><code>const</code> 修饰的变量一旦初始化，其值不能被修改，因此<code>const</code>常量本质上是不可变化的变量：</p>
<pre><code class="language-cpp">const double PI = 3.14159;
PI = 3.14; // 错误：不能修改常量
</code></pre>
<h4 id="常量指针与指向常量的指针"><a class="header" href="#常量指针与指向常量的指针">常量指针与指向常量的指针</a></h4>
<div class="table-wrapper"><table><thead><tr><th>形式</th><th>含义</th></tr></thead><tbody>
<tr><td><code>const int* p</code></td><td>指针指向的值不能改</td></tr>
<tr><td><code>int* const p</code></td><td>指针本身不能改</td></tr>
<tr><td><code>const int* const p</code></td><td>值与指针均不可改</td></tr>
</tbody></table>
</div>
<h3 id="3-constexpr-常量表达式c11-起"><a class="header" href="#3-constexpr-常量表达式c11-起">3. <code>constexpr</code> 常量表达式（C++11 起）</a></h3>
<p><code>constexpr</code> 表示在<strong>编译期即可确定值</strong>的常量。它比 <code>const</code> 更严格：</p>
<pre><code class="language-cpp">constexpr int max_size = 100;
constexpr int square(int x) { return x * x; }

int arr[square(4)]; // 编译期确定数组大小
</code></pre>
<blockquote>
<p><code>const</code> 表示<strong>值不可改</strong>，而 <code>constexpr</code> 表示<strong>在编译时确定值</strong>。</p>
</blockquote>
<h3 id="4-枚举常量-enumeration"><a class="header" href="#4-枚举常量-enumeration">4. 枚举常量 (Enumeration)</a></h3>
<p>枚举用于定义一组命名的整型常量：</p>
<pre><code class="language-cpp">enum Color { RED, GREEN, BLUE };
Color c = GREEN;
</code></pre>
<p>自定义起始值：</p>
<pre><code class="language-cpp">enum ErrorCode { OK = 0, NotFound = 404, ServerError = 500 };
</code></pre>
<h2 id="4-变量与常量的对比"><a class="header" href="#4-变量与常量的对比">4. 变量与常量的对比</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>变量</th><th>常量</th></tr></thead><tbody>
<tr><td>值是否可修改</td><td>可修改</td><td>不可修改</td></tr>
<tr><td>是否必须初始化</td><td>否（但推荐）</td><td>是</td></tr>
<tr><td>存储位置</td><td>栈 / 堆 / 静态区</td><td>通常在只读区</td></tr>
<tr><td>示例</td><td><code>int x = 5;</code></td><td><code>const int x = 5;</code></td></tr>
</tbody></table>
</div>
<h2 id="5-示例代码"><a class="header" href="#5-示例代码">5. 示例代码</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

constexpr double PI = 3.14159;

int main() {
    int radius = 5;
    const double area = PI * radius * radius;

    cout &lt;&lt; "半径：" &lt;&lt; radius &lt;&lt; endl;
    cout &lt;&lt; "圆面积：" &lt;&lt; area &lt;&lt; endl;

    // area = 100; // 常量不可修改
    return 0;
}
</code></pre>
<p>输出：</p>
<pre><code class="language-text">半径：5
圆面积：78.5397
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="控制结构control-structures"><a class="header" href="#控制结构control-structures">控制结构（Control Structures）</a></h1>
<p>在 C++ 中，控制结构用于控制程序语句的执行顺序。C++ 的控制流主要分为三种类型：</p>
<ol>
<li><strong>顺序结构</strong>：从上到下依次执行语句，是程序的默认执行方式。</li>
<li><strong>选择结构</strong>：根据条件判断，执行不同的分支语句。</li>
<li><strong>循环结构</strong>：重复执行一段代码，直到某个条件满足为止。</li>
</ol>
<p>在理解控制结构时，最关键的是掌握<strong>表达式求值时机</strong>、<strong>作用域规则</strong>与<strong>循环/分支退出机制</strong>。</p>
<h2 id="一循环结构loop-structure"><a class="header" href="#一循环结构loop-structure">一、循环结构（Loop Structure）</a></h2>
<p>循环结构的本质是<strong>在某个条件满足时重复执行代码块</strong>。
C++ 提供了三种主要循环语法：<code>for</code>、<code>while</code> 和 <code>do...while</code>。</p>
<p>虽然三者都能实现循环逻辑，但它们在<strong>执行顺序</strong>与<strong>条件判断时机</strong>上存在显著差异。</p>
<h3 id="1-for-循环"><a class="header" href="#1-for-循环">1. <code>for</code> 循环</a></h3>
<pre><code class="language-cpp">for (初始化表达式; 条件表达式; 迭代表达式) {
    // 循环体
}
</code></pre>
<p>在执行时，<code>for</code> 循环遵循如下过程：</p>
<ol>
<li><strong>初始化表达式</strong>在循环开始时执行一次；</li>
<li>计算<strong>条件表达式</strong>，若为 <code>true</code>，则进入循环体；</li>
<li>执行循环体中的语句；</li>
<li>执行<strong>迭代表达式</strong>（通常为自增或自减操作）；</li>
<li>再次判断条件表达式；</li>
<li>若条件仍为真，继续循环；否则退出循环。</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    for (int i = 0; i &lt; 5; ++i) {
        cout &lt;&lt; "当前 i = " &lt;&lt; i &lt;&lt; endl;
    }
}
</code></pre>
<p>程序执行顺序如下：</p>
<pre><code class="language-text">初始化：i = 0
判断条件：i &lt; 5 → true
执行循环体：输出 i
迭代表达式：i++
再判断...
</code></pre>
<ul>
<li>
<p><strong>局部作用域</strong>：在 <code>for</code> 循环中声明的变量（如 <code>int i</code>）仅在循环内部可见，循环结束后变量被销毁。</p>
</li>
<li>
<p><strong>可省略项</strong>：</p>
<pre><code class="language-cpp">for (;;) {
    // 无限循环
}
</code></pre>
<p>如果条件表达式被省略，默认为 <code>true</code>。</p>
</li>
<li>
<p><strong>循环控制建议</strong>：</p>
<ul>
<li>在循环内部修改循环变量容易出错；</li>
<li>条件表达式应当保证能在有限次迭代后终止，否则会造成死循环。</li>
</ul>
</li>
</ul>
<p>C++11 引入了<strong>基于范围的 for 循环</strong>（range-based for loop）：</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

int main() {
    vector&lt;int&gt; nums = {1, 2, 3, 4, 5};
    for (int x : nums) {
        cout &lt;&lt; x &lt;&lt; " ";
    }
}
</code></pre>
<p>等价于传统形式：</p>
<pre><code class="language-cpp">for (auto it = nums.begin(); it != nums.end(); ++it)
    cout &lt;&lt; *it &lt;&lt; " ";
</code></pre>
<p>这种写法更简洁、安全，也更符合 STL 容器的使用习惯。</p>
<h3 id="2-while-循环"><a class="header" href="#2-while-循环">2. <code>while</code> 循环</a></h3>
<pre><code class="language-cpp">while (条件表达式) {
    // 循环体
}
</code></pre>
<p><code>while</code> 循环先判断条件，再执行循环体。执行流程如下：</p>
<ol>
<li>判断条件；</li>
<li>若条件为 <code>true</code>，执行循环体；</li>
<li>循环体执行完毕后，再次判断条件；</li>
<li>若条件为 <code>false</code>，循环终止。</li>
</ol>
<pre><code class="language-cpp">int i = 0;
while (i &lt; 5) {
    cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;
    ++i;
}
</code></pre>
<p>与 <code>for</code> 相比，<code>while</code> 更适用于<strong>循环次数不确定但终止条件明确</strong>的情况，例如文件读取或网络接收：</p>
<pre><code class="language-cpp">string line;
while (getline(cin, line)) {
    cout &lt;&lt; line &lt;&lt; endl;
}
</code></pre>
<p>这种结构常见于 IO 流循环，因为输入次数事先未知。</p>
<p>一个经典的初学者错误：</p>
<pre><code class="language-cpp">int i = 0;
while (i &lt; 10);
{
    cout &lt;&lt; i &lt;&lt; endl;
    ++i;
}
</code></pre>
<p>这里的分号 <code>;</code> 结束了 <code>while</code> 语句，导致循环体为空。
实际运行时这段代码会陷入死循环，因为条件判断永远为真而循环体无法修改变量。</p>
<h3 id="3-dowhile-循环"><a class="header" href="#3-dowhile-循环">3. <code>do...while</code> 循环</a></h3>
<pre><code class="language-cpp">do {
    // 循环体
} while (条件表达式);
</code></pre>
<p>与 <code>while</code> 不同，<code>do...while</code> <strong>先执行循环体一次，再判断条件</strong>。
因此，无论条件是否为真，循环体至少会被执行一次。</p>
<pre><code class="language-cpp">int n;
do {
    cout &lt;&lt; "请输入一个正数：";
    cin &gt;&gt; n;
} while (n &lt;= 0);
</code></pre>
<p>程序会反复要求输入，直到输入值大于零。
这种结构常用于需要<strong>先执行一次再决定是否继续</strong>的交互逻辑。</p>
<h3 id="4-循环控制语句"><a class="header" href="#4-循环控制语句">4. 循环控制语句</a></h3>
<ul>
<li>
<p><code>break</code> —— 提前结束循环</p>
<p><code>break</code> 用于<strong>立即终止当前循环</strong>或 <code>switch</code> 语句，不会再执行后续的循环体和条件判断。</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; 10; ++i) {
    if (i == 5)
        break;
    cout &lt;&lt; i &lt;&lt; " ";
}
</code></pre>
</li>
<li>
<p><code>continue</code> —— 跳过当前迭代</p>
<p><code>continue</code> 会<strong>跳过本次循环剩余部分</strong>，直接进入下一次条件判断。</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; 10; ++i) {
    if (i % 2 == 0)
        continue; // 跳过偶数
    cout &lt;&lt; i &lt;&lt; " ";
}
</code></pre>
</li>
<li>
<p><code>goto</code> —— 无条件跳转（极少使用）</p>
<pre><code class="language-cpp">int i = 0;
loop_start:
if (i &lt; 5) {
    cout &lt;&lt; i &lt;&lt; endl;
    ++i;
    goto loop_start;
}
</code></pre>
<p>虽然语法合法，但这种写法不符合结构化编程思想，现代 C++ 中几乎不使用。</p>
</li>
</ul>
<h3 id="5-嵌套循环与性能考量"><a class="header" href="#5-嵌套循环与性能考量">5. 嵌套循环与性能考量</a></h3>
<p>循环可以嵌套，例如输出九九乘法表：</p>
<pre><code class="language-cpp">for (int i = 1; i &lt;= 9; ++i) {
    for (int j = 1; j &lt;= i; ++j) {
        cout &lt;&lt; j &lt;&lt; "x" &lt;&lt; i &lt;&lt; "=" &lt;&lt; i * j &lt;&lt; "\t";
    }
    cout &lt;&lt; endl;
}
</code></pre>
<p>嵌套循环会带来<strong>O(n²)</strong> 级别的时间复杂度，因此在数据量大时应当考虑优化：</p>
<ul>
<li>减少内层循环的迭代次数；</li>
<li>将不必要的计算提前至循环外；</li>
<li>使用 <code>break</code> 或条件提前退出。</li>
</ul>
<h2 id="二判断结构selection-structure"><a class="header" href="#二判断结构selection-structure">二、判断结构（Selection Structure）</a></h2>
<p>判断结构的目的是让程序<strong>在不同条件下执行不同语句</strong>。
C++ 提供了两种主要形式：<code>if</code> 与 <code>switch</code>，另有三目运算符用于简单条件判断。</p>
<h3 id="1-if-条件语句"><a class="header" href="#1-if-条件语句">1. <code>if</code> 条件语句</a></h3>
<pre><code class="language-cpp">if (条件表达式) {
    // 条件成立时执行
}
else {
    // 条件不成立时执行
}
</code></pre>
<p>在执行时，编译器首先计算条件表达式的布尔值：</p>
<ul>
<li>若为 <code>true</code>，执行 <code>if</code> 块；</li>
<li>否则执行 <code>else</code> 块（如果存在）。</li>
</ul>
<p>除此以外，<code>if</code>还支持多分支判断：</p>
<pre><code class="language-cpp">if (score &gt;= 90)
    cout &lt;&lt; "优秀";
else if (score &gt;= 80)
    cout &lt;&lt; "良好";
else if (score &gt;= 60)
    cout &lt;&lt; "及格";
else
    cout &lt;&lt; "不及格";
</code></pre>
<p>编译器从上至下依次判断条件表达式。
当某个条件为真时，后续分支将被跳过。</p>
<ul>
<li>短路求值（short-circuit evaluation）</li>
</ul>
<p>逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code> 在判断中具有<strong>短路行为</strong>：</p>
<pre><code class="language-cpp">if (x != 0 &amp;&amp; 10 / x &gt; 1)  // 安全
</code></pre>
<p>若 <code>x == 0</code>，第一个条件为 <code>false</code>，第二个表达式不会被求值，从而避免除零错误。
短路机制是 C++ 逻辑判断中非常重要的性能与安全特性。</p>
<ul>
<li>悬挂 else（dangling else）问题</li>
</ul>
<pre><code class="language-cpp">if (a &gt; 0)
    if (b &gt; 0)
        cout &lt;&lt; "A";
    else
        cout &lt;&lt; "B";
</code></pre>
<p>此时 <code>else</code> 默认匹配<strong>最近的未匹配 if</strong>，即第二个 <code>if</code>。
建议始终使用大括号 <code>{}</code> 明确逻辑边界。</p>
<h3 id="2-switch-语句"><a class="header" href="#2-switch-语句">2. <code>switch</code> 语句</a></h3>
<pre><code class="language-cpp">switch (表达式) {
    case 常量1:
        // 语句
        break;
    case 常量2:
        // 语句
        break;
    default:
        // 默认语句
        break;
}
</code></pre>
<p><code>switch</code> 表达式的值会与每个 <code>case</code> 标签进行匹配，若相等，则从该处开始执行，直到遇到 <code>break</code> 或 <code>switch</code> 结束。</p>
<pre><code class="language-cpp">int day = 3;
switch (day) {
    case 1: cout &lt;&lt; "Monday"; break;
    case 2: cout &lt;&lt; "Tuesday"; break;
    case 3: cout &lt;&lt; "Wednesday"; break;
    default: cout &lt;&lt; "Invalid";
}
</code></pre>
<ul>
<li>
<p>语义分析与注意事项</p>
</li>
<li>
<p><code>switch</code> 的判断值必须是<strong>整数类型或枚举类型</strong>；</p>
</li>
<li>
<p><code>case</code> 标签必须是<strong>常量表达式</strong>；</p>
</li>
<li>
<p>若 <code>break</code> 省略，将导致<strong>贯穿 (fall through)</strong>，继续执行后续分支；</p>
</li>
<li>
<p><code>default</code> 分支可选，但建议始终保留。</p>
</li>
<li>
<p>现代 C++ 的枚举与 <code>switch</code></p>
</li>
</ul>
<pre><code class="language-cpp">enum class Color { Red, Green, Blue };

Color c = Color::Green;
switch (c) {
    case Color::Red: cout &lt;&lt; "Red"; break;
    case Color::Green: cout &lt;&lt; "Green"; break;
    case Color::Blue: cout &lt;&lt; "Blue"; break;
}
</code></pre>
<p>使用 <code>enum class</code> 可避免命名冲突和隐式转换，提高类型安全性。</p>
<h3 id="3-条件运算符三目运算符"><a class="header" href="#3-条件运算符三目运算符">3. 条件运算符（三目运算符）</a></h3>
<p>C++ 提供了简洁的条件表达式：</p>
<pre><code class="language-cpp">表达式1 ? 表达式2 : 表达式3;
</code></pre>
<p>求值逻辑：</p>
<ul>
<li>若表达式1为真，则整个表达式结果为表达式2；</li>
<li>否则结果为表达式3。</li>
</ul>
<p>示例：</p>
<pre><code class="language-cpp">int a = 10, b = 20;
int max = (a &gt; b) ? a : b;
</code></pre>
<p>该语句的效果等价于：</p>
<pre><code class="language-cpp">if (a &gt; b) max = a;
else max = b;
</code></pre>
<p>三目运算符常用于简单赋值，但不适合复杂逻辑，因为可读性较差。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作符operators"><a class="header" href="#操作符operators">操作符（Operators）</a></h1>
<p>操作符（Operator）是 C++ 表达式的核心组成部分，用于对操作数（Operand）进行各种运算、比较或逻辑处理。
在编译阶段，操作符会被转化为相应的汇编指令或函数调用（例如运算符重载时）。</p>
<p>C++ 拥有丰富的操作符体系，并且允许程序员通过<strong>运算符重载</strong>（operator overloading）定义自定义类型的操作方式，从而实现与内置类型一致的自然语法。</p>
<h2 id="一操作符的分类"><a class="header" href="#一操作符的分类">一、操作符的分类</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">类别</th><th style="text-align: left">示例</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: center">算术操作符</td><td style="text-align: left"><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></td><td style="text-align: left">数值计算</td></tr>
<tr><td style="text-align: center">自增/自减操作符</td><td style="text-align: left"><code>++</code>, <code>--</code></td><td style="text-align: left">累加或递减</td></tr>
<tr><td style="text-align: center">关系操作符</td><td style="text-align: left"><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td style="text-align: left">比较</td></tr>
<tr><td style="text-align: center">逻辑操作符</td><td style="text-align: left"><code>&amp;&amp;</code>, <code>||</code>, <code>!</code></td><td style="text-align: left">逻辑判断</td></tr>
<tr><td style="text-align: center">位操作符</td><td style="text-align: left"><code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></td><td style="text-align: left">位级运算</td></tr>
<tr><td style="text-align: center">赋值操作符</td><td style="text-align: left"><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> 等</td><td style="text-align: left">赋值与复合赋值</td></tr>
<tr><td style="text-align: center">条件运算符</td><td style="text-align: left"><code>?:</code></td><td style="text-align: left">三目条件判断</td></tr>
<tr><td style="text-align: center">逗号运算符</td><td style="text-align: left"><code>,</code></td><td style="text-align: left">顺序求值</td></tr>
<tr><td style="text-align: center">成员操作符</td><td style="text-align: left"><code>.</code>, <code>-&gt;</code>, <code>.*</code>, <code>-&gt;*</code></td><td style="text-align: left">成员访问</td></tr>
<tr><td style="text-align: center">指针与地址操作符</td><td style="text-align: left"><code>*</code>, <code>&amp;</code></td><td style="text-align: left">指针解引用与取地址</td></tr>
<tr><td style="text-align: center">类型转换操作符</td><td style="text-align: left"><code>(type)</code>, <code>static_cast</code>, <code>dynamic_cast</code> 等</td><td style="text-align: left">类型转换</td></tr>
<tr><td style="text-align: center">其他特殊操作符</td><td style="text-align: left"><code>sizeof</code>, <code>typeid</code>, <code>new</code>, <code>delete</code></td><td style="text-align: left">特殊用途</td></tr>
</tbody></table>
</div>
<h2 id="二算术操作符arithmetic-operators"><a class="header" href="#二算术操作符arithmetic-operators">二、算术操作符（Arithmetic Operators）</a></h2>
<h3 id="1-基本算术运算"><a class="header" href="#1-基本算术运算">1. 基本算术运算</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: left">含义</th><th style="text-align: left">示例</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>+</code></td><td style="text-align: left">加法</td><td style="text-align: left"><code>a + b</code></td></tr>
<tr><td style="text-align: center"><code>-</code></td><td style="text-align: left">减法</td><td style="text-align: left"><code>a - b</code></td></tr>
<tr><td style="text-align: center"><code>*</code></td><td style="text-align: left">乘法</td><td style="text-align: left"><code>a * b</code></td></tr>
<tr><td style="text-align: center"><code>/</code></td><td style="text-align: left">除法</td><td style="text-align: left"><code>a / b</code></td></tr>
<tr><td style="text-align: center"><code>%</code></td><td style="text-align: left">取余（模运算）</td><td style="text-align: left"><code>a % b</code></td></tr>
</tbody></table>
</div>
<p>示例：</p>
<pre><code class="language-cpp">int a = 10, b = 3;
cout &lt;&lt; a + b &lt;&lt; endl; // 13
cout &lt;&lt; a - b &lt;&lt; endl; // 7
cout &lt;&lt; a * b &lt;&lt; endl; // 30
cout &lt;&lt; a / b &lt;&lt; endl; // 3
cout &lt;&lt; a % b &lt;&lt; endl; // 1
</code></pre>
<h3 id="2-注意事项"><a class="header" href="#2-注意事项">2. 注意事项</a></h3>
<ul>
<li>
<p><strong>整数除法</strong>：两个整数相除结果仍为整数，小数部分会被截断。</p>
</li>
<li>
<p><strong>浮点除法</strong>：若任一操作数为浮点型，则结果为浮点数。</p>
</li>
<li>
<p><strong>取余运算 <code>%</code></strong>：仅适用于整数类型。</p>
</li>
<li>
<p><strong>负数取余</strong>：结果的符号与被除数相同，例如：</p>
<pre><code class="language-cpp">cout &lt;&lt; (-7) % 4; // 输出 -3
</code></pre>
</li>
</ul>
<h2 id="三自增与自减操作符-与---"><a class="header" href="#三自增与自减操作符-与---">三、自增与自减操作符（<code>++</code> 与 <code>--</code>）</a></h2>
<h3 id="1-区分前置与后置"><a class="header" href="#1-区分前置与后置">1. 区分前置与后置</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">形式</th><th style="text-align: left">名称</th><th style="text-align: left">求值顺序</th><th style="text-align: left">示例</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>++i</code></td><td style="text-align: left">前置自增</td><td style="text-align: left">先自增再返回值</td><td style="text-align: left"><code>int a = 1; cout &lt;&lt; ++a; // 输出 2</code></td></tr>
<tr><td style="text-align: center"><code>i++</code></td><td style="text-align: left">后置自增</td><td style="text-align: left">先返回值再自增</td><td style="text-align: left"><code>int a = 1; cout &lt;&lt; a++; // 输出 1</code></td></tr>
</tbody></table>
</div>
<p>同理适用于 <code>--</code>。</p>
<h3 id="2-编译层面的区别"><a class="header" href="#2-编译层面的区别">2. 编译层面的区别</a></h3>
<p>前置自增：</p>
<pre><code class="language-cpp">int&amp; operator++(int&amp; i) { i += 1; return i; }
</code></pre>
<p>后置自增：</p>
<pre><code class="language-cpp">int operator++(int&amp; i, int) { int old = i; ++i; return old; }
</code></pre>
<p>因此后置版本通常会创建临时对象，性能略低。</p>
<h2 id="四关系操作符relational-operators"><a class="header" href="#四关系操作符relational-operators">四、关系操作符（Relational Operators）</a></h2>
<p>用于比较两个值的大小或相等性，结果为 <code>bool</code> 类型。</p>
<pre><code class="language-cpp">int a = 5, b = 10;
cout &lt;&lt; (a &lt; b) &lt;&lt; endl;  // 1
cout &lt;&lt; (a == b) &lt;&lt; endl; // 0
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: left">含义</th><th style="text-align: left">示例</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>==</code></td><td style="text-align: left">等于</td><td style="text-align: left"><code>a == b</code></td></tr>
<tr><td style="text-align: center"><code>!=</code></td><td style="text-align: left">不等于</td><td style="text-align: left"><code>a != b</code></td></tr>
<tr><td style="text-align: center"><code>&lt;</code></td><td style="text-align: left">小于</td><td style="text-align: left"><code>a &lt; b</code></td></tr>
<tr><td style="text-align: center"><code>&gt;</code></td><td style="text-align: left">大于</td><td style="text-align: left"><code>a &gt; b</code></td></tr>
<tr><td style="text-align: center"><code>&lt;=</code></td><td style="text-align: left">小于等于</td><td style="text-align: left"><code>a &lt;= b</code></td></tr>
<tr><td style="text-align: center"><code>&gt;=</code></td><td style="text-align: left">大于等于</td><td style="text-align: left"><code>a &gt;= b</code></td></tr>
</tbody></table>
</div>
<h2 id="五逻辑操作符logical-operators"><a class="header" href="#五逻辑操作符logical-operators">五、逻辑操作符（Logical Operators）</a></h2>
<p>逻辑操作符用于<strong>布尔表达式组合</strong>，返回 <code>true</code> 或 <code>false</code>。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: left">含义</th><th style="text-align: left">示例</th><th style="text-align: left">特性</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&amp;&amp;</code></td><td style="text-align: left">逻辑与</td><td style="text-align: left"><code>(x &gt; 0 &amp;&amp; y &gt; 0)</code></td><td style="text-align: left"><strong>短路</strong>：若左侧为假，右侧不求值</td></tr>
<tr><td style="text-align: center"><code>||</code></td><td style="text-align: left">逻辑或</td><td style="text-align: left"><code>(x &lt; 0 || y &lt; 0)</code></td><td style="text-align: left"><strong>短路</strong>：若左侧为真，右侧不求值</td></tr>
<tr><td style="text-align: center"><code>!</code></td><td style="text-align: left">逻辑非</td><td style="text-align: left"><code>!flag</code></td><td style="text-align: left">取反</td></tr>
</tbody></table>
</div>
<p><strong>短路求值</strong>（short-circuit evaluation）是逻辑运算的重要特性，它不仅提升性能，也避免非法运算（例如除零）。</p>
<pre><code class="language-cpp">if (ptr != nullptr &amp;&amp; *ptr &gt; 10)
    cout &lt;&lt; "安全访问";
</code></pre>
<h2 id="六位操作符bitwise-operators"><a class="header" href="#六位操作符bitwise-operators">六、位操作符（Bitwise Operators）</a></h2>
<p>位操作符直接作用于整数的<strong>二进制表示</strong>。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: left">含义</th><th style="text-align: left">示例</th><th></th><th></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&amp;</code></td><td style="text-align: left">按位与</td><td style="text-align: left"><code>a &amp; b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center">`</td><td style="text-align: left">`</td><td style="text-align: left">按位或</td><td>`a</td><td>b`</td></tr>
<tr><td style="text-align: center"><code>^</code></td><td style="text-align: left">按位异或</td><td style="text-align: left"><code>a ^ b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>~</code></td><td style="text-align: left">按位取反</td><td style="text-align: left"><code>~a</code></td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>&lt;&lt;</code></td><td style="text-align: left">左移</td><td style="text-align: left"><code>a &lt;&lt; n</code> （相当于乘以 2ⁿ）</td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>&gt;&gt;</code></td><td style="text-align: left">右移</td><td style="text-align: left"><code>a &gt;&gt; n</code> （相当于除以 2ⁿ）</td><td></td><td></td></tr>
</tbody></table>
</div>
<p>示例：</p>
<pre><code class="language-cpp">unsigned int a = 5;  // 00000101
unsigned int b = 3;  // 00000011
cout &lt;&lt; (a &amp; b);     // 00000001 -&gt; 1
cout &lt;&lt; (a | b);     // 00000111 -&gt; 7
cout &lt;&lt; (a ^ b);     // 00000110 -&gt; 6
cout &lt;&lt; (~a);        // 11111010 -&gt; 取反
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>位移运算的右操作数必须为非负；</li>
<li>有符号右移的高位填充由实现定义；</li>
<li>通常使用无符号类型进行位操作以避免歧义。</li>
</ul>
<h2 id="七赋值与复合赋值操作符assignment-operators"><a class="header" href="#七赋值与复合赋值操作符assignment-operators">七、赋值与复合赋值操作符（Assignment Operators）</a></h2>
<h3 id="1-基本赋值"><a class="header" href="#1-基本赋值">1. 基本赋值</a></h3>
<pre><code class="language-cpp">int x = 10;
</code></pre>
<h3 id="2-复合赋值"><a class="header" href="#2-复合赋值">2. 复合赋值</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: left">等价形式</th><th></th><th></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>+=</code></td><td style="text-align: left"><code>a = a + b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>-=</code></td><td style="text-align: left"><code>a = a - b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>*=</code></td><td style="text-align: left"><code>a = a * b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>/=</code></td><td style="text-align: left"><code>a = a / b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>%=</code></td><td style="text-align: left"><code>a = a % b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>&amp;=</code></td><td style="text-align: left"><code>a = a &amp; b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center">`</td><td style="text-align: left">=`</td><td>`a = a</td><td>b`</td></tr>
<tr><td style="text-align: center"><code>^=</code></td><td style="text-align: left"><code>a = a ^ b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>&lt;&lt;=</code></td><td style="text-align: left"><code>a = a &lt;&lt; b</code></td><td></td><td></td></tr>
<tr><td style="text-align: center"><code>&gt;&gt;=</code></td><td style="text-align: left"><code>a = a &gt;&gt; b</code></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>复合赋值的优点是<strong>只计算一次左值</strong>，因此在复杂左值表达式中效率更高：</p>
<pre><code class="language-cpp">arr[getIndex()] += 10; // getIndex() 只调用一次
</code></pre>
<h2 id="八条件运算符ternary-operator"><a class="header" href="#八条件运算符ternary-operator">八、条件运算符（Ternary Operator）</a></h2>
<p>三目运算符语法：</p>
<pre><code class="language-cpp">条件 ? 表达式1 : 表达式2;
</code></pre>
<p>示例：</p>
<pre><code class="language-cpp">int max = (a &gt; b) ? a : b;
</code></pre>
<p>等价于：</p>
<pre><code class="language-cpp">if (a &gt; b)
    max = a;
else
    max = b;
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>运算符返回一个值，因此可嵌入表达式；</li>
<li>但应避免多层嵌套，影响可读性。</li>
</ul>
<h2 id="九逗号运算符comma-operator"><a class="header" href="#九逗号运算符comma-operator">九、逗号运算符（Comma Operator）</a></h2>
<p>逗号运算符从左到右依次求值，整个表达式的结果是<strong>最后一个表达式的值</strong>：</p>
<pre><code class="language-cpp">int a = (b = 3, b + 2); // b=3执行后，再计算b+2，a=5
</code></pre>
<p>在 <code>for</code> 循环中常见：</p>
<pre><code class="language-cpp">for (int i = 0, j = 10; i &lt; j; ++i, --j)
    cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;
</code></pre>
<h2 id="十成员与指针操作符member--pointer-operators"><a class="header" href="#十成员与指针操作符member--pointer-operators">十、成员与指针操作符（Member &amp; Pointer Operators）</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: left">含义</th><th style="text-align: left">示例</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>.</code></td><td style="text-align: left">访问对象成员</td><td style="text-align: left"><code>obj.member</code></td></tr>
<tr><td style="text-align: center"><code>-&gt;</code></td><td style="text-align: left">访问指针所指对象的成员</td><td style="text-align: left"><code>ptr-&gt;member</code></td></tr>
<tr><td style="text-align: center"><code>.*</code></td><td style="text-align: left">访问对象的成员指针</td><td style="text-align: left"><code>(obj.*ptrMember)</code></td></tr>
<tr><td style="text-align: center"><code>-&gt;*</code></td><td style="text-align: left">通过指针访问成员指针</td><td style="text-align: left"><code>(ptr-&gt;*ptrMember)</code></td></tr>
</tbody></table>
</div>
<p><strong>示例：</strong></p>
<pre><code class="language-cpp">struct Test { int x; void show() { cout &lt;&lt; x; } };
Test t{42};
Test* p = &amp;t;
cout &lt;&lt; t.x;    // 使用 .
cout &lt;&lt; p-&gt;x;   // 使用 -&gt;
</code></pre>
<h2 id="十一指针相关操作符"><a class="header" href="#十一指针相关操作符">十一、指针相关操作符</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: left">作用</th><th style="text-align: left">示例</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&amp;</code></td><td style="text-align: left">取地址</td><td style="text-align: left"><code>int* p = &amp;x;</code></td></tr>
<tr><td style="text-align: center"><code>*</code></td><td style="text-align: left">解引用</td><td style="text-align: left"><code>cout &lt;&lt; *p;</code></td></tr>
</tbody></table>
</div>
<p>这两个符号在声明与使用中含义不同：</p>
<pre><code class="language-cpp">int* p;   // 声明指针类型
*p = 10;  // 解引用赋值
</code></pre>
<h2 id="十二类型转换操作符cast-operators"><a class="header" href="#十二类型转换操作符cast-operators">十二、类型转换操作符（Cast Operators）</a></h2>
<h3 id="1-c-风格强制类型转换"><a class="header" href="#1-c-风格强制类型转换">1. C 风格强制类型转换</a></h3>
<pre><code class="language-cpp">int a = 10;
double b = (double)a;
</code></pre>
<h3 id="2-c-风格强制类型转换"><a class="header" href="#2-c-风格强制类型转换">2. C++ 风格强制类型转换</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>static_cast&lt;T&gt;(expr)</code></td><td style="text-align: left">编译期已知的安全类型转换</td></tr>
<tr><td style="text-align: center"><code>dynamic_cast&lt;T&gt;(expr)</code></td><td style="text-align: left">用于多态类型的安全向下转换（运行期检查）</td></tr>
<tr><td style="text-align: center"><code>const_cast&lt;T&gt;(expr)</code></td><td style="text-align: left">去除或添加 <code>const</code> 属性</td></tr>
<tr><td style="text-align: center"><code>reinterpret_cast&lt;T&gt;(expr)</code></td><td style="text-align: left">强制重解释类型（高风险）</td></tr>
</tbody></table>
</div>
<p>示例：</p>
<pre><code class="language-cpp">Base* b = new Derived();
Derived* d = dynamic_cast&lt;Derived*&gt;(b); // 安全类型检查
</code></pre>
<h2 id="十三其他特殊操作符"><a class="header" href="#十三其他特殊操作符">十三、其他特殊操作符</a></h2>
<h3 id="1-sizeof"><a class="header" href="#1-sizeof">1. <code>sizeof</code></a></h3>
<p>返回对象或类型的<strong>字节大小</strong>，结果类型为 <code>size_t</code>：</p>
<pre><code class="language-cpp">cout &lt;&lt; sizeof(int); // 通常为4
</code></pre>
<p>对数组时返回整个数组的大小，而不是指针大小：</p>
<pre><code class="language-cpp">int arr[10];
cout &lt;&lt; sizeof(arr); // 40 (假设int为4字节)
</code></pre>
<h3 id="2-typeid"><a class="header" href="#2-typeid">2. <code>typeid</code></a></h3>
<p>用于在运行时获取类型信息，常与 RTTI（运行时类型识别）配合使用。</p>
<pre><code class="language-cpp">#include &lt;typeinfo&gt;
int a = 5;
cout &lt;&lt; typeid(a).name(); // 输出类型名
</code></pre>
<h3 id="3-new-与-delete"><a class="header" href="#3-new-与-delete">3. <code>new</code> 与 <code>delete</code></a></h3>
<p>动态内存分配与释放：</p>
<pre><code class="language-cpp">int* p = new int(10);
delete p;

int* arr = new int[5];
delete[] arr;
</code></pre>
<p><code>new</code> 会自动调用构造函数，而 <code>delete</code> 调用析构函数。</p>
<h2 id="十四运算符优先级与结合性"><a class="header" href="#十四运算符优先级与结合性">十四、运算符优先级与结合性</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">优先级（高→低）</th><th style="text-align: left">操作符</th><th style="text-align: left">结合方向</th></tr></thead><tbody>
<tr><td style="text-align: center">1</td><td style="text-align: left"><code>::</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: left"><code>()</code> <code>[]</code> <code>-&gt;</code> <code>.</code> <code>++</code> <code>--</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: left"><code>!</code> <code>~</code> <code>++</code> <code>--</code> <code>+</code> <code>-</code> <code>(type)</code> <code>*</code> <code>&amp;</code> <code>sizeof</code> <code>new</code> <code>delete</code></td><td style="text-align: left">右到左</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: left"><code>*</code> <code>/</code> <code>%</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: left"><code>+</code> <code>-</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: left"><code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: left"><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: left"><code>==</code> <code>!=</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">9</td><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">10</td><td style="text-align: left"><code>^</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">11</td><td style="text-align: left"><code>|</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">12</td><td style="text-align: left"><code>&amp;&amp;</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">13</td><td style="text-align: left"><code>||</code></td><td style="text-align: left">左到右</td></tr>
<tr><td style="text-align: center">14</td><td style="text-align: left"><code>?:</code></td><td style="text-align: left">右到左</td></tr>
<tr><td style="text-align: center">15</td><td style="text-align: left"><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> 等</td><td style="text-align: left">右到左</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: left"><code>,</code></td><td style="text-align: left">左到右</td></tr>
</tbody></table>
</div>
<p>建议使用<strong>括号明确运算顺序</strong>，尤其在混合表达式中。</p>
<h2 id="十五运算符重载operator-overloading"><a class="header" href="#十五运算符重载operator-overloading">十五、运算符重载（Operator Overloading）</a></h2>
<p>C++ 允许为自定义类型定义运算符行为。例如：</p>
<pre><code class="language-cpp">class Vector {
public:
    int x, y;
    Vector(int x, int y): x(x), y(y) {}
    Vector operator+(const Vector&amp; v) const {
        return Vector(x + v.x, y + v.y);
    }
};
</code></pre>
<p>使用：</p>
<pre><code class="language-cpp">Vector a(1, 2), b(3, 4);
Vector c = a + b; // 等价于 a.operator+(b)
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>不能重载 <code>.</code>、<code>::</code>、<code>?:</code>、<code>sizeof</code>；</li>
<li>运算符重载不会改变操作符优先级；</li>
<li>应保证语义一致性（例如重载 <code>==</code> 时应与 <code>!=</code> 保持逻辑对称）。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数-functions"><a class="header" href="#函数-functions">函数 (Functions)</a></h1>
<p>函数是 C++ 程序的基本组成部分，它们用于将程序分解为可管理、可重复使用的代码块。</p>
<h2 id="一函数的基本概念"><a class="header" href="#一函数的基本概念">一、函数的基本概念</a></h2>
<h3 id="1-定义"><a class="header" href="#1-定义">1. 定义</a></h3>
<p>函数是一段执行特定任务的命名代码块。</p>
<h3 id="2-优点"><a class="header" href="#2-优点">2. 优点</a></h3>
<ul>
<li><strong>模块化 (Modularity):</strong> 使程序结构清晰，易于理解和维护。</li>
<li><strong>代码重用 (Code Reusability):</strong> 一次编写，多次调用，避免重复劳动。</li>
<li><strong>简化调试 (Easier Debugging):</strong> 易于隔离和测试代码。</li>
</ul>
<h2 id="二函数的构成要素"><a class="header" href="#二函数的构成要素">二、函数的构成要素</a></h2>
<p>一个函数通常由以下几个部分组成：</p>
<h3 id="1-函数原型-function-prototype--函数声明-declaration"><a class="header" href="#1-函数原型-function-prototype--函数声明-declaration">1. 函数原型 (Function Prototype) / 函数声明 (Declaration)</a></h3>
<p>告诉编译器函数的名称、返回类型和参数列表，但没有函数体。</p>
<p><strong>格式:</strong></p>
<pre><code class="language-cpp">返回类型 函数名(参数类型 参数名, ...);
</code></pre>
<p><strong>示例:</strong></p>
<pre><code class="language-cpp">int add(int a, int b); // 函数原型
</code></pre>
<ul>
<li><strong>注意:</strong> 函数原型通常放在 <code>main</code> 函数之前或头文件 (<code>.h</code> 文件) 中。</li>
</ul>
<h3 id="2-函数定义-function-definition"><a class="header" href="#2-函数定义-function-definition">2. 函数定义 (Function Definition)</a></h3>
<p>包含函数头和函数体（实际执行的代码）。</p>
<p><strong>格式:</strong></p>
<pre><code class="language-cpp">返回类型 函数名(参数类型 参数名, ...)
{
    // 函数体：执行任务的代码
    // ...
    return 表达式; // 如果返回类型不是 void
}
</code></pre>
<p><strong>示例:</strong></p>
<pre><code class="language-cpp">int add(int a, int b) // 函数头
{
    // 函数体
    return a + b;
}
</code></pre>
<h3 id="3-函数调用-function-call"><a class="header" href="#3-函数调用-function-call">3. 函数调用 (Function Call)</a></h3>
<p>在程序中执行函数。</p>
<p><strong>格式:</strong></p>
<pre><code class="language-cpp">函数名(实参1, 实参2, ...);
</code></pre>
<p><strong>示例:</strong></p>
<pre><code class="language-cpp">int sum = add(5, 3); // 调用 add 函数，5 和 3 是实参
</code></pre>
<h2 id="三函数的关键要素"><a class="header" href="#三函数的关键要素">三、函数的关键要素</a></h2>
<h3 id="1-返回类型-return-type"><a class="header" href="#1-返回类型-return-type">1. 返回类型 (Return Type)</a></h3>
<p>函数执行完毕后返回给调用者的值的类型。</p>
<ul>
<li>可以是任何有效的数据类型（如 <code>int</code>, <code>double</code>, <code>bool</code>, 自定义类型等）。</li>
<li><strong><code>void</code>:</strong> 如果函数不返回任何值，则使用 <code>void</code>。</li>
</ul>
<h3 id="2-函数名-function-name"><a class="header" href="#2-函数名-function-name">2. 函数名 (Function Name)</a></h3>
<p>用于唯一标识函数。遵循 C++ 命名规则。</p>
<h3 id="3-参数-parameters--形参-formal-parameters"><a class="header" href="#3-参数-parameters--形参-formal-parameters">3. 参数 (Parameters) / 形参 (Formal Parameters)</a></h3>
<p>定义在函数头中，用于接收调用者传递的数据。</p>
<ul>
<li><strong>格式:</strong> <code>类型 名称</code> (例如 <code>int x</code>)</li>
</ul>
<h3 id="4-实参-arguments"><a class="header" href="#4-实参-arguments">4. 实参 (Arguments)</a></h3>
<p>调用函数时传递给形参的实际值。</p>
<h3 id="5-return-语句"><a class="header" href="#5-return-语句">5. <code>return</code> 语句</a></h3>
<p>用于：</p>
<ul>
<li><strong>返回值:</strong> 将一个值返回给调用者。</li>
<li><strong>结束执行:</strong> 立即终止函数的执行。</li>
<li><strong>注意:</strong> 对于返回类型非 <code>void</code> 的函数，必须有 <code>return</code> 语句返回一个与返回类型兼容的值。</li>
</ul>
<h2 id="四参数传递-argument-passing"><a class="header" href="#四参数传递-argument-passing">四、参数传递 (Argument Passing)</a></h2>
<p>函数调用时，将实参的值复制或引用到形参中，主要有三种方式：</p>
<h3 id="1-值传递-pass-by-value-最常用"><a class="header" href="#1-值传递-pass-by-value-最常用">1. 值传递 (Pass by Value) <strong>(最常用)</strong></a></h3>
<ul>
<li>
<p><strong>机制:</strong> 将实参的值复制给形参。</p>
</li>
<li>
<p><strong>效果:</strong> 函数内部对形参的任何修改，<strong>不会</strong> 影响到外部的实参。</p>
</li>
<li>
<p><strong>声明:</strong></p>
<pre><code class="language-cpp">void func(int x); // x 是一个副本
</code></pre>
</li>
</ul>
<h3 id="2-地址传递-pass-by-pointer-c-风格c-中不推荐"><a class="header" href="#2-地址传递-pass-by-pointer-c-风格c-中不推荐">2. 地址传递 (Pass by Pointer) <strong>(C 风格，C++ 中不推荐)</strong></a></h3>
<ul>
<li>
<p><strong>机制:</strong> 传递实参的内存地址（指针）。</p>
</li>
<li>
<p><strong>效果:</strong> 函数可以通过指针修改实参的值。</p>
</li>
<li>
<p><strong>声明:</strong></p>
<pre><code class="language-cpp">void func(int *ptr); // ptr 是一个指向 int 的指针
</code></pre>
</li>
</ul>
<h3 id="3-引用传递-pass-by-reference-c-推荐"><a class="header" href="#3-引用传递-pass-by-reference-c-推荐">3. 引用传递 (Pass by Reference) <strong>(C++ 推荐)</strong></a></h3>
<ul>
<li>
<p><strong>机制:</strong> 形参成为实参的别名（引用）。</p>
</li>
<li>
<p><strong>效果:</strong> 函数内部对形参的任何修改，<strong>会</strong> 直接影响到外部的实参。</p>
</li>
<li>
<p><strong>声明:</strong></p>
<pre><code class="language-cpp">void func(int &amp;ref); // ref 是实参的引用
</code></pre>
<ul>
<li><strong>优点:</strong> 既能修改外部变量，又避免了指针的复杂性和值传递的开销。</li>
</ul>
</li>
</ul>
<h2 id="五函数的进阶特性"><a class="header" href="#五函数的进阶特性">五、函数的进阶特性</a></h2>
<h3 id="1-默认参数-default-arguments"><a class="header" href="#1-默认参数-default-arguments">1. 默认参数 (Default Arguments)</a></h3>
<p>允许在函数声明时给参数设定一个默认值。调用时若不提供该实参，则使用默认值。</p>
<ul>
<li><strong>规则:</strong> 默认参数必须从右向左依次设置。一旦一个参数有了默认值，它右边的所有参数都必须有默认值。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-cpp">void print_info(int a, int b = 10, int c = 20); // b 和 c 是默认参数

// 调用方式
print_info(1);      // a=1, b=10, c=20
print_info(1, 5);   // a=1, b=5, c=20
print_info(1, 5, 8); // a=1, b=5, c=8
</code></pre>
<h3 id="2-函数重载-function-overloading"><a class="header" href="#2-函数重载-function-overloading">2. 函数重载 (Function Overloading)</a></h3>
<p>在同一作用域内，允许存在多个同名函数，但它们的 <strong>参数列表</strong> 必须不同（数量、类型或顺序）。</p>
<ul>
<li><strong>作用:</strong> 使程序能够使用一个统一的名称来执行相似但操作不同数据类型的任务。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-cpp">int operate(int a, int b)
{ return a + b; }

double operate(double a, double b)
{ return a * b; }

int operate(int a) // 与前两个函数参数数量不同
{ return a * a; }
</code></pre>
<h3 id="3-内联函数-inline-functions"><a class="header" href="#3-内联函数-inline-functions">3. 内联函数 (Inline Functions)</a></h3>
<p>使用 <code>inline</code> 关键字修饰的函数。</p>
<ul>
<li><strong>目的:</strong> 建议编译器在函数被调用的地方直接将函数体的代码展开，而不是执行常规的函数调用机制。</li>
<li><strong>优点:</strong> 消除函数调用开销，提高小函数的执行效率。</li>
<li><strong>缺点:</strong> 可能导致代码膨胀（占用更多内存）。</li>
<li><strong>适用场景:</strong> 函数体非常简单（只有一两行代码）的情况。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-cpp">inline int square(int x) { return x * x; }
</code></pre>
<ul>
<li><strong>注意:</strong> <code>inline</code> 只是对编译器的<strong>建议</strong>，编译器可以忽略它。</li>
</ul>
<h2 id="示例代码-1"><a class="header" href="#示例代码-1">示例代码</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// 函数原型 (声明)
int add(int a, int b);
void swap_by_ref(int &amp;x, int &amp;y);

// 带有默认参数的函数原型
void greet(std::string name, std::string greeting = "Hello");

// main 函数 (程序入口)
int main() {
    int num1 = 10, num2 = 5;

    // 1. 函数调用
    int sum = add(num1, num2); // num1, num2 是实参
    std::cout &lt;&lt; "Sum: " &lt;&lt; sum &lt;&lt; std::endl; // 输出: 15

    // 2. 引用传递示例
    int x = 100, y = 200;
    std::cout &lt;&lt; "Before swap: x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; std::endl;
    swap_by_ref(x, y); // 交换 x 和 y 的值
    std::cout &lt;&lt; "After swap: x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; std::endl; // 输出: x=200, y=100

    // 3. 默认参数示例
    greet("Alice");           // 使用默认问候语: Hello Alice
    greet("Bob", "Good Morning"); // 使用自定义问候语: Good Morning Bob

    return 0;
}

// 函数定义
int add(int a, int b) // a, b 是形参 (值传递)
{
    return a + b;
}

// 引用传递实现值交换
void swap_by_ref(int &amp;x, int &amp;y) // x, y 是引用
{
    int temp = x;
    x = y;
    y = temp;
    // x 和 y 的改变会影响到 main 函数中的实参
}

// 默认参数实现
void greet(std::string name, std::string greeting)
{
    std::cout &lt;&lt; greeting &lt;&lt; " " &lt;&lt; name &lt;&lt; std::endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类与对象"><a class="header" href="#类与对象">类与对象</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="c-内存管理"><a class="header" href="#c-内存管理">C++ 内存管理</a></h1>
<p>内存管理是 C++ 编程中的核心概念之一，它直接影响程序的性能、可靠性和稳定性。C++ 提供了灵活且高效的内存管理机制，这也使得开发者能够更精细地控制程序的内存使用。C++ 中的内存管理分为两大类：<strong>静态内存管理</strong>和<strong>动态内存管理</strong>。</p>
<p>在 C++ 中，静态内存管理主要涉及由编译器管理的栈内存，通常用于存储局部变量和函数调用的相关信息。与此不同，动态内存管理则涉及到程序运行时动态分配的内存区域，这通常需要程序员显式地分配和释放内存。</p>
<p>C++ 提供了一些工具来帮助开发者更高效地管理内存，避免内存泄漏、悬空指针和野指针等常见问题。在传统的内存管理方式中，开发者需要通过 new 和 delete 来手动管理动态内存的分配和释放。而为了提高开发效率和安全性，C++11 引入了<code>智能指针</code>，如 <code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>，它们自动管理内存的生命周期，减少了人为错误的可能性。</p>
<p>此外，C++ 还提供了内存池和内存对齐等更底层的内存管理技术，使得开发者可以根据需要进一步优化程序的内存使用。</p>
<p>在本章中，将深入探讨 C++ 中的内存管理机制，重点介绍手动内存管理和智能指针的使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointer"><a class="header" href="#smart-pointer">Smart Pointer</a></h1>
<p>内存管理是 C++ 编程中的一个关键问题，尤其是当涉及到动态分配的内存时，程序员需要确保及时释放资源以避免内存泄漏或其他潜在问题。为了解决这个问题，C++ 引入了智能指针，它们通过自动管理内存的生命周期来帮助开发者更安全地进行内存操作。智能指针不仅简化了内存管理的复杂性，还提高了程序的安全性，避免了许多常见的内存错误。</p>
<p>智能指针是 C++ 标准库中的模板类，它们的作用是通过自动释放所持有的资源来管理动态分配的内存。智能指针的核心特点是，它们会在不再需要资源时自动释放内存，从而减少内存泄漏的风险。C++11 引入了三种主要类型的智能指针：std::unique_ptr、std::shared_ptr 和 std::weak_ptr，它们适用于不同的使用场景。除此之外，std::auto_ptr 是 C++98 中的一个智能指针，但由于设计缺陷，它在 C++11 中被弃用了。</p>
<p>在本节中，我们将详细介绍这四种智能指针的特点、适用场景以及如何使用它们。</p>
<div class="table-wrapper"><table><thead><tr><th>智能指针类型</th><th>所有权类型</th><th>主要特点</th><th>适用场景</th><th>创建方式</th></tr></thead><tbody>
<tr><td><code>std::auto_ptr</code></td><td>独占所有权（已弃用）</td><td>自动管理内存，但存在隐式所有权转移的问题，已在 C++11 中弃用</td><td>不推荐使用（已被 <code>std::unique_ptr</code> 取代）</td><td><code>std::auto_ptr&lt;T&gt; ptr(new T);</code></td></tr>
<tr><td><code>std::unique_ptr</code></td><td>独占所有权</td><td>不能拷贝，只能移动，自动销毁所管理的资源</td><td>单一所有者的资源管理，适用于工厂模式等</td><td><code>std::unique_ptr&lt;T&gt; ptr = std::make_unique&lt;T&gt;();</code></td></tr>
<tr><td><code>std::shared_ptr</code></td><td>共享所有权</td><td>引用计数，多个指针共享同一资源，最后一个销毁时释放资源</td><td>多个对象共享资源，如缓存、资源池</td><td><code>std::shared_ptr&lt;T&gt; ptr = std::make_shared&lt;T&gt;();</code></td></tr>
<tr><td><code>std::weak_ptr</code></td><td>不管理资源生命周期</td><td>防止 <code>shared_ptr</code> 引用计数循环引用，不能直接访问资源</td><td>避免 <code>shared_ptr</code> 的循环引用问题</td><td><code>std::weak_ptr&lt;T&gt; weak_ptr = shared_ptr;</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="stdauto_ptr"><a class="header" href="#stdauto_ptr">std::auto_ptr</a></h1>
<p><code>std::auto_ptr</code> 是 C++98 中引入的智能指针类型，它提供了一种自动管理动态内存的方式。其主要功能是通过自动销毁对象来避免内存泄漏。然而，由于其所有权转移的语义问题（例如，拷贝操作时所有权隐式转移），<code>std::auto_ptr</code> 在 C++11 中被 <strong>弃用</strong>，并且在 C++17 中被 <strong>完全移除</strong>。因此，建议开发者使用 <code>std::unique_ptr</code> 来替代 <code>std::auto_ptr</code>。</p>
<h2 id="1-定义-1"><a class="header" href="#1-定义-1">1. 定义</a></h2>
<p><code>std::auto_ptr</code> 的模板定义如下：</p>
<pre><code class="language-cpp">template&lt;class T&gt;
class auto_ptr;
</code></pre>
<p>它是一个模板类，接受一个类型 <code>T</code>，并提供对该类型的自动内存管理。</p>
<p><code>std::auto_ptr</code> 还有一个专用的模板版本：</p>
<pre><code class="language-cpp">template&lt;&gt;
class auto_ptr&lt;void&gt;;
</code></pre>
<p>这个版本用于不处理任何具体类型的 <code>void</code> 指针，但它通常不用于常规编程中，因为它并没有实际的意义。</p>
<h2 id="2-基本功能"><a class="header" href="#2-基本功能">2. 基本功能</a></h2>
<p><code>std::auto_ptr</code> 自动管理其指向的动态内存资源。其基本特点是：</p>
<ul>
<li>在 <code>auto_ptr</code> 被销毁时，自动释放其指向的对象。</li>
<li>所有权转移：当 <code>auto_ptr</code> 被拷贝时，源 <code>auto_ptr</code> 的所有权被转移到目标 <code>auto_ptr</code>，这意味着源指针不再持有资源。这一行为可能会导致意外的内存管理问题。</li>
</ul>
<h2 id="3-重要特点"><a class="header" href="#3-重要特点">3. 重要特点</a></h2>
<ul>
<li>
<p>所有权转移：</p>
<ul>
<li><code>std::auto_ptr</code> 的最具争议的特性就是它的 <strong>所有权转移</strong>。在拷贝构造函数或拷贝赋值运算符中，<code>auto_ptr</code> 会转移所有权（即源指针将失去对对象的所有权，而目标指针会成为新的所有者）。这种行为与 C++ 中其他类型的智能指针（如 <code>std::unique_ptr</code>）不同，容易导致不易察觉的 bug，尤其是在多次使用相同的对象时。</li>
</ul>
</li>
<li>
<p>析构时自动释放资源：</p>
<ul>
<li>在 <code>auto_ptr</code> 被销毁时，它会自动释放它持有的内存。其析构函数会调用所管理对象的析构函数来释放资源，因此，开发者不需要显式地调用 <code>delete</code>。</li>
</ul>
</li>
<li>
<p>不支持复制语义：</p>
<ul>
<li>由于所有权转移，<code>std::auto_ptr</code> 不支持复制操作（即不支持拷贝构造和拷贝赋值），它只支持移动语义。</li>
</ul>
</li>
</ul>
<h2 id="4-使用示例"><a class="header" href="#4-使用示例">4. 使用示例</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

class MyClass {
public:
    MyClass() { std::cout &lt;&lt; "MyClass constructor\n"; }
    ~MyClass() { std::cout &lt;&lt; "MyClass destructor\n"; }
};

int main() {
    // 创建一个 auto_ptr 指向 MyClass
    std::auto_ptr&lt;MyClass&gt; ptr1(new MyClass());

    // 通过拷贝构造将 ptr1 的所有权转移到 ptr2
    std::auto_ptr&lt;MyClass&gt; ptr2 = ptr1; // ptr1 的所有权转移给 ptr2

    // ptr1 现在为空，不能再使用它
    if (!ptr1) {
        std::cout &lt;&lt; "ptr1 is now null.\n";
    }

    // ptr2 仍然拥有 MyClass 的资源
    // 在程序结束时，ptr2 将自动释放 MyClass 对象
    return 0;
}
</code></pre>
<h2 id="5-为什么-stdauto_ptr-被弃用"><a class="header" href="#5-为什么-stdauto_ptr-被弃用">5. 为什么 <code>std::auto_ptr</code> 被弃用</a></h2>
<ul>
<li>
<p>所有权转移的问题：
<code>std::auto_ptr</code> 的一个关键问题是它的拷贝构造函数和拷贝赋值运算符会隐式地转移所有权，这会导致意外的行为和 bug。开发者可能会错误地认为一个对象仍然拥有资源，而实际上的资源已经被转移给另一个对象，导致悬空指针或多次释放同一资源。</p>
</li>
<li>
<p>现代 C++ 的替代方案：
在 C++11 中，<code>std::unique_ptr</code> 被引入作为 <code>std::auto_ptr</code> 的替代品。与 <code>std::auto_ptr</code> 不同，<code>std::unique_ptr</code> 不允许拷贝操作，只允许移动操作，避免了隐式所有权转移的风险，从而更符合现代 C++ 的设计理念。</p>
</li>
<li>
<p>移动语义：
<code>std::unique_ptr</code> 支持移动语义，它允许资源的所有权在不同对象间转移，而不会引起混淆或潜在错误。</p>
</li>
</ul>
<h3 id="6-替代品"><a class="header" href="#6-替代品">6. 替代品</a></h3>
<ul>
<li>
<p><code>std::unique_ptr</code>：
<code>std::unique_ptr</code> 是 <code>std::auto_ptr</code> 的现代替代品，它通过明确的所有权控制来避免潜在的错误。<code>std::unique_ptr</code> 不允许拷贝，只支持通过 <code>std::move</code> 转移所有权，因此避免了所有权转移时产生的问题。</p>
</li>
<li>
<p><code>std::shared_ptr</code>：
对于共享所有权的场景，<code>std::shared_ptr</code> 可以提供引用计数功能，使得多个指针可以共同拥有资源，而在最后一个指针被销毁时释放资源。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdunique_ptr"><a class="header" href="#stdunique_ptr">std::unique_ptr</a></h1>
<p><code>std::unique_ptr</code> 是 C++11 引入的智能指针类型，它为动态内存提供了更加安全和高效的管理方式。与 <code>std::auto_ptr</code> 相比，<code>std::unique_ptr</code> 引入了更严格的所有权管理机制，避免了隐式所有权转移的问题，并且仅支持通过移动语义来转移资源的所有权。这使得 <code>std::unique_ptr</code> 在现代 C++ 中成为管理动态内存的推荐方式。</p>
<h2 id="定义与基本功能"><a class="header" href="#定义与基本功能">定义与基本功能</a></h2>
<p><code>std::unique_ptr</code> 是一个模板类，用于管理指向动态分配内存的指针。它确保在其生命周期结束时自动释放资源，避免了开发者手动管理内存的复杂性。该类型的主要目标是明确地控制资源的所有权，确保资源只会被一个指针持有，避免内存泄漏和资源重复释放的风险。</p>
<pre><code class="language-cpp">template&lt;
    class T,
    class Deleter = std::default_delete&lt;T&gt;
&gt; class unique_ptr;
</code></pre>
<pre><code class="language-cpp">template &lt;
    class T,
    class Deleter
&gt; class unique_ptr&lt;T[], Deleter&gt;;
</code></pre>
<p>与 <code>std::auto_ptr</code> 不同，<code>std::unique_ptr</code> 不允许拷贝操作，它只支持移动操作。这样，<code>std::unique_ptr</code> 可以避免由于不明确的所有权转移所引发的错误和 bug。资源的所有权转移只能通过 <code>std::move</code> 完成，这使得程序员可以清晰地看到何时发生了所有权的转移，避免了拷贝构造和赋值操作带来的隐式问题。</p>
<h2 id="资源管理的所有权控制"><a class="header" href="#资源管理的所有权控制">资源管理的所有权控制</a></h2>
<p><code>std::unique_ptr</code> 的核心特性之一就是它持有资源的 <strong>唯一所有权</strong>。每个 <code>std::unique_ptr</code> 都确保它是唯一拥有所指向对象的所有者。当 <code>std::unique_ptr</code> 被销毁时，它会自动释放所管理的内存，无需开发者手动调用 <code>delete</code>，从而降低了内存泄漏的风险。由于不允许拷贝构造或拷贝赋值操作，<code>std::unique_ptr</code> 使得资源的所有权在多个指针之间的共享变得不可能，从而避免了多个指针指向同一资源时可能导致的多重释放或悬空指针问题。</p>
<p>例如，考虑以下代码片段：</p>
<pre><code class="language-cpp">std::unique_ptr&lt;MyClass&gt; ptr1(new MyClass());
std::unique_ptr&lt;MyClass&gt; ptr2 = std::move(ptr1);  // 转移所有权
</code></pre>
<p>在这段代码中，<code>ptr1</code> 的所有权通过 <code>std::move</code> 转移给 <code>ptr2</code>，<code>ptr1</code> 变为一个空指针，无法再访问原始资源。资源的所有权不再在多个指针之间共享，因此 <code>ptr1</code> 不再需要释放资源。</p>
<h2 id="移动语义"><a class="header" href="#移动语义">移动语义</a></h2>
<p><code>std::unique_ptr</code> 支持 <strong>移动语义</strong>，意味着资源的所有权可以从一个 <code>unique_ptr</code> 移动到另一个 <code>unique_ptr</code>。通过移动构造函数或移动赋值操作，资源的所有权会被安全地转移，而不会引发不必要的复制操作。与拷贝构造不同，移动操作并不会增加资源的引用计数，也不会创建多个指针指向同一个对象。移动语义使得内存管理更加高效，并避免了性能上的冗余开销。</p>
<pre><code class="language-cpp">std::unique_ptr&lt;MyClass&gt; ptr1(new MyClass());
std::unique_ptr&lt;MyClass&gt; ptr2 = std::move(ptr1);  // 使用移动语义转移所有权
</code></pre>
<p>这里，<code>ptr1</code> 的所有权被移动到 <code>ptr2</code>，<code>ptr1</code> 被置为空。这样，<code>std::unique_ptr</code> 能够在不产生冗余复制的情况下实现资源所有权的转移。</p>
<h2 id="自动销毁与内存管理"><a class="header" href="#自动销毁与内存管理">自动销毁与内存管理</a></h2>
<p><code>std::unique_ptr</code> 在其生命周期结束时会自动释放它所持有的资源。它的析构函数会在 <code>unique_ptr</code> 被销毁时自动调用所管理对象的析构函数，这意味着开发者无需手动管理内存的释放操作。通过这种方式，<code>std::unique_ptr</code> 减少了内存泄漏的可能性，也避免了因为忘记释放内存而导致的错误。</p>
<p>例如，在函数的作用域结束时，<code>std::unique_ptr</code> 会自动释放它管理的资源：</p>
<pre><code class="language-cpp">void createObject() {
    std::unique_ptr&lt;MyClass&gt; ptr(new MyClass());
    // 自动释放 ptr 管理的内存
}
</code></pre>
<p>当 <code>createObject</code> 函数结束时，<code>ptr</code> 会被销毁，它所管理的 <code>MyClass</code> 对象也会被自动释放。</p>
<h2 id="不支持复制支持移动"><a class="header" href="#不支持复制支持移动">不支持复制，支持移动</a></h2>
<p>与 <code>std::auto_ptr</code> 不同，<code>std::unique_ptr</code> 设计上不支持拷贝构造和拷贝赋值操作，因此不会发生隐式所有权转移的问题。若需要转移所有权，开发者必须显式地使用 <code>std::move</code> 进行资源的转移，这使得代码中资源所有权的转移变得更加明确和安全。这种设计使得 <code>std::unique_ptr</code> 在资源管理上更加清晰，避免了由于误用或隐式操作而引发的错误。</p>
<pre><code class="language-cpp">std::unique_ptr&lt;MyClass&gt; ptr1(new MyClass());
std::unique_ptr&lt;MyClass&gt; ptr2 = ptr1;  // 编译错误，不能拷贝
</code></pre>
<p>这段代码会编译错误，因为 <code>std::unique_ptr</code> 不允许拷贝构造。唯一的方式是使用 <code>std::move</code> 来进行所有权的转移：</p>
<pre><code class="language-cpp">std::unique_ptr&lt;MyClass&gt; ptr1(new MyClass());
std::unique_ptr&lt;MyClass&gt; ptr2 = std::move(ptr1);  // 通过移动操作转移所有权
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdshared_ptr"><a class="header" href="#stdshared_ptr">std::shared_ptr</a></h1>
<p><code>std::shared_ptr</code> 是 C++11 中引入的智能指针类型，用于管理动态分配的内存。它与 <code>std::unique_ptr</code> 和 <code>std::auto_ptr</code> 的主要区别在于，<code>std::shared_ptr</code> 支持 <strong>共享所有权</strong>，即多个 <code>shared_ptr</code> 可以共同拥有同一个资源。当最后一个持有该资源的 <code>shared_ptr</code> 被销毁时，资源会被自动释放。因此，<code>std::shared_ptr</code> 适用于需要多个指针共同管理同一资源的场景。</p>
<h2 id="定义与基本功能-1"><a class="header" href="#定义与基本功能-1">定义与基本功能</a></h2>
<p><code>std::shared_ptr</code> 是一个模板类，能够在多个 <code>shared_ptr</code> 之间共享资源的所有权, 其定义如下：</p>
<pre><code class="language-cpp">template&lt; class T &gt; class shared_ptr;
</code></pre>
<p>它通过 <strong>引用计数</strong> 机制来管理资源，确保在多个指针指向同一个对象时，资源只有在最后一个指针被销毁时才会被释放。每当一个新的 <code>shared_ptr</code> 被创建或拷贝时，引用计数会增加；当一个 <code>shared_ptr</code> 被销毁或被重置时，引用计数会减少。当引用计数降到 0 时，<code>std::shared_ptr</code> 会自动释放资源。</p>
<p>这种共享所有权的特性使得 <code>std::shared_ptr</code> 特别适用于需要多个对象共同管理资源的场景，而不必担心资源在多个指针之间的管理冲突。</p>
<h2 id="引用计数机制"><a class="header" href="#引用计数机制">引用计数机制</a></h2>
<p><code>std::shared_ptr</code> 的核心特点是它的 <strong>引用计数</strong> 机制。每个 <code>shared_ptr</code> 都维护着一个与资源关联的引用计数，记录当前有多少个 <code>shared_ptr</code> 正在共享同一资源。每当一个新的 <code>shared_ptr</code> 被拷贝或赋值时，引用计数增加；当一个 <code>shared_ptr</code> 被销毁时，引用计数减少。当引用计数降到 0 时，<code>std::shared_ptr</code> 会自动删除所指向的对象，从而避免了内存泄漏。</p>
<p>例如，考虑以下代码：</p>
<pre><code class="language-cpp">std::shared_ptr&lt;MyClass&gt; ptr1 = std::make_shared&lt;MyClass&gt;();
std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;  // 引用计数增加
</code></pre>
<p>此时，<code>ptr1</code> 和 <code>ptr2</code> 都指向同一个 <code>MyClass</code> 对象，引用计数为 2。当 <code>ptr1</code> 或 <code>ptr2</code> 被销毁时，引用计数会减少。只有当最后一个 <code>shared_ptr</code> 被销毁时，所管理的对象才会被释放。</p>
<h2 id="共享所有权"><a class="header" href="#共享所有权">共享所有权</a></h2>
<p><code>std::shared_ptr</code> 允许 <strong>多个指针共享同一资源的所有权</strong>。这种共享所有权的特性使得它在一些需要多个对象共同访问资源的场景中非常有用。例如，在多线程环境中，多个线程可能需要访问共享资源，而 <code>std::shared_ptr</code> 可以确保该资源在没有明确的所有权控制的情况下得到正确管理。</p>
<pre><code class="language-cpp">std::shared_ptr&lt;MyClass&gt; ptr1 = std::make_shared&lt;MyClass&gt;();
std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;  // 多个 shared_ptr 共享同一资源
</code></pre>
<p>在上面的例子中，<code>ptr1</code> 和 <code>ptr2</code> 都指向同一个对象，它们共享对资源的所有权，引用计数增加为 2。即使某个 <code>shared_ptr</code> 被销毁，另一个 <code>shared_ptr</code> 仍然可以访问资源。</p>
<h2 id="自动销毁与内存管理-1"><a class="header" href="#自动销毁与内存管理-1">自动销毁与内存管理</a></h2>
<p>与 <code>std::unique_ptr</code> 相似，<code>std::shared_ptr</code> 会在其生命周期结束时自动释放它所管理的资源。资源的释放是通过引用计数机制来实现的，当最后一个指向资源的 <code>shared_ptr</code> 被销毁时，资源会自动释放，从而避免内存泄漏的风险。</p>
<p>这一点非常适合需要共享资源的场景，因为 <code>shared_ptr</code> 会自动管理资源的生命周期，不需要开发者显式地调用 <code>delete</code>。</p>
<pre><code class="language-cpp">void createObject() {
    std::shared_ptr&lt;MyClass&gt; ptr1 = std::make_shared&lt;MyClass&gt;();
    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;  // 引用计数增加

    // ptr1 和 ptr2 都会在函数结束时自动销毁
    // 当最后一个 shared_ptr 被销毁时，MyClass 对象将被自动删除
}
</code></pre>
<p>在上述示例中，<code>ptr1</code> 和 <code>ptr2</code> 都指向同一个 <code>MyClass</code> 对象。当这两个 <code>shared_ptr</code> 都超出作用域并被销毁时，引用计数变为 0，<code>MyClass</code> 对象会被自动销毁。</p>
<h2 id="线程安全"><a class="header" href="#线程安全">线程安全</a></h2>
<p><code>std::shared_ptr</code> 的引用计数机制是线程安全的，即多个线程可以安全地同时操作同一个 <code>shared_ptr</code>，而不必担心引用计数的竞争条件。这使得 <code>std::shared_ptr</code> 非常适合多线程程序中的共享资源管理。</p>
<p>然而，值得注意的是，虽然 <code>std::shared_ptr</code> 在引用计数方面是线程安全的，但并不是对资源本身的访问是线程安全的。如果多个线程需要同时访问资源的成员，则需要额外的同步机制（如互斥锁）来保护资源。</p>
<h2 id="不支持循环引用"><a class="header" href="#不支持循环引用">不支持循环引用</a></h2>
<p>一个需要注意的事项是，<code>std::shared_ptr</code> 可能会导致 <strong>循环引用</strong> 的问题。如果两个或多个 <code>shared_ptr</code> 互相持有对方的引用，且它们的引用计数永远不会降到 0，那么这些资源将无法释放，从而导致内存泄漏。</p>
<p>例如，考虑以下代码：</p>
<pre><code class="language-cpp">struct Node {
    std::shared_ptr&lt;Node&gt; next;
};

void createCircularReference() {
    std::shared_ptr&lt;Node&gt; node1 = std::make_shared&lt;Node&gt;();
    std::shared_ptr&lt;Node&gt; node2 = std::make_shared&lt;Node&gt;();

    node1-&gt;next = node2;
    node2-&gt;next = node1;  // 形成循环引用
}
</code></pre>
<p>在这个例子中，<code>node1</code> 和 <code>node2</code> 互相持有对方的 <code>shared_ptr</code>，这将导致它们的引用计数永远不为 0，因此资源无法自动释放，造成内存泄漏。为了避免这种情况，可以使用 <code>std::weak_ptr</code> 来解决循环引用问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdweak_ptr"><a class="header" href="#stdweak_ptr">std::weak_ptr</a></h1>
<p><code>std::weak_ptr</code> 是 C++11 中引入的智能指针类型，它与 <code>std::shared_ptr</code> 紧密相关，用于解决共享指针管理过程中可能出现的 <strong>循环引用</strong> 问题。<code>std::weak_ptr</code> 本身不拥有所指向的对象，它只作为 <code>std::shared_ptr</code> 的辅助工具，允许观察某个对象而不改变其引用计数。因此，<code>std::weak_ptr</code> 可以防止由于多个 <code>std::shared_ptr</code> 相互引用而导致的内存泄漏。</p>
<h2 id="定义与基本功能-2"><a class="header" href="#定义与基本功能-2">定义与基本功能</a></h2>
<p><code>std::weak_ptr</code> 是一个模板类，它与 <code>std::shared_ptr</code> 配合使用，提供对对象的弱引用。弱引用不增加所管理对象的引用计数，因此不会阻止对象的销毁。<code>std::weak_ptr</code> 的主要功能是：它允许你“观察”一个 <code>std::shared_ptr</code> 管理的对象，而不会影响该对象的生命周期管理。通过 <code>std::weak_ptr</code>，你可以检查对象是否仍然存在，但不需要担心导致资源不会被销毁。</p>
<p><code>std::weak_ptr</code> 的最大应用场景就是避免 <strong>循环引用</strong>，这是当两个或多个 <code>std::shared_ptr</code> 互相持有对方时所导致的问题，通常会使得对象无法被释放。</p>
<h2 id="解决循环引用问题"><a class="header" href="#解决循环引用问题">解决循环引用问题</a></h2>
<p>循环引用是 <code>std::shared_ptr</code> 的一个典型问题。例如，当两个 <code>std::shared_ptr</code> 互相引用对方时，它们的引用计数永远不会降到零，导致对象无法被销毁，造成内存泄漏。为了避免这种情况，<code>std::weak_ptr</code> 可以作为一种“观察者”角色，用于打破循环引用。</p>
<p>考虑以下示例，假设 <code>Node</code> 类有一个指向另一个 <code>Node</code> 对象的指针，如果两个节点互相持有 <code>std::shared_ptr</code>，就会形成一个循环引用：</p>
<pre><code class="language-cpp">struct Node {
    std::shared_ptr&lt;Node&gt; next;
};

void createCircularReference() {
    std::shared_ptr&lt;Node&gt; node1 = std::make_shared&lt;Node&gt;();
    std::shared_ptr&lt;Node&gt; node2 = std::make_shared&lt;Node&gt;();

    node1-&gt;next = node2;
    node2-&gt;next = node1;  // 形成循环引用
}
</code></pre>
<p>在上述代码中，<code>node1</code> 和 <code>node2</code> 互相持有对方的 <code>shared_ptr</code>，导致它们的引用计数永远不会为 0，造成内存泄漏。为了解决这个问题，我们可以使用 <code>std::weak_ptr</code> 来消除循环引用。例如，改用 <code>std::weak_ptr</code> 来表示 <code>node1</code> 对 <code>node2</code> 的引用：</p>
<pre><code class="language-cpp">struct Node {
    std::weak_ptr&lt;Node&gt; next;  // 使用 weak_ptr 代替 shared_ptr
};

void createCircularReference() {
    std::shared_ptr&lt;Node&gt; node1 = std::make_shared&lt;Node&gt;();
    std::shared_ptr&lt;Node&gt; node2 = std::make_shared&lt;Node&gt;();

    node1-&gt;next = node2;
    node2-&gt;next = node1;  // 现在不会形成循环引用
}
</code></pre>
<p>通过将 <code>next</code> 指针改为 <code>std::weak_ptr</code>，我们打破了循环引用。现在，当 <code>node1</code> 和 <code>node2</code> 被销毁时，它们的引用计数会正常降到 0，资源将被正确释放。</p>
<h2 id="访问管理对象"><a class="header" href="#访问管理对象">访问管理对象</a></h2>
<p>尽管 <code>std::weak_ptr</code> 本身并不管理资源的生命周期，它可以通过 <code>std::shared_ptr</code> 来访问所管理的对象。当你想要访问一个由 <code>std::weak_ptr</code> 观察的对象时，必须先将其转换为 <code>std::shared_ptr</code>。这个转换过程称为 <strong>提升（lock）</strong>，通过 <code>std::weak_ptr::lock()</code> 函数完成。该函数返回一个 <code>std::shared_ptr</code>，如果原始对象仍然存在，则该 <code>shared_ptr</code> 会指向它；否则，返回一个空的 <code>shared_ptr</code>。</p>
<pre><code class="language-cpp">std::shared_ptr&lt;MyClass&gt; ptr = weakPtr.lock();
if (ptr) {
    // 使用 ptr 来访问 MyClass 对象
} else {
    // 对象已被销毁
}
</code></pre>
<p>这里，<code>lock()</code> 方法会尝试从 <code>std::weak_ptr</code> 获取一个有效的 <code>std::shared_ptr</code>，如果对象已经被销毁（即引用计数为 0），则返回一个空的 <code>shared_ptr</code>。</p>
<h2 id="不增加引用计数"><a class="header" href="#不增加引用计数">不增加引用计数</a></h2>
<p><code>std::weak_ptr</code> 通过不增加引用计数来提供弱引用，因此它不会干扰对象生命周期的管理。它只用作对对象的观察者，让你能够安全地检查对象是否仍然存在。换句话说，<code>std::weak_ptr</code> 不控制对象的生命周期，只是“看”着它，并且通过 <code>lock()</code> 函数来查询对象是否有效。</p>
<pre><code class="language-cpp">std::shared_ptr&lt;MyClass&gt; sp1 = std::make_shared&lt;MyClass&gt;();
std::weak_ptr&lt;MyClass&gt; wp1 = sp1;  // weak_ptr 不增加引用计数

// 当 sp1 超出作用域时，wp1 不再有效，且 MyClass 对象会被销毁
</code></pre>
<p>在这个例子中，<code>wp1</code> 观察了 <code>sp1</code> 管理的对象，但并没有增加引用计数。这样，当 <code>sp1</code> 被销毁时，<code>wp1</code> 变得无效，所管理的对象也会被正确释放。</p>
<h2 id="转换为-stdshared_ptr"><a class="header" href="#转换为-stdshared_ptr">转换为 <code>std::shared_ptr</code></a></h2>
<p>通常，我们使用 <code>std::weak_ptr</code> 来避免循环引用，但如果需要，我们可以将其转换回 <code>std::shared_ptr</code> 来访问资源。转换过程是通过 <code>std::weak_ptr::lock()</code> 完成的，这将返回一个新的 <code>std::shared_ptr</code>，并增加该资源的引用计数。如果资源已经被销毁（即引用计数为 0），则返回一个空的 <code>std::shared_ptr</code>。</p>
<pre><code class="language-cpp">std::shared_ptr&lt;MyClass&gt; ptr = wp.lock();  // 转换为 shared_ptr
if (ptr) {
    // 使用 ptr 来访问 MyClass 对象
}
</code></pre>
<p>通过这种方式，我们可以在必要时访问由 <code>std::weak_ptr</code> 管理的对象，但前提是该对象仍然存在。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stl"><a class="header" href="#stl">STL</a></h1>
<p>C++ 标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类和函数的集合，基于泛型编程，因此适合各种数据结构，它提供了一系列通用的、可复用的算法和数据结构。</p>
<div class="table-wrapper"><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody>
<tr><td><strong>容器 (Containers)</strong></td><td>容器是 STL 中最基本的组件之一，提供了各种数据结构，包括向量（vector）、链表（list）、队列（queue）、栈（stack）、集合（set）、映射（map）等。这些容器具有不同的特性和用途，可以根据实际需求选择合适的容器。</td></tr>
<tr><td><strong>算法 (Algorithms)</strong></td><td>STL 提供了大量的算法，用于对容器中的元素进行各种操作，包括排序、搜索、复制、移动、变换等。这些算法在使用时不需要关心容器的具体类型，只需要指定要操作的范围即可。</td></tr>
<tr><td><strong>迭代器 (Iterators)</strong></td><td>迭代器用于遍历容器中的元素，允许以统一的方式访问容器中的元素，而不用关心容器的内部实现细节。STL 提供了多种类型的迭代器，包括随机访问迭代器、双向迭代器、前向迭代器和输入输出迭代器等。</td></tr>
<tr><td><strong>函数对象 (Function Objects)</strong></td><td>函数对象是可以像函数一样调用的对象，可以用于算法中的各种操作。STL 提供了多种函数对象，包括一元函数对象、二元函数对象、谓词等，可以满足不同的需求。</td></tr>
<tr><td><strong>适配器 (Adapters)</strong></td><td>适配器用于将一种容器或迭代器适配成另一种容器或迭代器，以满足特定的需求。STL 提供了多种适配器，包括栈适配器（stack adapter）、队列适配器（queue adapter）和优先队列适配器（priority queue adapter）等。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="utility"><a class="header" href="#utility">Utility</a></h1>
<p>在 C++ 中，有一些实用的工具类和函数，这些工具类和函数在编写高效、可读性强的代码时非常有用且大多是C++新特性</p>
<div class="table-wrapper"><table><thead><tr><th>工具名称</th><th>说明</th><th>所属头文件</th><th>C++版本引入</th></tr></thead><tbody>
<tr><td><strong><code>std::pair</code></strong></td><td>存储两个相关值的通用模板类。</td><td><code>&lt;utility&gt;</code></td><td>C++98</td></tr>
<tr><td><strong><code>std::make_pair</code></strong></td><td>辅助函数，用于创建 <code>std::pair</code>。</td><td><code>&lt;utility&gt;</code></td><td>C++98</td></tr>
<tr><td><strong><code>std::move</code></strong></td><td>将对象显式转换为右值引用，用于触发移动语义。</td><td><code>&lt;utility&gt;</code></td><td>C++11</td></tr>
<tr><td><strong><code>std::forward</code></strong></td><td>完美转发函数，用于保持值类别（左值/右值）。</td><td><code>&lt;utility&gt;</code></td><td>C++11</td></tr>
<tr><td><strong><code>std::swap</code></strong></td><td>通用交换函数，支持用户自定义类型的交换。</td><td><code>&lt;utility&gt;</code></td><td>C++98</td></tr>
<tr><td><strong><code>std::tuple</code></strong></td><td>可变长异质容器，存储多个不同类型的值。</td><td><code>&lt;tuple&gt;</code></td><td>C++11</td></tr>
<tr><td><strong><code>std::make_tuple</code></strong></td><td>辅助函数，用于创建 <code>std::tuple</code>。</td><td><code>&lt;tuple&gt;</code></td><td>C++11</td></tr>
<tr><td><strong><code>std::tie</code></strong></td><td>将多个左值绑定为 tuple，用于结构化绑定或比较。</td><td><code>&lt;tuple&gt;</code></td><td>C++11</td></tr>
<tr><td><strong><code>std::ignore</code></strong></td><td>与 <code>std::tie</code> 搭配，用于忽略某个绑定的值。</td><td><code>&lt;tuple&gt;</code></td><td>C++11</td></tr>
<tr><td><strong><code>std::optional</code></strong></td><td>表示一个可选值，可能含值也可能为空。</td><td><code>&lt;optional&gt;</code></td><td>C++17</td></tr>
<tr><td><strong><code>std::variant</code></strong></td><td>类型安全的联合体，可以在多个候选类型中存储其中之一。</td><td><code>&lt;variant&gt;</code></td><td>C++17</td></tr>
<tr><td><strong><code>std::any</code></strong></td><td>类型擦除的容器，可以存放任意类型的值，并在运行时安全提取。</td><td><code>&lt;any&gt;</code></td><td>C++17</td></tr>
<tr><td><strong><code>std::function</code></strong></td><td>通用函数包装器，可存储可调用对象（函数指针、lambda、仿函数等）。</td><td><code>&lt;functional&gt;</code></td><td>C++11</td></tr>
<tr><td><strong><code>std::bind</code></strong></td><td>绑定函数参数，生成新的可调用对象。</td><td><code>&lt;functional&gt;</code></td><td>C++11</td></tr>
<tr><td><strong><code>std::ref</code></strong></td><td>将对象包装为引用，以便在需要值语义时保持引用语义。</td><td><code>&lt;functional&gt;</code></td><td>C++11</td></tr>
<tr><td><strong><code>std::cref</code></strong></td><td>常量引用版本的 <code>std::ref</code>。</td><td><code>&lt;functional&gt;</code></td><td>C++11</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="stdpair"><a class="header" href="#stdpair">std::pair</a></h1>
<p><code>std::pair</code> 是一个结构体模板，其可于一个单元内存储两个相异对象。是 std::tuple 的拥有两个元素的特殊情况。一般来说，pair 可以封装任意类型的对象，可以生成各种不同的 <code>std::pair&lt;T1, T2&gt;</code> 对象，可以是数组对象或者包含 <code>std::pair&lt;T1,T2&gt;</code> 的 vector 容器。pair 还可以封装两个序列容器或两个序列容器的指针。</p>
<h2 id="1-引入"><a class="header" href="#1-引入">1. 引入</a></h2>
<p>被包括在<code>&lt;utility&gt;</code>头文件中。</p>
<pre><code class="language-C++">#include &lt;utility&gt;
</code></pre>
<h2 id="2-存储方式"><a class="header" href="#2-存储方式">2. 存储方式</a></h2>
<p><code>std::pair</code> 存储两个对象，分别通过 <code>first</code> 和 <code>second</code> 成员访问。<code>std::pair</code> 自动将初始化参数的值赋给 <code>first</code> 和 <code>second</code>。</p>
<h2 id="3-方法"><a class="header" href="#3-方法">3. 方法</a></h2>
<h3 id="1构造方法"><a class="header" href="#1构造方法">(1)构造方法</a></h3>
<ol>
<li>
<p>默认构造函数：创建一个未初始化的 <code>std::pair</code> 对象。</p>
<pre><code class="language-cpp">std::pair&lt;int, std::string&gt; myPair;
</code></pre>
</li>
<li>
<p>值构造函数：通过传入两个对象初始化 <code>std::pair</code>。</p>
<pre><code class="language-cpp">std::pair&lt;int, std::string&gt; myPair(1, "example");
</code></pre>
</li>
<li>
<p>工厂函数 <code>make_pair</code>：生成 <code>std::pair</code> 对象。</p>
<pre><code class="language-cpp">auto anotherPair = std::make_pair(2, "test");
</code></pre>
</li>
</ol>
<h3 id="2成员访问"><a class="header" href="#2成员访问">(2)成员访问</a></h3>
<ol>
<li>first：访问或修改 <code>std::pair</code> 的第一个元素。</li>
<li>second：访问或修改 <code>std::pair</code> 的第二个元素。</li>
</ol>
<h3 id="3比较操作符"><a class="header" href="#3比较操作符">(3)比较操作符</a></h3>
<ol>
<li>相等 (<code>==</code>) 和不相等 (<code>!=</code>)：比较两个 <code>std::pair</code> 对象是否相等。</li>
<li>小于 (<code>&lt;</code>) 和大于 (<code>&gt;</code>)和小于等于 (<code>&lt;=</code>) 和大于等于 (<code>&gt;=</code>)：根据 <code>first</code> 和 <code>second</code> 的字典顺序比较两个 <code>std::pair</code> 对象。</li>
</ol>
<h3 id="4交换"><a class="header" href="#4交换">(4)交换</a></h3>
<ol>
<li>
<p>swap：交换两个 <code>std::pair</code> 对象的值。</p>
<pre><code class="language-cpp">myPair.swap(anotherPair);
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdmove"><a class="header" href="#stdmove">std::move</a></h1>
<p>将一个对象的<strong>所有权</strong>从一个地方(特指引用或是指针)转移到另一个地方，相当于rust语言的所有权转让，对于<code>std::string</code>或是更复杂的数据结构使用<code>std::move</code>转移所有权可以比直接复制有着更高的效率。</p>
<p>其模板定义如下：</p>
<pre><code class="language-cpp">template&lt; class T &gt;
typename std::remove_reference&lt;T&gt;::type&amp;&amp; move( T&amp;&amp; t ) noexcept; // (since C++11 and until C++14)
</code></pre>
<pre><code class="language-cpp">template&lt; class T &gt;
constexpr std::remove_reference_t&lt;T&gt;&amp;&amp; move( T&amp;&amp; t ) noexcept; // (since C++14)
</code></pre>
<h2 id="1-引入-1"><a class="header" href="#1-引入-1">1. 引入</a></h2>
<p>被包括在<code>&lt;utility&gt;</code>头文件中。</p>
<pre><code class="language-C++">#include &lt;utility&gt;
</code></pre>
<h2 id="2-stdmove的工作原理"><a class="header" href="#2-stdmove的工作原理">2. <code>std::move</code>的工作原理</a></h2>
<p><code>std::move</code>并不真正“移动”对象的数据，它的作用是将一个左值引用转化为右值引用，从而启用移动语义。在C++中，右值引用和左值引用的主要区别在于右值引用允许资源的所有权转移，而左值引用则保持资源的所有权。</p>
<p>通过使用<code>std::move</code>，编译器能够区分何时使用<strong>拷贝构造</strong>（复制数据）和<strong>移动构造</strong>（转移所有权），从而优化程序性能，特别是在涉及大量数据拷贝的场景中。</p>
<h3 id="1右值引用与左值引用"><a class="header" href="#1右值引用与左值引用">(1)右值引用与左值引用</a></h3>
<ul>
<li>左值：表示可以被引用且具有持久地址的对象（例如，变量）。</li>
<li>右值：表示临时对象或可以被销毁的对象（例如，常量、字面值、函数返回值）。</li>
</ul>
<p><code>std::move</code>的作用是将左值转换为右值引用，允许资源的移动。</p>
<h3 id="2为什么需要stdmove"><a class="header" href="#2为什么需要stdmove">(2)为什么需要<code>std::move</code>？</a></h3>
<p>C++11引入了移动语义（Move Semantics），目标是提高性能。复制一个大对象时，可能涉及到大量的内存分配和数据拷贝，而如果能将资源的所有权直接转移给另一个对象，就可以避免这些开销。<code>std::move</code>通过将左值转换为右值引用，促使移动构造函数或移动赋值运算符被调用。</p>
<p>例如：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v1 = {1, 2, 3};
std::vector&lt;int&gt; v2 = std::move(v1);  // 这里v2会接管v1的所有权，v1会处于一个"空"状态
</code></pre>
<p>在这个例子中，<code>std::move</code>将<code>v1</code>转换为右值引用，从而触发了移动构造函数。结果是，<code>v2</code>接管了<code>v1</code>的数据，而<code>v1</code>进入了一个有效但不确定的状态。</p>
<h2 id="3-使用stdmove的场景"><a class="header" href="#3-使用stdmove的场景">3. 使用<code>std::move</code>的场景</a></h2>
<h3 id="1移动构造与移动赋值"><a class="header" href="#1移动构造与移动赋值">(1)移动构造与移动赋值</a></h3>
<p>在使用<code>std::move</code>时，通常会看到它与<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>一起使用。</p>
<ul>
<li>移动构造函数：当一个对象通过右值引用初始化另一个对象时，调用移动构造函数，通常用于资源的转移。</li>
<li>移动赋值运算符：当一个对象被右值引用赋值给另一个已存在的对象时，调用移动赋值运算符。</li>
</ul>
<p>例如：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v1 = {1, 2, 3};
std::vector&lt;int&gt; v2 = std::move(v1);  // 使用移动构造函数
</code></pre>
<p>对于赋值操作：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v1 = {1, 2, 3};
std::vector&lt;int&gt; v2;
v2 = std::move(v1);  // 使用移动赋值运算符
</code></pre>
<p>不管是哪一种操作，<code>v1</code>都会被剥夺所有权。</p>
<h3 id="2自定义类型与stdmove"><a class="header" href="#2自定义类型与stdmove">(2)自定义类型与<code>std::move</code></a></h3>
<p>如果你有自定义类型，并希望通过移动语义来优化性能，那么你需要为这个类型定义<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>。这些函数通常需要显式地将资源的所有权从一个对象转移到另一个对象。</p>
<p>例如：</p>
<pre><code class="language-cpp">class MyClass {
public:
    MyClass(MyClass&amp;&amp; other) noexcept {
        // 移动构造函数
        this-&gt;data = std::move(other.data);  // 移动数据
    }

    MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept {
        // 移动赋值运算符
        if (this != &amp;other) {
            this-&gt;data = std::move(other.data);  // 移动数据
        }
        return *this;
    }

private:
    std::vector&lt;int&gt; data;
};
</code></pre>
<h2 id="4-stdmove的常见误用"><a class="header" href="#4-stdmove的常见误用">4. <code>std::move</code>的常见误用</a></h2>
<h3 id="1移动之后使用原对象"><a class="header" href="#1移动之后使用原对象">(1)移动之后使用原对象</a></h3>
<p>在将对象通过<code>std::move</code>转移所有权之后，原对象的状态是未定义的。因此，<strong>不应再使用原对象</strong>，例如：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v1 = {1, 2, 3};
std::vector&lt;int&gt; v2 = std::move(v1);

// v1现在处于未定义状态，不能再安全使用
std::cout &lt;&lt; v1.size();  // 错误
</code></pre>
<p>正确的做法是，只在转移所有权后“放弃”原对象的使用。</p>
<h3 id="2不必要的使用stdmove"><a class="header" href="#2不必要的使用stdmove">(2)不必要的使用<code>std::move</code></a></h3>
<p><code>std::move</code>的作用是告诉编译器“这不是一个左值，你可以安全地移动它”，但是如果你已经明确知道对象不会被复制（例如返回一个对象的右值引用），就不必使用<code>std::move</code>。</p>
<p>例如：</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; createVector() {
    std::vector&lt;int&gt; v = {1, 2, 3};
    return v;  // 编译器会自动进行返回值优化（RVO），不需要手动使用std::move
}
</code></pre>
<p>这里的返回值优化（RVO）允许编译器在返回<code>v</code>时进行移动，而不需要显式调用<code>std::move</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdoptional"><a class="header" href="#stdoptional">std::optional</a></h1>
<p><code>std::optional</code> 是 C++17 引入的一个工具类，用来表示一个 <strong>可选值</strong>。它可以包含某个类型的值，也可以为空（即没有值）。这在函数返回值和状态表达上尤其有用，可以避免使用特殊标志值（如 <code>-1</code> 或 <code>nullptr</code>）来表示“无效”或“不存在”的情况。它本质上是对 <strong>“可空值”</strong> 概念的抽象：</p>
<ul>
<li><strong>有值 (engaged)</strong>：存储一个 <code>T</code> 类型对象，保证其生命周期绑定到 <code>optional</code> 对象上。</li>
<li><strong>无值 (disengaged)</strong>：表示空状态，此时不存储任何对象。</li>
</ul>
<p>相比于传统的返回 <code>nullptr</code> 或 <code>std::pair&lt;T,bool&gt;</code> 表示失败，<code>std::optional</code> 更加语义化、类型安全，尤其适合构造成本较高的对象。</p>
<p>其模板定义如下：</p>
<pre><code class="language-cpp">template&lt; class T &gt;
class optional;
</code></pre>
<h2 id="1-引入-2"><a class="header" href="#1-引入-2">1. 引入</a></h2>
<p>被包括在 <code>&lt;optional&gt;</code> 头文件中。</p>
<pre><code class="language-cpp">#include &lt;optional&gt;
</code></pre>
<p><code>T</code> 必须满足 <strong>Destructible</strong>（可析构）。</p>
<p>不允许是引用类型、数组类型、函数类型或 <code>void</code>。</p>
<p>从 C++26 起，<code>optional&lt;T&gt;</code> 还支持作为 <strong>range view</strong>。</p>
<h2 id="2-stdoptional-的工作原理"><a class="header" href="#2-stdoptional-的工作原理">2. <code>std::optional</code> 的工作原理</a></h2>
<ul>
<li><code>optional&lt;T&gt;</code> 内部通过一个 <strong>布尔标志</strong> + <strong>可能存在的值存储区</strong> 来实现：
<ul>
<li>当 engaged 时，<code>optional</code> 内部构造并管理一个 <code>T</code> 对象。</li>
<li>当 disengaged 时，标志为 false，存储区未构造对象。</li>
</ul>
</li>
</ul>
<p>这使得 <code>optional</code> 更接近于 “可能为空的对象”，而不是指针。
即使提供了 <code>operator*</code> 和 <code>operator-&gt;</code>，它依旧是值语义而非指针语义。</p>
<h3 id="1-为什么需要-stdoptional"><a class="header" href="#1-为什么需要-stdoptional">(1) 为什么需要 <code>std::optional</code>？</a></h3>
<p>传统做法：</p>
<ul>
<li>C 风格函数通常用返回值来表示错误，用输出参数来返回数据。</li>
<li>某些场景需要用 <code>nullptr</code> 或 <code>-1</code> 表示“无效”，但这并不类型安全。</li>
</ul>
<p><code>std::optional</code> 提供了一个清晰、安全的方式：返回“要么有值，要么没有值”。</p>
<h3 id="2-基本使用"><a class="header" href="#2-基本使用">(2) 基本使用</a></h3>
<pre><code class="language-cpp">std::optional&lt;int&gt; maybeInt;           // 默认构造：无值
std::optional&lt;int&gt; hasInt = 42;        // 构造：有值
std::optional&lt;int&gt; emptyInt = std::nullopt; // 显式无值

if (hasInt) {
    std::cout &lt;&lt; "Value: " &lt;&lt; *hasInt &lt;&lt; "\n";  // 解引用访问
}
</code></pre>
<h2 id="3-使用-stdoptional-的场景"><a class="header" href="#3-使用-stdoptional-的场景">3. 使用 <code>std::optional</code> 的场景</a></h2>
<h3 id="1-函数返回值"><a class="header" href="#1-函数返回值">(1) 函数返回值</a></h3>
<p>最常见的场景是函数可能“有值”或“无值”。</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; findValue(const std::vector&lt;int&gt;&amp; vec, int target) {
    for (auto v : vec) {
        if (v == target) return v;
    }
    return std::nullopt;
}

auto result = findValue({1, 2, 3}, 2);
if (result) {
    std::cout &lt;&lt; "Found: " &lt;&lt; *result &lt;&lt; "\n";
}
</code></pre>
<h3 id="2-延迟初始化"><a class="header" href="#2-延迟初始化">(2) 延迟初始化</a></h3>
<p><code>std::optional</code> 可以用来延迟对象构造，仅在需要时才赋值。</p>
<pre><code class="language-cpp">std::optional&lt;std::string&gt; cache;
if (!cache) {
    cache = "Hello";  // 仅在需要时才构造
}
</code></pre>
<h3 id="3-配合结构化绑定"><a class="header" href="#3-配合结构化绑定">(3) 配合结构化绑定</a></h3>
<pre><code class="language-cpp">std::optional&lt;std::pair&lt;int, int&gt;&gt; divide(int a, int b) {
    if (b == 0) return std::nullopt;
    return std::make_pair(a / b, a % b);
}

if (auto res = divide(10, 3)) {
    auto [q, r] = *res;
    std::cout &lt;&lt; "Quotient: " &lt;&lt; q &lt;&lt; " Remainder: " &lt;&lt; r &lt;&lt; "\n";
}
</code></pre>
<h2 id="4-常用操作"><a class="header" href="#4-常用操作">4. 常用操作</a></h2>
<h3 id="0-构造与析构"><a class="header" href="#0-构造与析构">(0) 构造与析构</a></h3>
<pre><code class="language-cpp">// 默认构造：无值
std::optional&lt;int&gt; a;

// 从值构造
std::optional&lt;int&gt; b = 42;
std::optional&lt;std::string&gt; c{"hello"};

// 拷贝构造 / 赋值
std::optional&lt;int&gt; d = b;

// 移动构造 / 赋值
std::optional&lt;std::string&gt; e = std::move(c);

// 使用 nullopt 构造空对象
std::optional&lt;int&gt; f = std::nullopt;

// 析构：生命周期结束时自动析构其中的值（如果有值）
{
    std::optional&lt;std::string&gt; g{"RAII"};
} // g 的析构会自动调用 std::string 的析构函数
</code></pre>
<h3 id="1-value-与-value_or"><a class="header" href="#1-value-与-value_or">(1) <code>value()</code> 与 <code>value_or()</code></a></h3>
<pre><code class="language-cpp">std::optional&lt;int&gt; x = 10;
std::cout &lt;&lt; x.value() &lt;&lt; "\n";         // 获取值，若为空抛出 std::bad_optional_access
std::cout &lt;&lt; x.value_or(0) &lt;&lt; "\n";     // 若为空返回默认值
</code></pre>
<h3 id="2-emplace-与-reset"><a class="header" href="#2-emplace-与-reset">(2) <code>emplace()</code> 与 <code>reset()</code></a></h3>
<pre><code class="language-cpp">std::optional&lt;std::string&gt; name;
name.emplace("Alice");   // 原地构造值
std::cout &lt;&lt; *name &lt;&lt; "\n";
name.reset();            // 清空，变为无值
</code></pre>
<h3 id="3-布尔上下文与-has_value"><a class="header" href="#3-布尔上下文与-has_value">(3) 布尔上下文与 <code>has_value()</code></a></h3>
<pre><code class="language-cpp">std::optional&lt;int&gt; maybe;
if (maybe) {             // 等价于 maybe.has_value()
    std::cout &lt;&lt; "有值\n";
} else {
    std::cout &lt;&lt; "无值\n";
}
</code></pre>
<h3 id="4-访问操作符-operator-与-operator-"><a class="header" href="#4-访问操作符-operator-与-operator-">(4) 访问操作符 <code>operator*</code> 与 <code>operator-&gt;</code></a></h3>
<pre><code class="language-cpp">std::optional&lt;std::string&gt; msg = "Hello";
std::cout &lt;&lt; (*msg).size() &lt;&lt; "\n";     // 解引用访问
std::cout &lt;&lt; msg-&gt;size() &lt;&lt; "\n";       // 箭头访问
</code></pre>
<h3 id="5-swap"><a class="header" href="#5-swap">(5) <code>swap()</code></a></h3>
<pre><code class="language-cpp">std::optional&lt;int&gt; a = 1, b = 2;
a.swap(b);                             // 交换内容
std::cout &lt;&lt; *a &lt;&lt; " " &lt;&lt; *b &lt;&lt; "\n";  // 输出 2 1
</code></pre>
<h3 id="6-工厂函数-stdmake_optional-与-stdnullopt"><a class="header" href="#6-工厂函数-stdmake_optional-与-stdnullopt">(6) 工厂函数 <code>std::make_optional</code> 与 <code>std::nullopt</code></a></h3>
<pre><code class="language-cpp">auto a = std::make_optional&lt;int&gt;(42);   // 创建有值 optional
std::optional&lt;int&gt; b = std::nullopt;    // 创建空 optional
</code></pre>
<h3 id="7-常见-value_or-模式"><a class="header" href="#7-常见-value_or-模式">(7) 常见 <code>value_or</code> 模式</a></h3>
<pre><code class="language-cpp">std::optional&lt;std::string&gt; maybe_name;
std::string name = maybe_name.value_or("Default");  // 若无值，使用默认值
</code></pre>
<h3 id="8-c23-单子操作monadic-operations"><a class="header" href="#8-c23-单子操作monadic-operations">(8) C++23 单子操作（Monadic operations）</a></h3>
<pre><code class="language-cpp">std::optional&lt;int&gt; num = 5;

// and_then: 仅在有值时继续计算
auto squared = num.and_then([](int x) { return std::optional&lt;int&gt;(x * x); });

// transform: 值存在时映射为新值
auto str = num.transform([](int x) { return std::to_string(x); });

// or_else: 若无值则提供替代
auto val = num.or_else([] { return std::optional&lt;int&gt;(100); });
</code></pre>
<h2 id="5-stdoptional-的常见误用"><a class="header" href="#5-stdoptional-的常见误用">5. <code>std::optional</code> 的常见误用</a></h2>
<h3 id="1-滥用在必然有值的场景"><a class="header" href="#1-滥用在必然有值的场景">(1) 滥用在“必然有值”的场景</a></h3>
<p>如果某个值在逻辑上 <strong>必然存在</strong>，使用 <code>optional</code> 反而多此一举，降低可读性。</p>
<h3 id="2-忘记检查是否有值"><a class="header" href="#2-忘记检查是否有值">(2) 忘记检查是否有值</a></h3>
<p>错误示例：</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; x;
std::cout &lt;&lt; *x;  // 未检查直接解引用，未定义行为
</code></pre>
<p>正确示例：</p>
<pre><code class="language-cpp">if (x) std::cout &lt;&lt; *x;
</code></pre>
<h3 id="3-不当替代指针或容器"><a class="header" href="#3-不当替代指针或容器">(3) 不当替代指针或容器</a></h3>
<p><code>std::optional</code> 适合表示“零或一”的情况，但如果可能有多个值，应该用 <code>std::vector</code> 或其他容器，而不是 <code>optional&lt;std::vector&lt;T&gt;&gt;</code> 滥用。</p>
<h2 id="6-与-rust-的类比"><a class="header" href="#6-与-rust-的类比">6. 与 Rust 的类比</a></h2>
<ul>
<li>Rust 的 <code>Option&lt;T&gt;</code> 与 C++ 的 <code>std::optional&lt;T&gt;</code> 类似，都是“要么有值（Some），要么无值（None）”。</li>
<li>不同点：Rust 强制模式匹配，保证空值情况不会被遗漏，而 C++ 中 <code>optional</code> 需要程序员手动检查。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdany"><a class="header" href="#stdany">std::any</a></h1>
<p><code>std::any</code> 是 C++17 引入的一个工具类，用来表示 <strong>类型安全的任意类型容器</strong>。它可以存储任何 <strong>可拷贝构造</strong> 的类型，并且在运行时动态管理其类型和生命周期。<code>std::any</code> 常用于需要存储不同类型对象，但在编译时无法确定类型的场景。</p>
<ul>
<li><strong>有值 (engaged)</strong>：存储一个特定类型的对象。</li>
<li><strong>无值 (disengaged)</strong>：表示空状态，没有存储任何对象。</li>
</ul>
<p>相比于 <code>void*</code> 或不安全的类型转换，<code>std::any</code> 提供了类型安全的访问和异常检测机制。</p>
<p>其模板定义如下：</p>
<pre><code class="language-cpp">class any;
</code></pre>
<h2 id="1-引入-3"><a class="header" href="#1-引入-3">1. 引入</a></h2>
<p>被包括在 <code>&lt;any&gt;</code> 头文件中。</p>
<pre><code class="language-cpp">#include &lt;any&gt;
</code></pre>
<p>存储的类型必须满足 <strong>CopyConstructible</strong>（可拷贝构造）。</p>
<h2 id="2-stdany-的工作原理"><a class="header" href="#2-stdany-的工作原理">2. <code>std::any</code> 的工作原理</a></h2>
<ul>
<li>内部通过 <strong>指针 + 类型信息（typeid）</strong> 或小对象优化实现：
<ul>
<li>当对象有值时，存储实际类型对象。</li>
<li>当对象为空时，存储状态标记为空。</li>
</ul>
</li>
<li>通过 <code>any_cast</code> 提供类型安全访问，如果类型不匹配会抛出 <code>std::bad_any_cast</code> 异常。</li>
</ul>
<h3 id="1-为什么需要-stdany"><a class="header" href="#1-为什么需要-stdany">(1) 为什么需要 <code>std::any</code>？</a></h3>
<ul>
<li>当需要存储 <strong>不同类型的对象</strong>，但类型在编译时未知时。</li>
<li>用于实现 <strong>动态类型容器</strong>、事件系统或通用缓存。</li>
<li>避免使用不安全的 <code>void*</code> 或 <code>union</code>。</li>
</ul>
<h3 id="2-基本使用-1"><a class="header" href="#2-基本使用-1">(2) 基本使用</a></h3>
<pre><code class="language-cpp">std::any a = 1;             // 存储 int
a = 3.14;                   // 改为存储 double
a = std::string("hello");   // 改为存储 std::string

if (a.has_value()) {
    std::cout &lt;&lt; std::any_cast&lt;std::string&gt;(a) &lt;&lt; "\n";
}
</code></pre>
<h2 id="3-使用-stdany-的场景"><a class="header" href="#3-使用-stdany-的场景">3. 使用 <code>std::any</code> 的场景</a></h2>
<h3 id="1-动态类型存储"><a class="header" href="#1-动态类型存储">(1) 动态类型存储</a></h3>
<pre><code class="language-cpp">std::vector&lt;std::any&gt; values;
values.push_back(10);
values.push_back(3.14);
values.push_back(std::string("text"));

for (auto&amp; v : values) {
    if (v.type() == typeid(int))
        std::cout &lt;&lt; std::any_cast&lt;int&gt;(v) &lt;&lt; "\n";
}
</code></pre>
<h3 id="2-类型安全访问"><a class="header" href="#2-类型安全访问">(2) 类型安全访问</a></h3>
<p>通过 <code>any_cast</code> 访问内部对象，类型不匹配会抛异常：</p>
<pre><code class="language-cpp">std::any a = 42;
try {
    double d = std::any_cast&lt;double&gt;(a);  // 类型错误，会抛出 std::bad_any_cast
} catch (const std::bad_any_cast&amp; e) {
    std::cout &lt;&lt; e.what() &lt;&lt; "\n";
}
</code></pre>
<h3 id="3-指针访问"><a class="header" href="#3-指针访问">(3) 指针访问</a></h3>
<p><code>any_cast</code> 也可返回指针，类型错误时返回 nullptr：</p>
<pre><code class="language-cpp">std::any a = 3;
if (int* p = std::any_cast&lt;int&gt;(&amp;a)) {
    std::cout &lt;&lt; *p &lt;&lt; "\n";  // 输出 3
}
</code></pre>
<h2 id="4-常用操作-1"><a class="header" href="#4-常用操作-1">4. 常用操作</a></h2>
<h3 id="0-构造与析构-1"><a class="header" href="#0-构造与析构-1">(0) 构造与析构</a></h3>
<pre><code class="language-cpp">std::any a;                 // 默认构造：无值
std::any b = 42;            // 从值构造
std::any c = std::string("hi"); // 从其他类型构造

// 拷贝构造 / 拷贝赋值
std::any d = b;
d = c;

// 移动构造 / 移动赋值
std::any e = std::move(c);
e = std::move(b);

// 析构：生命周期结束时自动析构存储的对象
{
    std::any f = std::string("RAII");
} // f 的析构自动调用 std::string 析构函数
</code></pre>
<h3 id="1-has_value-与-type"><a class="header" href="#1-has_value-与-type">(1) <code>has_value()</code> 与 <code>type()</code></a></h3>
<pre><code class="language-cpp">std::any a = 42;
if (a.has_value()) {
    std::cout &lt;&lt; "类型: " &lt;&lt; a.type().name() &lt;&lt; "\n";
}
</code></pre>
<h3 id="2-emplace-与-reset-1"><a class="header" href="#2-emplace-与-reset-1">(2) <code>emplace()</code> 与 <code>reset()</code></a></h3>
<pre><code class="language-cpp">std::any a;
a.emplace&lt;std::string&gt;("Hello");  // 原地构造新值
std::cout &lt;&lt; std::any_cast&lt;std::string&gt;(a) &lt;&lt; "\n";
a.reset();                         // 清空
</code></pre>
<h3 id="3-赋值操作-operator"><a class="header" href="#3-赋值操作-operator">(3) 赋值操作 <code>operator=</code></a></h3>
<pre><code class="language-cpp">std::any a, b;
a = 10;                // 赋值 int
b = std::string("hi"); // 赋值 string
a = b;                 // 拷贝 b 的值到 a
</code></pre>
<h3 id="4-swap"><a class="header" href="#4-swap">(4) <code>swap()</code></a></h3>
<pre><code class="language-cpp">std::any a = 1, b = 2;
a.swap(b);
std::cout &lt;&lt; std::any_cast&lt;int&gt;(a) &lt;&lt; " " &lt;&lt; std::any_cast&lt;int&gt;(b) &lt;&lt; "\n"; // 输出 2 1
</code></pre>
<h3 id="5-工厂函数-stdmake_any"><a class="header" href="#5-工厂函数-stdmake_any">(5) 工厂函数 <code>std::make_any</code></a></h3>
<pre><code class="language-cpp">auto a = std::make_any&lt;int&gt;(42);           // 创建 any 并存储 int
auto b = std::make_any&lt;std::string&gt;("hi"); // 创建 any 并存储 string
</code></pre>
<h3 id="6-非成员函数-any_cast"><a class="header" href="#6-非成员函数-any_cast">(6) 非成员函数 <code>any_cast</code></a></h3>
<pre><code class="language-cpp">std::any a = 123;
int* p = std::any_cast&lt;int&gt;(&amp;a);           // 指针访问
int v = std::any_cast&lt;int&gt;(a);             // 值访问，类型错误抛异常
</code></pre>
<h2 id="5-stdany-的常见误用"><a class="header" href="#5-stdany-的常见误用">5. <code>std::any</code> 的常见误用</a></h2>
<h3 id="1-滥用"><a class="header" href="#1-滥用">(1) 滥用</a></h3>
<ul>
<li>不应将 <code>std::any</code> 用作所有类型的通用容器，它不能替代容器或指针管理。</li>
<li>仅在 <strong>存储单个动态类型对象</strong> 且类型不确定时使用。</li>
</ul>
<h3 id="2-忘记类型检查"><a class="header" href="#2-忘记类型检查">(2) 忘记类型检查</a></h3>
<pre><code class="language-cpp">std::any a = 42;
std::cout &lt;&lt; std::any_cast&lt;double&gt;(a); // 未检查类型，抛异常
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdvariant"><a class="header" href="#stdvariant"><code>std::variant</code></a></h1>
<p><code>std::variant</code> 是 C++17 引入的 <strong>类型安全联合（type-safe union）</strong>。在任一时刻，<code>variant&lt;...&gt;</code> 要么保存其候选类型列表中的某一类型的对象（active alternative），要么在异常情况等导致的特殊情形下处于<strong>无值</strong>状态（<code>valueless_by_exception()</code>）。</p>
<p>头文件：</p>
<pre><code class="language-cpp">#include &lt;variant&gt;
</code></pre>
<h2 id="1-模板定义"><a class="header" href="#1-模板定义">1. 模板定义</a></h2>
<pre><code class="language-cpp">template&lt; class... Types &gt;
class variant;
</code></pre>
<ul>
<li>模板参数为 <code>Types...</code>：每个 <code>T</code> 必须满足 <strong>Destructible</strong>（能被析构）。</li>
<li><strong>不允许</strong>持有引用类型、数组类型或 <code>void</code>。</li>
<li>可以重复出现相同类型（例如 <code>variant&lt;int,int&gt;</code> 合法），也可以出现不同 cv 限定的同一基础类型（如 <code>int</code> 与 <code>const int</code>）。</li>
<li><strong>注意</strong>：如果你用同一个具体类型多次，基于类型的访问（<code>std::get&lt;T&gt;</code> / <code>get_if&lt;T&gt;</code>）会变得<strong>歧义 / 编译失败</strong>（只能用索引或明确 <code>in_place_type</code>/<code>in_place_index</code>）。</li>
<li>默认构造：<strong>默认构造会构造第一个候选类型的默认值</strong>，如果第一个候选类型不可默认构造，则 <code>variant</code> 本身也不可默认构造。可以把 <code>std::monostate</code> 放在首位以保证可默认构造。</li>
</ul>
<h2 id="2-存储与对象布局"><a class="header" href="#2-存储与对象布局">2. 存储与对象布局</a></h2>
<ul>
<li><code>variant</code> 内部<strong>存储了 discriminator（索引）与一个能容纳最大候选类型的缓冲区</strong>；当 <code>variant</code> 持有某个类型 <code>T</code> 时，一个 <code>T</code> 对象会嵌套（placement-new）在该缓冲区内。</li>
<li>因此 <code>variant</code> 的大小≈（max sizeof(alternatives)）+ 对齐 + discriminator 大小。</li>
<li>在异常情况下（构造/赋值期间）有可能变为 <strong>valueless_by_exception</strong>（见下文）。</li>
</ul>
<h2 id="3-主要成员函数--重载"><a class="header" href="#3-主要成员函数--重载">3. 主要成员函数 / 重载</a></h2>
<blockquote>
<p>下面列出常用操作、签名（伪签名风格）与行为说明与例子。</p>
</blockquote>
<h3 id="构造与析构"><a class="header" href="#构造与析构">构造与析构</a></h3>
<ul>
<li>
<p><code>variant()</code></p>
<ul>
<li>默认构造：构造第一个候选类型的默认值（若可行）。</li>
<li>否则 <code>variant</code> 不可默认构造。</li>
</ul>
</li>
<li>
<p><code>variant(const variant&amp;)</code> / <code>variant(variant&amp;&amp;)</code></p>
<ul>
<li>拷贝 / 移动构造。条件：候选类型支持相应操作；若某些候选类型不可拷贝/移动，相应操作会被删除。</li>
<li>如果在移动过程中抛出异常，可能导致 <code>valueless_by_exception</code>（取决于具体实现与异常传播）。</li>
</ul>
</li>
<li>
<p>converting constructors（从某个值构造）</p>
<ul>
<li>如果传入 <code>U</code> 可明确/唯一地构造某个候选类型，<code>variant</code> 会构造该候选。若存在二义性（能构造多个候选），编译失败。</li>
</ul>
</li>
<li>
<p>in-place 构造（直接在 variant 内就地构造）</p>
<pre><code class="language-cpp">variant(in_place_type&lt;T&gt;, Args&amp;&amp;...);
variant(in_place_index&lt;I&gt;, Args&amp;&amp;...);
</code></pre>
<ul>
<li><code>in_place_type_t</code> / <code>in_place_index_t</code> 用于在 variant 内直接构造目标 alternative，避免先创建临时再赋值。</li>
</ul>
</li>
<li>
<p><code>~variant()</code></p>
<ul>
<li>默认析构：会调用当前活动 alternative 的析构函数（如果有值）。</li>
</ul>
</li>
</ul>
<h3 id="赋值operator"><a class="header" href="#赋值operator">赋值（operator=）</a></h3>
<ul>
<li>
<p><code>variant&amp; operator=(const variant&amp;);</code></p>
</li>
<li>
<p><code>variant&amp; operator=(variant&amp;&amp;);</code></p>
<ul>
<li>这两个做拷贝/移动赋值。赋值行为在不同情况下（同类型 index / 不同 index）会调用相应 alternative 的赋值/析构+构造。</li>
<li>赋值过程中若抛异常，可能使 <code>variant</code> 进入 <code>valueless_by_exception</code>。</li>
</ul>
</li>
<li>
<p><code>template&lt;class T&gt; variant&amp; operator=(T&amp;&amp;);</code></p>
<ul>
<li>converting assignment：当 <code>T</code> 可以唯一构造某个候选类型时，执行相应赋值/替换。</li>
</ul>
</li>
<li>
<p><code>variant&amp; operator=(std::monostate)</code> 等（视候选类型而定）。</p>
</li>
</ul>
<h3 id="观察器observers"><a class="header" href="#观察器observers">观察器（Observers）</a></h3>
<ul>
<li>
<p><code>std::size_t index() const noexcept;</code></p>
<ul>
<li>返回当前活动的候选类型的零基索引（0..N-1）。</li>
<li>如果处于 <code>valueless_by_exception</code>，返回 <code>variant_npos</code>（常为 <code>std::size_t(-1)</code>）。</li>
</ul>
</li>
<li>
<p><code>bool valueless_by_exception() const noexcept;</code></p>
<ul>
<li>如果 <code>variant</code> 处于无值状态（例如在变更 active alternative 时异常导致）返回 <code>true</code>。</li>
</ul>
</li>
</ul>
<h3 id="修改modifiers"><a class="header" href="#修改modifiers">修改（Modifiers）</a></h3>
<ul>
<li>
<p><code>template&lt;class T, class... Args&gt; T&amp; emplace(Args&amp;&amp;...);</code></p>
<ul>
<li><code>emplace&lt;T&gt;(args...)</code>：在 <code>variant</code> 中就地构造类型 <code>T</code>（T 必须是某个 alternative）；会销毁旧的 active 值（若有），然后就地构造新值。</li>
<li>异常安全：如果构造抛出，<code>variant</code> 可能进入 <code>valueless_by_exception</code>（取决于实现与被替换对象的销毁时机）。</li>
</ul>
</li>
<li>
<p><code>template&lt;size_t I, class... Args&gt; variant&amp; emplace(in_place_index_t&lt;I&gt;, Args&amp;&amp;...);</code></p>
<ul>
<li>使用索引 I 就地构造。</li>
</ul>
</li>
<li>
<p><code>void swap(variant&amp; other) noexcept( /* depends */ );</code></p>
<ul>
<li>交换两个 variant 的状态与内容。noexcept 与具体候选类型的 swap/移动操作相关。</li>
</ul>
</li>
</ul>
<h3 id="访问get--get_if"><a class="header" href="#访问get--get_if">访问（get / get_if）</a></h3>
<ul>
<li>
<p><code>std::get&lt;T&gt;(variant&amp;)</code> / <code>std::get&lt;I&gt;(variant&amp;)</code></p>
<ul>
<li><code>get&lt;T&gt;</code>（按类型访问）要求 <code>T</code> 在候选类型中<strong>唯一</strong>，否则编译错误。</li>
<li><code>get&lt;I&gt;</code>（按索引访问）直接访问索引为 <code>I</code> 的候选类型。</li>
<li>若 <code>variant</code> 当前不保存请求的 alternative，<code>std::get</code> 会 <strong>抛出 <code>std::bad_variant_access</code>（运行时异常）</strong>。</li>
</ul>
</li>
<li>
<p><code>std::get_if&lt;T&gt;(&amp;variant)</code> / <code>std::get_if&lt;I&gt;(&amp;variant)</code></p>
<ul>
<li><code>get_if</code> 返回指向当前值的指针（非 <code>nullptr</code> 表示匹配），失败时返回 <code>nullptr</code>。不会抛异常，通常是更安全的访问方式。</li>
<li>有 <code>const</code> / 非 <code>const</code> 重载：<code>const T* get_if&lt;const T&gt;(&amp;const variant)</code> 等。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-cpp">std::variant&lt;int,std::string&gt; v = "hi";
if (auto p = std::get_if&lt;std::string&gt;(&amp;v)) {
    std::cout &lt;&lt; *p &lt;&lt; "\n";
}
try {
    std::cout &lt;&lt; std::get&lt;int&gt;(v); // 抛出 std::bad_variant_access
} catch (const std::bad_variant_access&amp; e) { ... }
</code></pre>
<h3 id="访问辅助stdholds_alternativetv"><a class="header" href="#访问辅助stdholds_alternativetv">访问辅助：<code>std::holds_alternative&lt;T&gt;(v)</code></a></h3>
<ul>
<li>返回 <code>true</code> 当且仅当 <code>v</code> 当前持有类型 <code>T</code>（同 <code>get_if&lt;T&gt;</code> 非空）。<code>T</code> 必须唯一出现在 alternatives 中。</li>
</ul>
<h3 id="访问索引常量"><a class="header" href="#访问索引常量">访问索引常量</a></h3>
<ul>
<li>
<p><code>constexpr std::size_t variant_npos = /* often size_t(-1) */;</code></p>
<ul>
<li>表示无效索引（用于 <code>index()</code> 返回值在 <code>valueless_by_exception()</code> 时）。</li>
</ul>
</li>
</ul>
<h2 id="4-访问与遍历stdvisitvisitor-模式"><a class="header" href="#4-访问与遍历stdvisitvisitor-模式">4. 访问与遍历：<code>std::visit</code>（Visitor 模式）</a></h2>
<h3 id="非成员-stdvisit自-c17-起"><a class="header" href="#非成员-stdvisit自-c17-起">非成员 <code>std::visit</code>（自 C++17 起）</a></h3>
<p>签名（概念）：</p>
<pre><code class="language-cpp">template &lt;class Visitor, class... Variants&gt;
decltype(auto) visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars);
</code></pre>
<ul>
<li><code>std::visit</code> 会将 visitor（可调用对象）以当前 variant（或多个 variants）的活动值作为参数调用。</li>
<li>当传入多个 <code>variant</code> 时，visitor 会被调用，参数顺序与 <code>variant</code> 顺序对应。</li>
<li>如果任一 <code>variant</code> 为 <code>valueless_by_exception()</code>，<code>std::visit</code> 通常会抛出 <code>std::bad_variant_access</code>。</li>
<li>返回值类型由 visitor 决定（可以返回 <code>void</code> 或其他类型）。</li>
<li>常用技巧：用 <code>overloaded</code> （多个 lambda 继承合并）来实现多分支处理：</li>
</ul>
<pre><code class="language-cpp">// helper
template&lt;class... Fs&gt; struct overloaded : Fs... { using Fs::operator()...; };
template&lt;class... Fs&gt; overloaded(Fs...) -&gt; overloaded&lt;Fs...&gt;;

// 使用
std::variant&lt;int,std::string&gt; v = 42;
std::visit(overloaded {
    [](int i){ std::cout&lt;&lt;"int "&lt;&lt;i&lt;&lt;"\n"; },
    [](const std::string&amp; s){ std::cout&lt;&lt;"str "&lt;&lt;s&lt;&lt;"\n"; }
}, v);
</code></pre>
<h3 id="成员-visitc26-提案member-visit"><a class="header" href="#成员-visitc26-提案member-visit">成员 <code>visit</code>（C++26 提案：member visit）</a></h3>
<ul>
<li>C++26 引入（或将引入）<code>v.visit(visitor)</code> 的成员形式作为便捷写法（请注意你使用的编译器/标准支持情况）。非成员 <code>std::visit</code> 在 C++17 就有。</li>
</ul>
<h2 id="5-比较运算与哈希"><a class="header" href="#5-比较运算与哈希">5. 比较运算与哈希</a></h2>
<ul>
<li>
<p><code>operator==</code> 等（C++17 起）与 <code>operator&lt;=&gt;</code>（C++20）有定义：通常两个 <code>variant</code> 先比较是否都 <code>valueless_by_exception()</code>，再比较 <code>index()</code>，在 index 相同时比较包含的值（按对应类型的比较运算）。</p>
<ul>
<li><code>==</code>：若两者 <code>index()</code> 相同且 contained values 相等 =&gt; true；若两个都 valueless =&gt; true；否则 false。</li>
<li><code>&lt;</code> / <code>&gt;</code>：若 <code>index()</code> 不同，通常以 <code>index()</code> 的大小决定排序；若相同，则调用 contained type 的 <code>&lt;</code>。</li>
<li>详细边界（valueless 等）以标准详细定义为准，但通常结果符合“按 index 首先排序，然后按值比较”的直觉。</li>
</ul>
</li>
<li>
<p><code>std::hash&lt;std::variant&lt;...&gt;&gt;</code> 在标准库有特化（要求所有候选类型可哈希）。</p>
</li>
</ul>
<h2 id="6-辅助类型与特性type-traits--helper-classes"><a class="header" href="#6-辅助类型与特性type-traits--helper-classes">6. 辅助类型与特性（type traits / helper classes）</a></h2>
<ul>
<li>
<p><code>std::monostate</code>（C++17）</p>
<ul>
<li>一个空占位类型，常用于将 <code>variant</code> 设置为默认可构造：<code>std::variant&lt;std::monostate, T1, T2&gt;</code>。</li>
</ul>
</li>
<li>
<p><code>std::bad_variant_access</code>（C++17）</p>
<ul>
<li>当用 <code>std::get&lt;T&gt;</code> / <code>std::get&lt;I&gt;</code> 访问但 <code>variant</code> 未持有该 alternative 时抛出。</li>
</ul>
</li>
<li>
<p><code>std::variant_size&lt;Variant&gt;</code> / <code>std::variant_size_v&lt;Variant&gt;</code>（C++17）</p>
<ul>
<li>编译期获取候选类型数量（常量表达式）。</li>
<li>例： <code>std::variant_size_v&lt;std::variant&lt;int,double&gt;&gt; == 2</code>。</li>
</ul>
</li>
<li>
<p><code>std::variant_alternative&lt;I, Variant&gt;::type</code> / <code>std::variant_alternative_t&lt;I, Variant&gt;</code>（C++17）</p>
<ul>
<li>编译期获取索引 <code>I</code> 对应的类型（类型别名）。</li>
<li>例： <code>std::variant_alternative_t&lt;0,std::variant&lt;int,double&gt;&gt;</code> 等于 <code>int</code>。</li>
</ul>
</li>
<li>
<p><code>variant_npos</code>：表示无值索引（如 <code>index()</code> 在 valueless 时返回此值）。</p>
</li>
</ul>
<h2 id="7-异常安全与-valueless_by_exception"><a class="header" href="#7-异常安全与-valueless_by_exception">7. 异常安全与 <code>valueless_by_exception</code></a></h2>
<ul>
<li>
<p>在某些变更 active alternative 的操作中（例如赋值、就地构造时），如果构造/移动/复制新的 alternative 的构造函数抛出异常，而旧对象已被销毁，<code>variant</code> 可能无法恢复到原先状态，从而进入 <code>valueless_by_exception()</code>。</p>
</li>
<li>
<p>一旦处于 <code>valueless_by_exception()</code>：</p>
<ul>
<li><code>index()</code> 返回 <code>variant_npos</code>；</li>
<li><code>std::get</code> 抛出 <code>std::bad_variant_access</code>；</li>
<li><code>std::get_if</code> 返回 <code>nullptr</code>；</li>
<li>一些操作（比如 <code>std::visit</code>）会抛出 <code>bad_variant_access</code>（取决于实现）。</li>
</ul>
</li>
<li>
<p>预防策略：当替换可能抛异常的类型时，优先使用 <code>emplace</code> 并在必要时进行异常处理；确保候选类型的构造/移动操作尽可能 <code>noexcept</code>，可以降低进入无值状态的风险。</p>
</li>
</ul>
<h2 id="8-常用例子"><a class="header" href="#8-常用例子">8. 常用例子</a></h2>
<p>基本使用与 get/get_if/holds_alternative</p>
<pre><code class="language-cpp">std::variant&lt;int,std::string&gt; v = "hello";
if (std::holds_alternative&lt;std::string&gt;(v)) {
    std::cout &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; "\n";
}
if (auto p = std::get_if&lt;int&gt;(&amp;v)) {
    std::cout &lt;&lt; "int: " &lt;&lt; *p &lt;&lt; "\n";
} else {
    std::cout &lt;&lt; "not int\n";
}
</code></pre>
<p>emplace / in_place</p>
<pre><code class="language-cpp">std::variant&lt;std::monostate, std::string, std::vector&lt;int&gt;&gt; v;
v.emplace&lt;std::string&gt;("abc");              // 就地构造 std::string
v.emplace&lt;std::vector&lt;int&gt;&gt;(3, 42);         // 就地构造 vector(3,42)
v.emplace&lt;in_place_index_t&lt;1&gt;&gt;("xyz");      // 使用索引就地构造（index=1 =&gt; std::string）
</code></pre>
<p>visit 与 overloaded 工具</p>
<pre><code class="language-cpp">auto handle = overloaded {
    [](int i){ std::cout&lt;&lt;"int "&lt;&lt;i&lt;&lt;"\n"; },
    [](const std::string&amp; s){ std::cout&lt;&lt;"str "&lt;&lt;s&lt;&lt;"\n"; }
};
std::variant&lt;int,std::string&gt; v = 10;
std::visit(handle, v);
</code></pre>
<p>使用 monostate 使可默认构造</p>
<pre><code class="language-cpp">std::variant&lt;std::monostate, std::string&gt; v; // 默认构造后 v 持有 monostate
</code></pre>
<h2 id="9-实用建议--常见误用"><a class="header" href="#9-实用建议--常见误用">9. 实用建议 / 常见误用</a></h2>
<ul>
<li><strong>不要把 <code>variant</code> 作为替代所有情况</strong>：类型过多会导致代码复杂和 visitor 分支膨胀。若候选类型集合非常大或松散，考虑设计别的抽象（多态/策略等）。</li>
<li><strong>当候选类型有重复的具体类型时，避免 <code>get&lt;T&gt;</code></strong>：因为会编译错误；使用 <code>get&lt;index&gt;</code> 或 <code>in_place_type</code> 显式选择。</li>
<li><strong>注意异常安全</strong>：替换 active alternative（赋值、emplace）如果构造抛异常，可能进入 <code>valueless_by_exception</code>；为关键路径确保候选类型的移动/复制构造尽可能 <code>noexcept</code>。</li>
<li><strong>避免把对 <code>variant</code> 的访问当作频繁反射</strong>：大量类型判断/切换会影响可读性和性能（虽然 <code>variant</code> 本质上是常数时间的判定与访问，但分支与 visitor 的实现复杂度需考虑）。</li>
<li>std::variant 类似于 Rust 的 enum，都能表示“一种类型中的多种可能”。
不同点在于Rust 的 enum 语法更简洁，且模式匹配是强制的；C++ 的 std::variant 需要 std::visit 或 get 来显式处理。</li>
</ul>
<h2 id="10-标准特性备注"><a class="header" href="#10-标准特性备注">10. 标准/特性备注</a></h2>
<ul>
<li><code>std::variant</code> 自 C++17 引入（特性宏：<code>__cpp_lib_variant</code> 等）。</li>
<li>标准后续对 <code>variant</code> 做过修订（例如 <code>std::visit</code> 扩展、constexpr 能力增强等）。例如有成员形式 <code>visit</code>（C++26 提议/扩展），以及使 <code>variant</code> 更多操作支持 <code>constexpr</code>（不同标准版本的支持程度由编译器/标准库实现决定）。</li>
<li>使用时注意你的编译器和标准库版本对 <code>variant</code> 的各项特性的支持情况（尤其是 <code>constexpr</code>、成员 <code>visit</code> 等较新特性）。</li>
</ul>
<h2 id="11-快速-api-参考"><a class="header" href="#11-快速-api-参考">11. 快速 API 参考</a></h2>
<ul>
<li>头文件：<code>&lt;variant&gt;</code></li>
<li>构造：<code>variant()</code>, <code>variant(in_place_type_t&lt;T&gt;, ...)</code>, <code>variant(in_place_index_t&lt;I&gt;, ...)</code>, converting constructors</li>
<li>赋值：<code>operator=(variant)</code>, <code>operator=(T&amp;&amp;)</code>（converting）</li>
<li>访问：<code>std::get&lt;T&gt;(v)</code>, <code>std::get&lt;I&gt;(v)</code>, <code>std::get_if&lt;T&gt;(&amp;v)</code>, <code>std::get_if&lt;I&gt;(&amp;v)</code></li>
<li>情况检测：<code>v.index()</code>, <code>v.valueless_by_exception()</code>, <code>std::holds_alternative&lt;T&gt;(v)</code></li>
<li>就地构造：<code>v.emplace&lt;T&gt;(args...)</code>, <code>v.emplace&lt;in_place_index_t&lt;I&gt;&gt;(args...)</code></li>
<li>访问模式：<code>std::visit(visitor, v1, v2, ...)</code>，C++26 可能支持成员 <code>v.visit(visitor)</code></li>
<li>辅助类型：<code>std::monostate</code>, <code>std::bad_variant_access</code>, <code>std::variant_size</code>, <code>std::variant_alternative_t</code>, <code>std::hash&lt;std::variant&lt;...&gt;&gt;</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containers"><a class="header" href="#containers">Containers</a></h1>
<h2 id="摘要"><a class="header" href="#摘要">摘要</a></h2>
<p><strong>C++ 标准模板库（STL）容器</strong>是用于存储数据的<strong>对象集合</strong>，它们提供了不同的存储方式、内存管理机制和访问模式。理解不同容器的<strong>底层结构</strong>、<strong>时间复杂度</strong>和<strong>内存特性</strong>，是高效进行C++编程的关键。</p>
<p>STL 容器主要分为三大类：<strong>序列容器</strong>、<strong>关联容器</strong>和<strong>无序容器</strong>。此外，<strong>容器适配器</strong>提供受限接口以模拟特定的数据结构（如栈和队列）。C++23 新增的<strong>扁平容器</strong>则代表了对内存局部性和性能优化的新探索。</p>
<h2 id="容器总览表"><a class="header" href="#容器总览表">容器总览表</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">容器类别</th><th style="text-align: left">容器名称</th><th style="text-align: left">描述</th><th style="text-align: left">存储特性</th><th style="text-align: left">核心操作复杂度</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>序列容器 (Sequence)</strong></td><td style="text-align: left"><strong>std::array</strong> (C++11)</td><td style="text-align: left">固定大小的静态数组。</td><td style="text-align: left">栈上，连续内存</td><td style="text-align: left">随机访问 \(O(1)\)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><strong>std::vector</strong></td><td style="text-align: left">动态数组。</td><td style="text-align: left">堆上，连续内存</td><td style="text-align: left">随机访问 \(O(1)\)，末尾增删平均 \(O(1)\)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><strong>std::deque</strong></td><td style="text-align: left">双端队列。</td><td style="text-align: left">分段连续内存</td><td style="text-align: left">随机访问 \(O(1)\)，头尾增删 \(O(1)\)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><strong>std::list</strong></td><td style="text-align: left">双向链表。</td><td style="text-align: left">堆上，非连续内存</td><td style="text-align: left">任意位置增删 \(O(1)\)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><strong>std::forward_list</strong> (C++11)</td><td style="text-align: left">单向链表。</td><td style="text-align: left">堆上，非连续内存</td><td style="text-align: left">头部增删 \(O(1)\)</td></tr>
<tr><td style="text-align: left"><strong>关联容器 (Associative)</strong></td><td style="text-align: left"><strong>std::set/multiset</strong></td><td style="text-align: left">存储<strong>键</strong>，基于红黑树。</td><td style="text-align: left">红黑树结构，有序</td><td style="text-align: left">查找/增删 \(O(\log n)\)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><strong>std::map/multimap</strong></td><td style="text-align: left">存储<strong>键值对</strong>，基于红黑树。</td><td style="text-align: left">红黑树结构，有序</td><td style="text-align: left">查找/增删 \(O(\log n)\)</td></tr>
<tr><td style="text-align: left"><strong>无序容器 (Unordered)</strong></td><td style="text-align: left"><strong>std::unordered_set/multiset</strong></td><td style="text-align: left">存储<strong>键</strong>，基于哈希表。</td><td style="text-align: left">哈希表结构，无序</td><td style="text-align: left">查找/增删 <strong>平均 \(O(1)\)</strong></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><strong>std::unordered_map/multimap</strong></td><td style="text-align: left">存储<strong>键值对</strong>，基于哈希表。</td><td style="text-align: left">哈希表结构，无序</td><td style="text-align: left">查找/增删 <strong>平均 \(O(1)\)</strong></td></tr>
<tr><td style="text-align: left"><strong>容器适配器 (Adaptors)</strong></td><td style="text-align: left"><strong>std::stack</strong></td><td style="text-align: left">LIFO（后进先出）。</td><td style="text-align: left">默认底层 \(\text{std::deque}\)</td><td style="text-align: left">\(O(1)\)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><strong>std::queue</strong></td><td style="text-align: left">FIFO（先进先出）。</td><td style="text-align: left">默认底层 \(\text{std::deque}\)</td><td style="text-align: left">\(O(1)\)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><strong>std::priority_queue</strong></td><td style="text-align: left">优先级队列（最大堆）。</td><td style="text-align: left">默认底层 \(\text{std::vector}\)</td><td style="text-align: left">插入/删除 \(O(\log n)\)</td></tr>
</tbody></table>
</div>
<h2 id="1-序列容器-sequence-containers"><a class="header" href="#1-序列容器-sequence-containers">1. 序列容器 (Sequence Containers)</a></h2>
<p>序列容器以线性方式排列元素，元素的位置由程序员控制，通常用于构建列表、数组等基础数据结构。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">特性</th><th style="text-align: left"><strong>std::array</strong></th><th style="text-align: left"><strong>std::vector</strong></th><th style="text-align: left"><strong>std::deque</strong></th><th style="text-align: left"><strong>std::forward_list</strong></th><th style="text-align: left"><strong>std::list</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>内存结构</strong></td><td style="text-align: left"><strong>连续内存</strong> (栈/全局)</td><td style="text-align: left"><strong>连续内存</strong> (堆)</td><td style="text-align: left"><strong>分段连续内存</strong></td><td style="text-align: left">非连续 (单向链表)</td><td style="text-align: left">非连续 (双向链表)</td></tr>
<tr><td style="text-align: left"><strong>随机访问</strong></td><td style="text-align: left">\(O(1)\) (最快)</td><td style="text-align: left">\(O(1)\) (快)</td><td style="text-align: left">\(O(1)\) (快)</td><td style="text-align: left"><strong>不支持</strong></td><td style="text-align: left"><strong>不支持</strong></td></tr>
<tr><td style="text-align: left"><strong>头部增删</strong></td><td style="text-align: left"><strong>不支持</strong></td><td style="text-align: left">\(O(n)\)</td><td style="text-align: left">\(O(1)\) (快)</td><td style="text-align: left">\(O(1)\) (最快)</td><td style="text-align: left">\(O(1)\) (快)</td></tr>
<tr><td style="text-align: left"><strong>尾部增删</strong></td><td style="text-align: left"><strong>不支持</strong></td><td style="text-align: left"><strong>平均 \(O(1)\)</strong> (最快)</td><td style="text-align: left">\(O(1)\) (快)</td><td style="text-align: left">\(O(n)\)</td><td style="text-align: left">\(O(1)\) (快)</td></tr>
<tr><td style="text-align: left"><strong>迭代器稳定性</strong></td><td style="text-align: left">稳定</td><td style="text-align: left">插入可能失效，删除指向被删元素的失效。</td><td style="text-align: left">插入/删除头尾稳定，中间失效。</td><td style="text-align: left">增删<strong>不会</strong>使其他迭代器失效。</td><td style="text-align: left">增删<strong>不会</strong>使其他迭代器失效。</td></tr>
<tr><td style="text-align: left"><strong>优势场景</strong></td><td style="text-align: left">编译期确定大小，极高性能。</td><td style="text-align: left"><strong>默认首选</strong>，需随机访问，主要在末尾操作。</td><td style="text-align: left">需头尾快速操作和随机访问的场景。</td><td style="text-align: left"><strong>极度频繁</strong>的插入/删除，内存占用要求低。</td><td style="text-align: left">频繁在<strong>任意位置</strong>插入/删除，需双向遍历。</td></tr>
</tbody></table>
</div>
<h2 id="2-有序关联容器-ordered-associative-containers"><a class="header" href="#2-有序关联容器-ordered-associative-containers">2. 有序关联容器 (Ordered Associative Containers)</a></h2>
<p>关联容器基于键 (Key) 进行<strong>有序</strong>存储，通常使用<strong>红黑树</strong>实现。它们自动保持元素/键的排序，适用于需要排序和快速查找的场景。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">特性</th><th style="text-align: left"><strong>std::set</strong></th><th style="text-align: left"><strong>std::multiset</strong></th><th style="text-align: left"><strong>std::map</strong></th><th style="text-align: left"><strong>std::multimap</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>底层结构</strong></td><td style="text-align: left"><strong>红黑树</strong></td><td style="text-align: left"><strong>红黑树</strong></td><td style="text-align: left"><strong>红黑树</strong></td><td style="text-align: left"><strong>红黑树</strong></td></tr>
<tr><td style="text-align: left"><strong>操作复杂度</strong></td><td style="text-align: left">查找、插入、删除均为 <strong>\(O(\log n)\)</strong></td><td style="text-align: left">查找、插入、删除均为 <strong>\(O(\log n)\)</strong></td><td style="text-align: left">查找、插入、删除均为 <strong>\(O(\log n)\)</strong></td><td style="text-align: left">查找、插入、删除均为 <strong>\(O(\log n)\)</strong></td></tr>
<tr><td style="text-align: left"><strong>存储内容</strong></td><td style="text-align: left">仅存储<strong>唯一键</strong></td><td style="text-align: left">存储<strong>可重复键</strong></td><td style="text-align: left">存储<strong>唯一键值对</strong></td><td style="text-align: left">存储<strong>可重复键值对</strong></td></tr>
<tr><td style="text-align: left"><strong>元素顺序</strong></td><td style="text-align: left"><strong>始终保持排序</strong> (按键)</td><td style="text-align: left"><strong>始终保持排序</strong> (按键)</td><td style="text-align: left"><strong>始终保持排序</strong> (按键)</td><td style="text-align: left"><strong>始终保持排序</strong> (按键)</td></tr>
<tr><td style="text-align: left"><strong>迭代器稳定性</strong></td><td style="text-align: left">插入或删除<strong>不会</strong>使指向其他元素的迭代器失效。</td><td style="text-align: left">插入或删除<strong>不会</strong>使指向其他元素的迭代器失效。</td><td style="text-align: left">插入或删除<strong>不会</strong>使指向其他元素的迭代器失效。</td><td style="text-align: left">插入或删除<strong>不会</strong>使指向其他元素的迭代器失效。</td></tr>
</tbody></table>
</div>
<h2 id="3-无序容器-unordered-containers"><a class="header" href="#3-无序容器-unordered-containers">3. 无序容器 (Unordered Containers)</a></h2>
<p>无序容器 (C++11) 基于 <strong>哈希表</strong> 实现。它们不保证元素顺序，但能提供<strong>极快</strong>的平均性能，适用于不关心元素顺序、追求极致查找速度的场景。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">特性</th><th style="text-align: left"><strong>std::unordered_set</strong></th><th style="text-align: left"><strong>std::unordered_multiset</strong></th><th style="text-align: left"><strong>std::unordered_map</strong></th><th style="text-align: left"><strong>std::unordered_multimap</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>底层结构</strong></td><td style="text-align: left"><strong>哈希表</strong> (桶和链表/树)</td><td style="text-align: left"><strong>哈希表</strong></td><td style="text-align: left"><strong>哈希表</strong></td><td style="text-align: left"><strong>哈希表</strong></td></tr>
<tr><td style="text-align: left"><strong>操作复杂度</strong></td><td style="text-align: left">平均 <strong>\(O(1)\)</strong>，最坏 \(O(n)\)</td><td style="text-align: left">平均 <strong>\(O(1)\)</strong>，最坏 \(O(n)\)</td><td style="text-align: left">平均 <strong>\(O(1)\)</strong>，最坏 \(O(n)\)</td><td style="text-align: left">平均 <strong>\(O(1)\)</strong>，最坏 \(O(n)\)</td></tr>
<tr><td style="text-align: left"><strong>存储内容</strong></td><td style="text-align: left">仅存储<strong>唯一键</strong></td><td style="text-align: left">存储<strong>可重复键</strong></td><td style="text-align: left">存储<strong>唯一键值对</strong></td><td style="text-align: left">存储<strong>可重复键值对</strong></td></tr>
<tr><td style="text-align: left"><strong>元素顺序</strong></td><td style="text-align: left"><strong>无序</strong> (取决于哈希值)</td><td style="text-align: left"><strong>无序</strong></td><td style="text-align: left"><strong>无序</strong></td><td style="text-align: left"><strong>无序</strong></td></tr>
<tr><td style="text-align: left"><strong>迭代器稳定性</strong></td><td style="text-align: left"><strong>不稳定</strong>。 \(\text{rehash}\) (重新散列) 时所有迭代器和引用都会失效。</td><td style="text-align: left"><strong>不稳定</strong>。 \(\text{rehash}\) 时所有迭代器和引用都会失效。</td><td style="text-align: left"><strong>不稳定</strong>。 \(\text{rehash}\) 时所有迭代器和引用都会失效。</td><td style="text-align: left"><strong>不稳定</strong>。 \(\text{rehash}\) 时所有迭代器和引用都会失效。</td></tr>
</tbody></table>
</div>
<h2 id="4-c23-扁平容器-flat-containers"><a class="header" href="#4-c23-扁平容器-flat-containers">4. C++23 扁平容器 (Flat Containers)</a></h2>
<p>C++23 引入的扁平容器旨在优化内存局部性。它们使用<strong>有序的 \(\text{std::vector}\)</strong> 作为底层存储，将键或键值对连续存储，从而利用现代CPU的缓存机制。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">容器名称</th><th style="text-align: left">对应关联容器</th><th style="text-align: left">底层结构</th><th style="text-align: left">查找性能</th><th style="text-align: left">插入/删除性能</th><th style="text-align: left">优势/劣势</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>std::flat_set / multiset</strong></td><td style="text-align: left">\(\text{std::set/multiset}\)</td><td style="text-align: left">有序 \(\text{std::vector}\)</td><td style="text-align: left">\(O(\log n)\) (二分查找，比红黑树更快)</td><td style="text-align: left"><strong>\(O(n)\)</strong> (需要移动元素)</td><td style="text-align: left"><strong>优势</strong>：极低的内存占用和极佳的遍历性能。<strong>劣势</strong>：高昂的插入/删除成本。</td></tr>
<tr><td style="text-align: left"><strong>std::flat_map / multimap</strong></td><td style="text-align: left">\(\text{std::map/multimap}\)</td><td style="text-align: left">一个或两个有序 \(\text{std::vector}\)</td><td style="text-align: left">\(O(\log n)\) (二分查找，比红黑树更快)</td><td style="text-align: left"><strong>\(O(n)\)</strong> (需要移动元素)</td><td style="text-align: left">适用于元素数量<strong>相对稳定</strong>、需要高查找速度和高效遍历的场景。</td></tr>
</tbody></table>
</div>
<h2 id="5-容器适配器-container-adaptors"><a class="header" href="#5-容器适配器-container-adaptors">5. 容器适配器 (Container Adaptors)</a></h2>
<p>容器适配器不是独立的容器，而是提供<strong>受限接口</strong>的类模板。它们使用底层容器来模拟特定的数据结构行为。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">容器名称</th><th style="text-align: left">接口模型</th><th style="text-align: left">核心操作</th><th style="text-align: left">默认底层容器</th><th style="text-align: left">可选底层容器</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>std::stack</strong></td><td style="text-align: left"><strong>LIFO</strong> (Last-In, First-Out)</td><td style="text-align: left">\(\text{push()}\), \(\text{pop()}\), \(\text{top()}\)</td><td style="text-align: left">\(\text{std::deque}\)</td><td style="text-align: left">\(\text{std::vector}\), \(\text{std::list}\)</td></tr>
<tr><td style="text-align: left"><strong>std::queue</strong></td><td style="text-align: left"><strong>FIFO</strong> (First-In, First-Out)</td><td style="text-align: left">\(\text{push()}\), \(\text{pop()}\), \(\text{front()}\)/\(\text{back()}\)</td><td style="text-align: left">\(\text{std::deque}\)</td><td style="text-align: left">\(\text{std::list}\)</td></tr>
<tr><td style="text-align: left"><strong>std::priority_queue</strong></td><td style="text-align: left">优先级排序 (最大堆)</td><td style="text-align: left">\(\text{push()}\), \(\text{pop()}\), \(\text{top()}\)</td><td style="text-align: left">\(\text{std::vector}\)</td><td style="text-align: left">\(\text{std::deque}\)</td></tr>
</tbody></table>
</div>
<h2 id="6-容器关键概念"><a class="header" href="#6-容器关键概念">6. 容器关键概念</a></h2>
<h3 id="迭代器-iterators"><a class="header" href="#迭代器-iterators">迭代器 (Iterators)</a></h3>
<p>迭代器是 STL 的核心，它提供了一种<strong>统一</strong>访问容器元素的方式，类似于指针。</p>
<ul>
<li><strong>随机访问迭代器</strong>：支持 \(O(1)\) 时间内的任意跳转（如 \(\text{std::vector}\), \(\text{std::deque}\), \(\text{std::array}\)）。</li>
<li><strong>双向迭代器</strong>：支持向前和向后移动（如 \(\text{std::list}\), \(\text{std::set}\), \(\text{std::map}\)）。</li>
<li><strong>前向迭代器</strong>：仅支持向前移动（如 \(\text{std::forward_list}\)）。</li>
</ul>
<h3 id="内存分配"><a class="header" href="#内存分配">内存分配</a></h3>
<ul>
<li><strong>连续内存</strong>：如 \(\text{std::vector}\) 和 \(\text{std::array}\)。优点是<strong>内存局部性好</strong>，CPU缓存利用率高；缺点是<strong>插入/删除中间元素成本高</strong>（需要移动后续元素）。</li>
<li><strong>非连续内存</strong>：如 \(\text{std::list}\) 和红黑树/哈希表容器。优点是<strong>插入/删除效率高</strong>；缺点是<strong>内存碎片化</strong>，CPU缓存效率低。</li>
</ul>
<h3 id="异常安全-exception-safety"><a class="header" href="#异常安全-exception-safety">异常安全 (Exception Safety)</a></h3>
<ul>
<li><strong>强保证</strong>：如果操作失败（抛出异常），容器保持不变。</li>
<li><strong>基本保证</strong>：如果操作失败，容器处于可用状态，但可能不是原来的状态。</li>
<li>\(\text{std::vector}\) 的 \(\text{push_back}\) 在需要重新分配内存时，如果复制构造函数抛出异常，可能导致<strong>强保证失效</strong>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdvector"><a class="header" href="#stdvector">std::vector</a></h1>
<p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。Vector支持<strong>快速随机访问</strong>。</p>
<h2 id="1-引入-4"><a class="header" href="#1-引入-4">1. 引入</a></h2>
<pre><code class="language-C++">#include &lt;vector&gt;
</code></pre>
<h2 id="2-存储方式-1"><a class="header" href="#2-存储方式-1">2. 存储方式</a></h2>
<p>为了支持随机访问，vector将元素连续存储–每个元素紧挨着前一个元素存储。容器中元素是连续存储的，且容器的大小是可变的。</p>
<p>在容器中增加元素时。vector根据存储元素的大小，在内存上申请一个空间，用于存储数据，空间的大小通常会大于所存储元素的实际大小，并且预留出一部分预留的空间，以便再次增加数据时，可以不用重新开辟空间。</p>
<p>当容器再次增加新的元素后，首先判断预留的空间是否够用，如果够用直接在预留空间中存储。如果预留的空间不够，需要在内存中开辟一整块新的更大的空间，并将vector原来的存储的数据<strong>拷贝</strong>过来，存储到新的内存中，然后在新的内存中增加需要增加的元素，这样保证存储的空间是连续的。所开的空间会预留出一部分空间，以便后续增加数据。</p>
<p>当 vector 增长时，容量通常会按一定比例（通常是1.5或2）增长。这有助于减少频繁的重新分配，提升性能。</p>
<h2 id="3-方法-1"><a class="header" href="#3-方法-1">3. 方法</a></h2>
<h3 id="1构造方法-1"><a class="header" href="#1构造方法-1">(1)构造方法</a></h3>
<ol>
<li>
<p><code>vector()</code>: 创建一个空vector，创建时也可以使用迭代器进行初始化</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec;
std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p><code>vector(size_t nSize)</code>: 创建一个vector,元素个数为nSize，默认构造函数会赋值与默认值</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec(10);
</code></pre>
</li>
<li>
<p><code>vector(size_t nSize,const t&amp; t)</code>: 创建一个vector，元素个数为nSize,且值均为t</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec(10, 5);
</code></pre>
</li>
<li>
<p><code>vector(const vector&amp;)</code>: 复制构造函数</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec1 = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; vec2(vec1);  // vec2 是 vec1 的一个复制版本
</code></pre>
</li>
<li>
<p><code>vector(begin,end)</code>: 复制[begin,end)区间内另一个数组的元素到vector中</p>
<pre><code class="language-c++">std::array&lt;int, 5&gt; arr = {1, 2, 3, 4, 5}; // 创建一个 std::array 或 std::vector
std::vector&lt;int&gt; vec(arr.begin(), arr.begin() + 3);  // 复制前3个元素
</code></pre>
</li>
</ol>
<h3 id="2大小函数"><a class="header" href="#2大小函数">(2)大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>: 返回vector中存放元素的实际数量（实际存储元素的个数）</p>
</li>
<li>
<p><code>size_t capacity() const</code>: 返回vector在内存中，开辟空间的容量（最多能放所少个元素不需要重新扩容）</p>
</li>
<li>
<p><code>size_t max_size() const</code>: 返回最大可允许的vector元素数量值</p>
</li>
<li>
<p><code>bool empty() const</code>: 返回数组是否为空</p>
</li>
<li>
<p><code>void shrink_to_fit()</code>: 调整数组大小(capacity)刚好适应当前的大小，节省内存</p>
</li>
<li>
<p><code>void resize(size_t size)</code>: 修改 vector 的大小。如果新大小比当前大小大，则扩大数组容量，会导致控制帧。如果新大小比当前大小小，则不做处理</p>
</li>
<li>
<p><code>void reserve(size_t n)</code>: 修改 vector 的capacity，为数组预留空间，不改变size。</p>
</li>
</ol>
<h3 id="3-增加函数"><a class="header" href="#3-增加函数">(3) 增加函数</a></h3>
<ol>
<li>
<p><code>push_back(const T&amp; value)</code>: 将元素 <code>value</code> 添加到 vector 的末尾。如果 vector 已满，<code>push_back</code> 会自动扩展容量。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3};
vec.push_back(4);  // 向 vec 中添加元素 4，vec 变为 {1, 2, 3, 4}
</code></pre>
</li>
<li>
<p><code>emplace_back(Args&amp;&amp;... args)</code>: 在 vector 的末尾就地构造一个元素，使用提供的参数直接构造该元素，而不是首先创建元素再添加。这样可以减少不必要的拷贝或移动操作。</p>
<pre><code class="language-c++">std::vector&lt;std::pair&lt;int, int&gt;&gt; vec;
vec.emplace_back(1, 2);  // 在末尾构造一个 pair&lt;int, int&gt;，值为 {1, 2}
</code></pre>
</li>
<li>
<p><code>insert(iterator pos, const T&amp; value)</code>: 在指定位置 <code>pos</code> 插入一个元素。元素会被插入到 <code>pos</code> 之前，<code>pos</code> 之后的元素会被向后移动。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 4, 5};
vec.insert(vec.begin() + 2, 3);  // 在位置2插入3，vec 变为 {1, 2, 3, 4, 5}
</code></pre>
</li>
<li>
<p><code>insert(iterator pos, size_t count, const T&amp; value)</code>: 在指定位置 <code>pos</code> 插入 <code>count</code> 个元素，所有的元素值为 <code>value</code>。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 4, 5};
vec.insert(vec.begin() + 2, 2, 3);  // 在位置2插入两个 3，vec 变为 {1, 2, 3, 3, 4, 5}
</code></pre>
</li>
<li>
<p><code>insert(iterator pos, InputIterator first, InputIterator last)</code>: 将 <code>[first, last)</code> 区间的元素插入到 <code>pos</code> 位置。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec1 = {1, 2, 3};
std::vector&lt;int&gt; vec2 = {4, 5};
vec1.insert(vec1.begin() + 2, vec2.begin(), vec2.end());  // 在位置 2 插入 vec2 中的元素，vec1 变为 {1, 2, 4, 5, 3}
</code></pre>
</li>
<li>
<p><code>emplace(iterator pos, Args&amp;&amp;... args)</code>: 在指定位置 <code>pos</code> 就地构造一个元素，使用提供的参数直接构造该元素。</p>
<pre><code class="language-c++">std::vector&lt;std::pair&lt;int, int&gt;&gt; vec;
vec.emplace(vec.begin(), 1, 2);  // 在位置0处构造一个 pair&lt;int, int&gt;，值为 {1, 2}
</code></pre>
</li>
</ol>
<h3 id="4-删除函数"><a class="header" href="#4-删除函数">(4) 删除函数</a></h3>
<ol>
<li>
<p><code>pop_back()</code>: 删除 vector 中的最后一个元素。该函数不会改变容器的容量，只是移除最后一个元素并缩小容器的大小。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4};
vec.pop_back();  // 删除最后一个元素，vec 变为 {1, 2, 3}
</code></pre>
</li>
<li>
<p><code>erase(iterator pos)</code>: 删除指定位置 <code>pos</code> 处的元素。删除后，后面的元素会向前移动。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4};
vec.erase(vec.begin() + 2);  // 删除索引为2的元素，vec 变为 {1, 2, 4}
</code></pre>
</li>
<li>
<p><code>erase(iterator first, iterator last)</code>: 删除 <code>[first, last)</code> 区间内的所有元素。此操作删除从 <code>first</code> 到 <code>last</code> 之间的元素（不包括 <code>last</code>）。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
vec.erase(vec.begin() + 1, vec.begin() + 4);  // 删除索引从 1 到 3 的元素，vec 变为 {1, 5}
</code></pre>
</li>
<li>
<p><code>clear()</code>: 删除 vector 中的所有元素，容器变为空，但容器的容量不会立即改变，直到发生重新分配。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4};
vec.clear();  // 删除所有元素，vec 变为空 { }
</code></pre>
</li>
</ol>
<h3 id="5遍历函数"><a class="header" href="#5遍历函数">(5)遍历函数</a></h3>
<ol>
<li>
<p><code>reference at(int pos)</code>: 返回 <code>pos</code> 位置元素的引用。与 <code>operator[]</code> 类似，但会检查边界，如果访问无效的位置会抛出 <code>std::out_of_range</code> 异常。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
int&amp; element = vec.at(2);  // 返回位置 2 处元素的引用，即值为 3
element = 10;  // 修改元素为 10
std::cout &lt;&lt; vec[2] &lt;&lt; std::endl;  // 输出: 10
</code></pre>
</li>
<li>
<p><code>reference front()</code>: 返回 vector 的第一个元素的引用。如果 vector 为空，调用该方法会导致未定义行为。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
int&amp; firstElement = vec.front();  // 返回第一个元素的引用，即值为 1
firstElement = 20;  // 修改第一个元素为 20
std::cout &lt;&lt; vec.front() &lt;&lt; std::endl;  // 输出: 20
</code></pre>
</li>
<li>
<p><code>reference back()</code>: 返回 vector 的最后一个元素的引用。如果 vector 为空，调用该方法会导致未定义行为。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
int&amp; lastElement = vec.back();  // 返回最后一个元素的引用，即值为 5
lastElement = 50;  // 修改最后一个元素为 50
std::cout &lt;&lt; vec.back() &lt;&lt; std::endl;  // 输出: 50
</code></pre>
</li>
<li>
<p><code>iterator begin()</code>: 返回指向 vector 第一个元素的迭代器。这个迭代器指向 vector 的首元素。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::vector&lt;int&gt;::iterator it = vec.begin();  // 返回指向第一个元素的迭代器
std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 1
</code></pre>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 vector 最后一个元素之后位置的迭代器。这个迭代器指向 vector 的尾元素的下一个位置。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::vector&lt;int&gt;::iterator it = vec.end();  // 返回指向最后一个元素之后位置的迭代器
--it;  // 移动到最后一个元素
std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 5
</code></pre>
</li>
<li>
<p><code>reverse_iterator rbegin()</code>: 返回指向 vector 最后一个元素的反向迭代器。该迭代器可以用来从后往前遍历元素。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::vector&lt;int&gt;::reverse_iterator rit = vec.rbegin();  // 返回指向最后一个元素的反向迭代器
std::cout &lt;&lt; *rit &lt;&lt; std::endl;  // 输出: 5
</code></pre>
</li>
<li>
<p><code>reverse_iterator rend()</code>: 返回指向 vector 第一个元素之前位置的反向迭代器。该迭代器指向 vector 的第一个元素之前的位置。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::vector&lt;int&gt;::reverse_iterator rit = vec.rend();  // 返回指向第一个元素之前位置的反向迭代器
++rit;  // 移动到第一个元素
std::cout &lt;&lt; *rit &lt;&lt; std::endl;  // 输出: 1
</code></pre>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 可以直接遍历 <code>std::vector</code> 中的每个元素，语法简洁。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
for (const int&amp; num : vec) {
    std::cout &lt;&lt; num &lt;&lt; " ";  // 输出: 1 2 3 4 5
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于索引）: 使用索引来遍历 <code>std::vector</code>，适合在需要访问元素索引的情况下使用。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
for (size_t i = 0; i &lt; vec.size(); ++i) {
    std::cout &lt;&lt; vec[i] &lt;&lt; " ";  // 输出: 1 2 3 4 5
}
</code></pre>
</li>
</ol>
<h3 id="6其他函数"><a class="header" href="#6其他函数">(6)其他函数</a></h3>
<ol>
<li>
<p><code>swap(vector&amp; other)</code>: 交换当前 vector 和另一个 vector 的内容。如果需要“删除”当前 vector 中的元素，可以通过交换将其与一个空的 vector 交换，从而达到清空的效果。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4};
std::vector&lt;int&gt; emptyVec;
vec.swap(emptyVec);  // vec 变为空，emptyVec 变为 {1, 2, 3, 4}
</code></pre>
</li>
<li>
<p><code>assign(size_t count, const T&amp; value)</code>: 将 <code>count</code> 个 <code>value</code> 元素赋值给当前 vector，替换原有内容。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec;
vec.assign(5, 10);  // 将 vec 赋值为 {10, 10, 10, 10, 10}
</code></pre>
</li>
<li>
<p><code>assign(InputIterator first, InputIterator last)</code>: 使用区间 <code>[first, last)</code> 的元素来填充当前 vector，替换原有内容。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec1 = {1, 2, 3};
std::vector&lt;int&gt; vec2;
vec2.assign(vec1.begin(), vec1.end());  // vec2 变为 {1, 2, 3}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdarray"><a class="header" href="#stdarray">std::array</a></h1>
<p><code>std::array</code> 是一个封装了<strong>固定大小</strong>数组的容器。它将 C 风格数组的性能和内存布局与标准容器的优点结合起来，例如能够知道自己的大小、支持赋值和随机访问迭代器等。<code>std::array</code> 的大小是模板参数的一部分，在<strong>编译时</strong>固定，因此它不支持动态大小的调整（如插入或删除元素）。</p>
<h2 id="1-引入-5"><a class="header" href="#1-引入-5">1. 引入</a></h2>
<pre><code class="language-c++">#include &lt;array&gt;
</code></pre>
<h2 id="2-存储方式-2"><a class="header" href="#2-存储方式-2">2. 存储方式</a></h2>
<p><code>std::array</code> 是一个<strong>固定大小</strong>的顺序容器，其元素是存储在<strong>连续内存</strong>中的，在栈中存储。它的内存布局与 C 风格数组 <code>T[N]</code> 完全相同，并且不包含任何额外的开销（例如，不需要存储大小）。</p>
<ul>
<li><strong>固定大小：</strong> 数组的大小 <code>N</code> 是一个模板参数，在编译时确定，不能在运行时改变。</li>
<li><strong>连续存储：</strong> 元素在内存中是连续存放的，这使得 <code>std::array</code> 支持高效的<strong>随机访问</strong>（通过索引 \(O(1)\) 时间复杂度）和迭代器操作。</li>
<li><strong>无数据成员开销：</strong> 数组本身不存储除了元素之外的任何数据（例如，不需要存储大小），因此它的空间效率与 C 风格数组相同。</li>
</ul>
<p>由于大小固定，<code>std::array</code> 不支持诸如 <code>push_back</code>、<code>pop_back</code> 或 <code>insert</code>、<code>erase</code> 等会改变容器大小的操作。</p>
<h2 id="3-方法-2"><a class="header" href="#3-方法-2">3. 方法</a></h2>
<p><code>std::array</code> 的许多操作都是隐式定义的，因为它是一个聚合类型（Aggregate Type），遵循 C 风格数组的初始化和复制规则。</p>
<h3 id="1-构造方法"><a class="header" href="#1-构造方法">(1) 构造方法</a></h3>
<p><code>std::array</code> 是一个聚合类型，因此它使用<strong>聚合初始化</strong>（Aggregate Initialization）规则：</p>
<ol>
<li>
<p><strong>默认构造</strong>：</p>
<pre><code class="language-c++">std::array&lt;int, 5&gt; arr; // 包含 5 个 int 元素，默认初始化（对于基本类型，值可能是不确定的）
</code></pre>
</li>
<li>
<p><strong>列表初始化/聚合初始化</strong>：</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr1 = {1, 2, 3}; // 包含 3 个元素，值为 1, 2, 3
std::array&lt;int, 5&gt; arr2 = {1, 2};   // 包含 5 个元素，前两个为 1, 2，其余为 0 (零初始化)
</code></pre>
</li>
<li>
<p><strong>复制/移动构造</strong>：</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr3 = {1, 2, 3};
std::array&lt;int, 3&gt; arr4(arr3); // 复制构造
</code></pre>
</li>
</ol>
<h3 id="2-大小函数"><a class="header" href="#2-大小函数">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>: 返回 <code>std::array</code> 中元素的个数（即模板参数 \(N\)）。</p>
<pre><code class="language-c++">std::array&lt;int, 4&gt; arr;
std::cout &lt;&lt; arr.size(); // 输出 4
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::array</code> 是否为空。由于 \(N\) 在编译时固定，对于 \(N &gt; 0\) 的数组总是返回 <code>false</code>。</p>
<pre><code class="language-c++">std::array&lt;int, 0&gt; arr0;
std::cout &lt;&lt; arr0.empty(); // 输出 true
std::array&lt;int, 5&gt; arr5;
std::cout &lt;&lt; arr5.empty(); // 输出 false
</code></pre>
</li>
<li>
<p><code>size_t max_size() const</code>: 返回容器可能包含的最大元素数，与 <code>size()</code> 相同。</p>
</li>
</ol>
<h3 id="3-元素访问"><a class="header" href="#3-元素访问">(3) 元素访问</a></h3>
<ol>
<li>
<p><code>reference at(size_type pos)</code>: 访问指定位置 <code>pos</code> 的元素，<strong>带边界检查</strong>。如果 <code>pos</code> 超出范围，则抛出 <code>std::out_of_range</code> 异常。</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr = {1, 2, 3};
std::cout &lt;&lt; arr.at(1); // 输出 2
// arr.at(5); // 运行时抛出异常
</code></pre>
</li>
<li>
<p><code>reference operator[](size_type pos)</code>: 访问指定位置 <code>pos</code> 的元素，<strong>不带边界检查</strong>。</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr = {1, 2, 3};
std::cout &lt;&lt; arr[1]; // 输出 2
// arr[5]; // 未定义行为
</code></pre>
</li>
<li>
<p><code>reference front()</code>: 访问<strong>第一个</strong>元素。</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr = {1, 2, 3};
std::cout &lt;&lt; arr.front(); // 输出 1
</code></pre>
</li>
<li>
<p><code>reference back()</code>: 访问<strong>最后一个</strong>元素。</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr = {1, 2, 3};
std::cout &lt;&lt; arr.back(); // 输出 3
</code></pre>
</li>
<li>
<p><code>T* data()</code>: 返回指向存储元素的首元素的<strong>底层 C 风格数组</strong>的指针。</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr = {1, 2, 3};
int* p = arr.data();
std::cout &lt;&lt; p[0]; // 输出 1
</code></pre>
</li>
<li>
<p><code>std::get&lt;I&gt;(array)</code>: 使用<strong>元组式接口</strong>访问第 \(I\) 个元素，<strong>编译时</strong>进行边界检查。</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr = {1, 2, 3};
std::cout &lt;&lt; std::get&lt;1&gt;(arr); // 输出 2
</code></pre>
</li>
</ol>
<h3 id="4-迭代器函数"><a class="header" href="#4-迭代器函数">(4) 迭代器函数</a></h3>
<p><code>std::array</code> 支持随机访问迭代器。</p>
<ol>
<li><code>iterator begin()</code> / <code>const_iterator cbegin()</code>: 返回指向<strong>第一个</strong>元素的迭代器。</li>
<li><code>iterator end()</code> / <code>const_iterator cend()</code>: 返回指向<strong>最后一个元素之后</strong>位置的迭代器。</li>
<li><code>reverse_iterator rbegin()</code> / <code>const_reverse_iterator crbegin()</code>: 返回指向<strong>最后一个</strong>元素的反向迭代器。</li>
<li><code>reverse_iterator rend()</code> / <code>const_reverse_iterator crend()</code>: 返回指向<strong>第一个元素之前</strong>位置的反向迭代器。</li>
</ol>
<h3 id="5-修改函数"><a class="header" href="#5-修改函数">(5) 修改函数</a></h3>
<p><code>std::array</code> 不支持改变大小的操作（如 <code>push_back</code>, <code>pop_back</code>, <code>insert</code>, <code>erase</code>）。</p>
<ol>
<li>
<p><code>void fill(const T&amp; value)</code>: 将所有元素的值设置为 <code>value</code>。</p>
<pre><code class="language-c++">std::array&lt;int, 5&gt; arr;
arr.fill(10); // arr 变为 {10, 10, 10, 10, 10}
</code></pre>
</li>
<li>
<p><code>void swap(array&amp; other)</code>: <strong>交换</strong>当前 <code>std::array</code> 和另一个大小、类型相同的 <code>std::array</code> 的内容。</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr1 = {1, 2, 3};
std::array&lt;int, 3&gt; arr2 = {4, 5, 6};
arr1.swap(arr2); // arr1 变为 {4, 5, 6}，arr2 变为 {1, 2, 3}
</code></pre>
</li>
</ol>
<h3 id="6-遍历函数"><a class="header" href="#6-遍历函数">(6) 遍历函数</a></h3>
<p>由于 <code>std::array</code> 提供了随机访问迭代器，因此可以使用多种方式遍历。</p>
<ol>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）：</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr = {1, 2, 3};
for (const int&amp; num : arr) {
    std::cout &lt;&lt; num &lt;&lt; " "; // 输出: 1 2 3
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）：</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr = {1, 2, 3};
for (auto it = arr.begin(); it != arr.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " "; // 输出: 1 2 3
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于索引）：</p>
<pre><code class="language-c++">std::array&lt;int, 3&gt; arr = {1, 2, 3};
for (size_t i = 0; i &lt; arr.size(); ++i) {
    std::cout &lt;&lt; arr[i] &lt;&lt; " "; // 输出: 1 2 3
}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdlist"><a class="header" href="#stdlist">std::list</a></h1>
<p>List 是一个支持在容器的任意位置快速插入和删除元素的一个顺序容器，支持存储各种类型的对象，链表在存储时不需要重新分配内存或是初始化时预留大小，对象存储在内存中的不连续位置，因此随机访问能力较差。</p>
<h2 id="1-引入-6"><a class="header" href="#1-引入-6">1. 引入</a></h2>
<pre><code class="language-C++">#include &lt;list&gt;
</code></pre>
<h2 id="2-存储方式-3"><a class="header" href="#2-存储方式-3">2. 存储方式</a></h2>
<p>std::list 是基于双向链表实现的容器。与 std::vector 的连续内存不同，std::list 的元素存储在不连续的内存块中。每个元素由一个节点（节点中包含元素和指向前后元素的指针）组成，这些节点通过指针连接成一个链表。由于每个节点都是独立分配的，std::list 不需要连续的内存空间来存储元素。</p>
<p>在 std::list 中插入或删除元素时，由于元素是通过指针连接的，因此插入和删除操作通常是非常高效的。插入、删除操作不会影响链表中其他元素的存储位置。</p>
<p>然而，由于每个元素都需要额外的内存来存储指向前后元素的指针，所以相较于 std::vector，std::list 在存储上较为低效，且不支持快速随机访问。访问元素时，必须从链表的起始或终止节点开始，逐步沿着指针遍历到目标元素。</p>
<h2 id="3-方法-3"><a class="header" href="#3-方法-3">3. 方法</a></h2>
<h3 id="1-构造方法-1"><a class="header" href="#1-构造方法-1">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>list()</code>: 创建一个空的 <code>std::list</code>，默认构造函数。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst;
</code></pre>
</li>
<li>
<p><code>list(size_t nSize)</code>: 创建一个包含 <code>nSize</code> 个默认构造元素的 <code>std::list</code>。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst(10);  // 创建一个包含10个默认构造的元素的列表
</code></pre>
</li>
<li>
<p><code>list(size_t nSize, const T&amp; value)</code>: 创建一个包含 <code>nSize</code> 个元素，并且所有元素的值为 <code>value</code> 的 <code>std::list</code>。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst(10, 5);  // 创建一个包含10个元素，值都为5的列表
</code></pre>
</li>
<li>
<p><code>list(const list&amp;)</code>: 复制构造函数，创建一个与另一个 <code>std::list</code> 完全相同的副本。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst1 = {1, 2, 3, 4, 5};
std::list&lt;int&gt; lst2(lst1);  // lst2 是 lst1 的一个复制版本
</code></pre>
</li>
<li>
<p><code>list(begin, end)</code>: 使用另一个容器或迭代器区间中的元素初始化 <code>std::list</code>。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::list&lt;int&gt; lst(vec.begin(), vec.end());  // 复制 vector 的元素到 list
</code></pre>
</li>
</ol>
<h3 id="2-大小函数-1"><a class="header" href="#2-大小函数-1">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>: 返回 <code>std::list</code> 中元素的个数。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3, 4};
std::cout &lt;&lt; lst.size();  // 输出 4
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::list</code> 是否为空，若为空返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst;
if (lst.empty()) {
    std::cout &lt;&lt; "List is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>void resize(size_t size)</code>: 调整 <code>std::list</code> 的大小。若新大小大于当前大小，<code>std::list</code> 会插入默认值的元素；若小于当前大小，则会删除多余的元素。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3};
lst.resize(5, 10);  // 增加两个元素，元素值为 10
</code></pre>
</li>
</ol>
<h3 id="3-增加函数-1"><a class="header" href="#3-增加函数-1">(3) 增加函数</a></h3>
<ol>
<li>
<p><code>push_back(const T&amp; value)</code>: 将元素 <code>value</code> 添加到 <code>std::list</code> 的末尾。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3};
lst.push_back(4);  // 向 lst 中添加元素 4，lst 变为 {1, 2, 3, 4}
</code></pre>
</li>
<li>
<p><code>push_front(const T&amp; value)</code>: 将元素 <code>value</code> 添加到 <code>std::list</code> 的开头。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {2, 3, 4};
lst.push_front(1);  // 向 lst 中添加元素 1，lst 变为 {1, 2, 3, 4}
</code></pre>
</li>
<li>
<p><code>emplace_back(Args&amp;&amp;... args)</code>: 在 <code>std::list</code> 的末尾就地构造一个元素，使用提供的参数直接构造该元素。</p>
<pre><code class="language-c++">std::list&lt;std::pair&lt;int, int&gt;&gt; lst;
lst.emplace_back(1, 2);  // 在末尾构造一个 pair&lt;int, int&gt;，值为 {1, 2}
</code></pre>
</li>
<li>
<p><code>emplace_front(Args&amp;&amp;... args)</code>: 在 <code>std::list</code> 的前端就地构造一个元素。</p>
<pre><code class="language-c++">std::list&lt;std::pair&lt;int, int&gt;&gt; lst;
lst.emplace_front(1, 2);  // 在前端构造一个 pair&lt;int, int&gt;，值为 {1, 2}
</code></pre>
</li>
<li>
<p><code>insert(iterator pos, const T&amp; value)</code>: 在指定位置 <code>pos</code> 插入元素 <code>value</code>，插入操作会将 <code>pos</code> 后面的元素向后移动。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 4, 5};
lst.insert(std::next(lst.begin(), 2), 3);  // 在位置2插入3，lst 变为 {1, 2, 3, 4, 5}
</code></pre>
</li>
<li>
<p><code>insert(iterator pos, size_t count, const T&amp; value)</code>: 在指定位置 <code>pos</code> 插入 <code>count</code> 个元素，所有的元素值为 <code>value</code>。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 4, 5};
lst.insert(std::next(lst.begin(), 2), 2, 3);  // 在位置2插入两个3，lst 变为 {1, 2, 3, 3, 4, 5}
</code></pre>
</li>
<li>
<p><code>insert(iterator pos, InputIterator first, InputIterator last)</code>: 将 <code>[first, last)</code> 区间的元素插入到指定位置 <code>pos</code>。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst1 = {1, 2, 3};
std::list&lt;int&gt; lst2 = {4, 5};
lst1.insert(std::next(lst1.begin(), 2), lst2.begin(), lst2.end());  // 在位置2插入 lst2 中的元素，lst1 变为 {1, 2, 4, 5, 3}
</code></pre>
</li>
</ol>
<h3 id="4-删除函数-1"><a class="header" href="#4-删除函数-1">(4) 删除函数</a></h3>
<ol>
<li>
<p><code>pop_back()</code>: 删除 <code>std::list</code> 中的最后一个元素。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3, 4};
lst.pop_back();  // 删除最后一个元素，lst 变为 {1, 2, 3}
</code></pre>
</li>
<li>
<p><code>pop_front()</code>: 删除 <code>std::list</code> 中的第一个元素。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3, 4};
lst.pop_front();  // 删除第一个元素，lst 变为 {2, 3, 4}
</code></pre>
</li>
<li>
<p><code>erase(iterator pos)</code>: 删除指定位置 <code>pos</code> 处的元素，删除操作后，<code>pos</code> 后面的元素会向前移动。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3, 4};
lst.erase(std::next(lst.begin(), 2));  // 删除索引为2的元素，lst 变为 {1, 2, 4}
</code></pre>
</li>
<li>
<p><code>erase(iterator first, iterator last)</code>: 删除区间 <code>[first, last)</code> 内的所有元素。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3, 4, 5};
lst.erase(std::next(lst.begin(), 1), std::next(lst.begin(), 4));  // 删除从索引1到3的元素，lst 变为 {1, 5}
</code></pre>
</li>
<li>
<p><code>clear()</code>: 删除 <code>std::list</code> 中的所有元素，使容器变为空。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3, 4};
lst.clear();  // 删除所有元素，lst 变为空 {}
</code></pre>
</li>
<li>
<p><code>void remove(const T&amp; val)</code>: <code>remove</code> 函数用于删除链表中所有等于指定值 <code>val</code> 的元素。它会遍历整个链表，删除所有匹配的元素。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3, 4, 3, 5};
lst.remove(3);  // 删除所有值为3的元素，lst 变为 {1, 2, 4, 5}
</code></pre>
</li>
<li>
<p><code>void remove_if (bool (*pred)(const T&amp;));</code>: pred: 一个谓词（通常是一个函数或函数对象），用于判断元素是否满足删除条件。pred 返回 true 表示删除该元素，返回 false 表示保留该元素。用于删除满足特定条件的所有元素。与 remove 不同的是，remove_if 允许你使用自定义的条件来判断哪些元素需要被删除。</p>
<p>remove_if 会遍历整个容器，将所有满足谓词 pred 条件的元素移到容器的末尾，并返回一个指向容器中第一个不满足条件的元素的迭代器。然后可以使用 erase 来删除这些元素。</p>
<p>需要注意的是，remove_if 并不会实际删除元素，它只是将符合条件的元素移动到容器的末尾，删除操作需要通过 erase 来完成。</p>
<p>假设我们有一个 std::list，并希望删除所有大于 3 的元素：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;  // 包含 std::remove_if

bool greater_than_three(int n) {
    return n &gt; 3;  // 条件：删除大于3的元素
}

int main() {
    std::list&lt;int&gt; lst = {1, 2, 3, 4, 5, 6};

    // 使用 remove_if 删除大于 3 的元素
    lst.remove_if(greater_than_three);

    // 输出结果
    for (int n : lst) {
        std::cout &lt;&lt; n &lt;&lt; " ";  // 输出: 1 2 3
    }

    return 0;
}
</code></pre>
<p>也可以使用 lambda 表达式作为谓词：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;

int main() {
    std::list&lt;int&gt; lst = {1, 2, 3, 4, 5, 6};

    // 使用 lambda 表达式删除大于 3 的元素
    lst.remove_if([](int n) { return n &gt; 3; });

    // 输出结果
    for (int n : lst) {
        std::cout &lt;&lt; n &lt;&lt; " ";  // 输出: 1 2 3
    }

    return 0;
}
</code></pre>
</li>
</ol>
<h3 id="5-遍历函数"><a class="header" href="#5-遍历函数">(5) 遍历函数</a></h3>
<ol>
<li>
<p><code>iterator begin()</code>: 返回指向 <code>std::list</code> 第一个元素的迭代器。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3};
std::list&lt;int&gt;::iterator it = lst.begin();  // 返回指向第一个元素的迭代器
std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 1
</code></pre>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 <code>std::list</code> 最后一个元素之后位置的迭代器。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3};
std::list&lt;int&gt;::iterator it = lst.end();  // 返回指向最后一个元素之后位置的迭代器
--it;  // 移动到最后一个元素
std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 3
</code></pre>
</li>
<li>
<p><code>reverse_iterator rbegin()</code>: 返回指向 <code>std::list</code> 最后一个元素的反向迭代器。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3};
std::list&lt;int&gt;::reverse_iterator rit = lst.rbegin();  // 返回指向最后一个元素的反向迭代器
std::cout &lt;&lt; *rit &lt;&lt; std::endl;  // 输出: 3
</code></pre>
</li>
<li>
<p><code>reverse_iterator rend()</code>: 返回指向 <code>std::list</code> 第一个元素之前位置的反向迭代器。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3};
std::list&lt;int&gt;::reverse_iterator rit = lst.rend();  // 返回指向第一个元素之前位置的反向迭代器
++rit;  // 移动到第一个元素
std::cout &lt;&lt; *rit &lt;&lt; std::endl;  // 输出: 1
</code></pre>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 直接遍历 <code>std::list</code> 中的每个元素。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3};
for (const int&amp; num : lst) {
    std::cout &lt;&lt; num &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）: 使用迭代器来遍历 <code>std::list</code>。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3};
for (auto it = lst.begin(); it != lst.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
</ol>
<h3 id="6-其他函数"><a class="header" href="#6-其他函数">(6) 其他函数</a></h3>
<ol>
<li>
<p><code>swap(list&amp; other)</code>: 交换当前 <code>std::list</code> 和另一个 <code>std::list</code> 的内容。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst1 = {1, 2, 3};
std::list&lt;int&gt; lst2 = {4, 5, 6};
lst1.swap(lst2);  // lst1 变为 {4, 5, 6}，lst2 变为 {1, 2, 3}
</code></pre>
</li>
<li>
<p><code>assign(size_t count, const T&amp; value)</code>: 将 <code>count</code> 个 <code>value</code> 元素赋值给当前 <code>std::list</code>，替换原有内容。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst;
lst.assign(5, 10);  // 将 lst 赋值为 {10, 10, 10, 10, 10}
</code></pre>
</li>
<li>
<p><code>assign(InputIterator first, InputIterator last)</code>: 使用区间 <code>[first, last)</code> 的元素来填充当前 <code>std::list</code>，替换原有内容。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst1 = {1, 2, 3};
std::list&lt;int&gt; lst2;
lst2.assign(lst1.begin(), lst1.end());  // lst2 变为 {1, 2, 3}
</code></pre>
</li>
<li>
<p><code>void sort()</code>: <code>sort</code> 函数用于对链表中的元素进行排序。默认情况下，它会按照元素的升序排列。如果需要按降序排序，可以提供自定义比较函数。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {5, 3, 4, 1, 2};
lst.sort();  // 按升序排序，lst 变为 {1, 2, 3, 4, 5}
</code></pre>
<p>如果要进行降序排序，可以使用自定义的比较函数：</p>
<pre><code class="language-c++">lst.sort(std::greater&lt;int&gt;());  // 按降序排序，lst 变为 {5, 4, 3, 2, 1}
</code></pre>
</li>
<li>
<p><code>void merge(list&amp; other)</code>: <code>merge</code> 函数用于将另一个已排序的链表 <code>other</code> 合并到当前链表中。合并后的链表仍然是有序的。注意，<code>merge</code> 函数要求两个链表必须是排序过的，否则结果无法保证是有序的。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst1 = {1, 3, 5};
std::list&lt;int&gt; lst2 = {2, 4, 6};
lst1.merge(lst2);  // lst1 合并 lst2 后，变为 {1, 2, 3, 4, 5, 6}
</code></pre>
</li>
<li>
<p><code>void reverse()</code>: <code>reverse</code> 函数用于将链表中的元素反转。它会改变链表中元素的顺序。</p>
<pre><code class="language-c++">std::list&lt;int&gt; lst = {1, 2, 3, 4, 5};
lst.reverse();  // 反转链表，lst 变为 {5, 4, 3, 2, 1}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdforward_list"><a class="header" href="#stdforward_list">std::forward_list</a></h1>
<p><code>std::forward_list</code> 是一个支持在容器的任意位置快速插入和删除元素的顺序容器。它是一个<strong>单向链表</strong>（singly-linked list）实现，因此它<strong>只支持向前遍历</strong>。相比于 <code>std::list</code>，它不存储指向前一个节点的指针，从而提供更节省空间的存储方式，但代价是失去了双向迭代的能力以及快速获取 <code>size()</code> 的能力。</p>
<h2 id="1-引入-7"><a class="header" href="#1-引入-7">1. 引入</a></h2>
<pre><code class="language-c++">#include &lt;forward_list&gt;
</code></pre>
<h2 id="2-存储方式-4"><a class="header" href="#2-存储方式-4">2. 存储方式</a></h2>
<p><code>std::forward_list</code> 是基于<strong>单向链表</strong>实现的容器。它的元素存储在内存中的不连续位置，每个元素由一个节点（包含元素和指向<strong>下一个</strong>元素的指针）组成。</p>
<ul>
<li><strong>单向连接：</strong> 每个节点只知道其后继节点，因此只能从头到尾单向遍历。</li>
<li><strong>高效的插入和删除：</strong> 与 <code>std::list</code> 类似，在任意位置插入和删除元素的时间复杂度为 \(O(1)\)，但操作通常需要一个指向<strong>目标位置之前</strong>元素的迭代器。</li>
<li><strong>空间优化：</strong> 由于每个元素只存储一个指针（指向下一个元素），它比双向链表 <code>std::list</code> 更节省内存。</li>
<li><strong>不支持随机访问和 <code>size()</code>：</strong> 由于是单向链表，它不支持 \(O(1)\) 复杂度的随机访问（例如 <code>operator[]</code>），并且为了保持 \(O(1)\) 插入/删除的效率，它通常<strong>不提供</strong> <code>size()</code> 成员函数（除非是 C++20 引入的 <code>std::ssize</code> 全局函数）。</li>
</ul>
<h2 id="3-方法-4"><a class="header" href="#3-方法-4">3. 方法</a></h2>
<p>由于 <code>std::forward_list</code> 的单向特性，其插入和删除操作与 <code>std::list</code> 有显著区别：它<strong>没有</strong> <code>pop_back()</code>、<code>push_back()</code> 或 <code>back()</code>，并且 <strong><code>insert</code> 和 <code>erase</code> 操作是在指定位置的</strong>后方<strong>进行。</strong></p>
<h3 id="1-构造方法-2"><a class="header" href="#1-构造方法-2">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>forward_list()</code>: 创建一个空的 <code>std::forward_list</code>，默认构造函数。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst;
</code></pre>
</li>
<li>
<p><code>forward_list(size_t nSize)</code>: 创建一个包含 <code>nSize</code> 个默认构造元素的 <code>std::forward_list</code>。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst(10);  // 创建一个包含10个默认构造的元素的列表
</code></pre>
</li>
<li>
<p><code>forward_list(size_t nSize, const T&amp; value)</code>: 创建一个包含 <code>nSize</code> 个元素，并且所有元素的值为 <code>value</code> 的 <code>std::forward_list</code>。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst(10, 5);  // 创建一个包含10个元素，值都为5的列表
</code></pre>
</li>
<li>
<p><code>forward_list(const forward_list&amp;)</code>: 复制构造函数，创建一个与另一个 <code>std::forward_list</code> 完全相同的副本。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst1 = {1, 2, 3};
std::forward_list&lt;int&gt; lst2(lst1);  // lst2 是 lst1 的一个复制版本
</code></pre>
</li>
<li>
<p><code>forward_list(begin, end)</code>: 使用另一个容器或迭代器区间中的元素初始化 <code>std::forward_list</code>。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3};
std::forward_list&lt;int&gt; lst(vec.begin(), vec.end());  // 复制 vector 的元素到 forward_list
</code></pre>
</li>
</ol>
<h3 id="2-大小函数-2"><a class="header" href="#2-大小函数-2">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::forward_list</code> 是否为空。若为空返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst;
if (lst.empty()) {
    std::cout &lt;&lt; "List is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>size_t max_size() const</code>: 返回容器可能包含的最大元素数。</p>
</li>
</ol>
<h3 id="3-增加函数-2"><a class="header" href="#3-增加函数-2">(3) 增加函数</a></h3>
<p><code>std::forward_list</code> 的所有插入操作都围绕<strong>前部</strong>或<strong>指定位置之后</strong>进行。</p>
<ol>
<li>
<p><code>push_front(const T&amp; value)</code>: 将元素 <code>value</code> 添加到 <code>std::forward_list</code> 的<strong>开头</strong>。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {2, 3, 4};
lst.push_front(1);  // lst 变为 {1, 2, 3, 4}
</code></pre>
</li>
<li>
<p><code>emplace_front(Args&amp;&amp;... args)</code>: 在 <code>std::forward_list</code> 的<strong>前端</strong>就地构造一个元素。</p>
<pre><code class="language-c++">std::forward_list&lt;std::pair&lt;int, int&gt;&gt; lst;
lst.emplace_front(1, 2);  // 在前端构造一个 pair&lt;int, int&gt;，值为 {1, 2}
</code></pre>
</li>
<li>
<p><code>insert_after(const_iterator pos, const T&amp; value)</code>: 在指定位置 <code>pos</code> 的<strong>后面</strong>插入元素 <code>value</code>。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 4, 5};
auto it = std::next(lst.begin()); // 指向元素 2
lst.insert_after(it, 3);          // 在 2 后面插入 3，lst 变为 {1, 2, 3, 4, 5}
</code></pre>
</li>
<li>
<p><code>insert_after(const_iterator pos, size_t count, const T&amp; value)</code>: 在指定位置 <code>pos</code> 的<strong>后面</strong>插入 <code>count</code> 个元素，所有元素值为 <code>value</code>。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 4, 5};
auto it = std::next(lst.begin());
lst.insert_after(it, 2, 3);  // 在 2 后面插入两个 3，lst 变为 {1, 2, 3, 3, 4, 5}
</code></pre>
</li>
<li>
<p><code>insert_after(const_iterator pos, InputIterator first, InputIterator last)</code>: 将 <code>[first, last)</code> 区间的元素插入到指定位置 <code>pos</code> 的<strong>后面</strong>。</p>
</li>
</ol>
<h3 id="4-删除函数-2"><a class="header" href="#4-删除函数-2">(4) 删除函数</a></h3>
<p><code>std::forward_list</code> 的所有删除操作都围绕<strong>前部</strong>或<strong>指定位置之后</strong>进行。</p>
<ol>
<li>
<p><code>pop_front()</code>: 删除 <code>std::forward_list</code> 中的<strong>第一个</strong>元素。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 3, 4};
lst.pop_front();  // 删除第一个元素，lst 变为 {2, 3, 4}
</code></pre>
</li>
<li>
<p><code>erase_after(const_iterator pos)</code>: 删除指定位置 <code>pos</code> <strong>后面</strong>的元素。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 3, 4};
auto it = lst.begin(); // 指向元素 1
lst.erase_after(it);   // 删除 1 后面的元素 2，lst 变为 {1, 3, 4}
</code></pre>
</li>
<li>
<p><code>erase_after(const_iterator first, const_iterator last)</code>: 删除区间 <code>(first, last)</code> 内的所有元素。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 3, 4, 5};
auto it1 = lst.begin(); // 指向 1
auto it2 = std::next(it1, 3); // 指向 4
lst.erase_after(it1, it2); // 删除 1 后面直到 4 之前的所有元素 {2, 3}，lst 变为 {1, 4, 5}
</code></pre>
</li>
<li>
<p><code>clear()</code>: 删除 <code>std::forward_list</code> 中的所有元素，使容器变为空。</p>
</li>
<li>
<p><code>void remove(const T&amp; val)</code>: 删除链表中所有等于指定值 <code>val</code> 的元素。</p>
</li>
<li>
<p><code>void remove_if (bool (*pred)(const T&amp;))</code>: 删除满足谓词 <code>pred</code> 条件的所有元素。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 3, 4, 5};
lst.remove_if([](int n) { return n % 2 == 0; }); // 删除偶数，lst 变为 {1, 3, 5}
</code></pre>
</li>
</ol>
<h3 id="5-遍历函数-1"><a class="header" href="#5-遍历函数-1">(5) 遍历函数</a></h3>
<p><code>std::forward_list</code> <strong>只支持前向迭代器</strong>。它提供了一个特殊的迭代器 <code>before_begin()</code> 用于方便地在链表头部之前进行插入/删除操作。</p>
<ol>
<li>
<p><code>const_iterator before_begin()</code>: 返回指向<strong>链表第一个元素之前</strong>位置的特殊迭代器。用于配合 <code>insert_after</code> 或 <code>erase_after</code> 在链表头部操作。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 3};
// 在链表头部插入元素 0
lst.insert_after(lst.before_begin(), 0); // lst 变为 {0, 1, 2, 3}
</code></pre>
</li>
<li>
<p><code>iterator begin()</code>: 返回指向 <code>std::forward_list</code> <strong>第一个</strong>元素的迭代器。</p>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 <code>std::forward_list</code> <strong>最后一个元素之后</strong>位置的迭代器。</p>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）:</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 3};
for (const int&amp; num : lst) {
    std::cout &lt;&lt; num &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
</ol>
<h3 id="6-其他函数-1"><a class="header" href="#6-其他函数-1">(6) 其他函数</a></h3>
<ol>
<li>
<p><code>swap(forward_list&amp; other)</code>: 交换当前 <code>std::forward_list</code> 和另一个 <code>std::forward_list</code> 的内容。</p>
</li>
<li>
<p><code>assign(size_t count, const T&amp; value)</code>: 将 <code>count</code> 个 <code>value</code> 元素赋值给当前 <code>std::forward_list</code>，替换原有内容。</p>
</li>
<li>
<p><code>assign(InputIterator first, InputIterator last)</code>: 使用区间 <code>[first, last)</code> 的元素来填充当前 <code>std::forward_list</code>，替换原有内容。</p>
</li>
<li>
<p><code>void sort()</code>: 对链表中的元素进行排序。默认升序。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {5, 3, 4, 1, 2};
lst.sort();  // 按升序排序，lst 变为 {1, 2, 3, 4, 5}
</code></pre>
</li>
<li>
<p><code>void merge(forward_list&amp; other)</code>: 将另一个已排序的链表 <code>other</code> 合并到当前链表中。要求两个链表都已排序。</p>
</li>
<li>
<p><code>void reverse()</code>: 将链表中的元素<strong>反转</strong>。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 3};
lst.reverse();  // 反转链表，lst 变为 {3, 2, 1}
</code></pre>
</li>
<li>
<p><code>void unique()</code>: 删除链表中所有<strong>连续重复</strong>的元素。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst = {1, 2, 2, 3, 3, 3, 4};
lst.unique(); // lst 变为 {1, 2, 3, 4}
</code></pre>
</li>
<li>
<p><code>void splice_after(const_iterator pos, forward_list&amp; other)</code>: 将 <code>other</code> 中的所有元素移动到当前列表 <code>*this</code> 中，放在 <code>pos</code> <strong>之后</strong>。<code>other</code> 变为<strong>空</strong>。</p>
<pre><code class="language-c++">std::forward_list&lt;int&gt; lst1 = {1, 4};
std::forward_list&lt;int&gt; lst2 = {2, 3};
lst1.splice_after(lst1.begin(), lst2); // lst1 变为 {1, 2, 3, 4}，lst2 变为空 {}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stddeque"><a class="header" href="#stddeque">std::deque</a></h1>
<p><code>std::deque</code>（双端队列）是一个支持在两端快速插入和删除元素的顺序容器。与 <code>std::vector</code> 不同，<code>std::deque</code> 在内存中采用分段连续的存储方式，即它的元素分布在多个不连续的内存块中，这些内存块通过指针数组进行管理。由于这一内存布局，<code>std::deque</code> 可以在头尾两端高效地进行插入和删除操作，并且支持随机访问(可以使用<code>operator[]</code>)。尽管如此，它的随机访问性能较 <code>std::vector</code> 差一些，因为每个内存块并不连续。</p>
<p><code>std::deque</code> 不需要像 <code>std::vector</code> 一样每次扩展时重新分配整个内存空间，而是通过扩展指向内存块的指针数组来增加容量。这使得它在动态变化的场景中，尤其是在需要频繁在两端插入和删除元素时，表现得尤为高效。</p>
<h2 id="1-引入-8"><a class="header" href="#1-引入-8">1. 引入</a></h2>
<pre><code class="language-C++">#include &lt;deque&gt;
</code></pre>
<h2 id="2-存储方式-5"><a class="header" href="#2-存储方式-5">2. 存储方式</a></h2>
<p>std::deque 是双端队列，支持在两端进行高效的插入和删除。为了实现这一点，std::deque 使用的是一种分段连续的内存结构。它的内存布局由多个固定大小的内存块（即“段”）组成，每个块内的元素是连续存储的，但这些块在内存中并不连续。通过维护一个指向这些块的指针数组，std::deque 可以实现高效的两端插入和删除操作。</p>
<p>当 std::deque 容量不足时，它会动态扩展新的内存块，并在原有的内存块之间插入新的块。这样，由于每个块都是独立分配的，std::deque 既能保证高效的插入和删除操作，又能提供支持随机访问的能力（虽然随机访问性能不如 std::vector）。</p>
<p>与 std::vector 不同的是，std::deque 不需要一次性重新分配整个内存空间，它只是扩展指向内存块的指针数组。这样，std::deque 可以高效地在头尾进行扩展，并且仍然保持较好的访问性能。</p>
<h3 id="3-方法-5"><a class="header" href="#3-方法-5">3. 方法</a></h3>
<h3 id="1-构造方法-3"><a class="header" href="#1-构造方法-3">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>deque()</code>: 创建一个空的 <code>std::deque</code>。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq;
</code></pre>
</li>
<li>
<p><code>deque(size_t nSize)</code>: 创建一个包含 <code>nSize</code> 个默认构造元素的 <code>std::deque</code>。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq(10);  // 创建一个包含10个默认构造元素的 deque
</code></pre>
</li>
<li>
<p><code>deque(size_t nSize, const T&amp; value)</code>: 创建一个包含 <code>nSize</code> 个元素，且每个元素的值为 <code>value</code> 的 <code>std::deque</code>。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq(10, 5);  // 创建一个包含10个元素，值都为5的 deque
</code></pre>
</li>
<li>
<p><code>deque(const deque&amp;)</code>: 复制构造函数，创建一个与另一个 <code>std::deque</code> 完全相同的副本。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq1 = {1, 2, 3, 4, 5};
std::deque&lt;int&gt; deq2(deq1);  // deq2 是 deq1 的一个复制版本
</code></pre>
</li>
<li>
<p><code>deque(begin, end)</code>: 使用另一个容器或迭代器区间中的元素初始化 <code>std::deque</code>。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::deque&lt;int&gt; deq(vec.begin(), vec.end());  // 复制 vector 的元素到 deque
</code></pre>
</li>
</ol>
<h3 id="2-大小函数-3"><a class="header" href="#2-大小函数-3">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>: 返回 <code>std::deque</code> 中元素的个数。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3, 4};
std::cout &lt;&lt; deq.size();  // 输出 4
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::deque</code> 是否为空，若为空返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq;
if (deq.empty()) {
    std::cout &lt;&lt; "Deque is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>void resize(size_t size)</code>: 调整 <code>std::deque</code> 的大小。若新大小大于当前大小，<code>std::deque</code> 会插入默认值的元素；若小于当前大小，则会删除多余的元素。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3};
deq.resize(5, 10);  // 增加两个元素，元素值为 10
</code></pre>
</li>
<li>
<p><code>void shrink_to_fit()</code>: 调整队列预留内存刚好适应当前的大小，节省内存</p>
</li>
<li>
<p><code>size_t max_size() const</code>: 返回最大可允许的vector元素数量值</p>
</li>
</ol>
<h3 id="3-增加函数-3"><a class="header" href="#3-增加函数-3">(3) 增加函数</a></h3>
<ol>
<li>
<p><code>push_back(const T&amp; value)</code>: 将元素 <code>value</code> 添加到 <code>std::deque</code> 的末尾。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3};
deq.push_back(4);  // 向 deq 中添加元素 4，deq 变为 {1, 2, 3, 4}
</code></pre>
</li>
<li>
<p><code>push_front(const T&amp; value)</code>: 将元素 <code>value</code> 添加到 <code>std::deque</code> 的开头。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {2, 3, 4};
deq.push_front(1);  // 向 deq 中添加元素 1，deq 变为 {1, 2, 3, 4}
</code></pre>
</li>
<li>
<p><code>emplace_back(Args&amp;&amp;... args)</code>: 在 <code>std::deque</code> 的末尾就地构造一个元素，使用提供的参数直接构造该元素。</p>
<pre><code class="language-c++">std::deque&lt;std::pair&lt;int, int&gt;&gt; deq;
deq.emplace_back(1, 2);  // 在末尾构造一个 pair&lt;int, int&gt;，值为 {1, 2}
</code></pre>
</li>
<li>
<p><code>emplace_front(Args&amp;&amp;... args)</code>: 在 <code>std::deque</code> 的前端就地构造一个元素。</p>
<pre><code class="language-c++">std::deque&lt;std::pair&lt;int, int&gt;&gt; deq;
deq.emplace_front(1, 2);  // 在前端构造一个 pair&lt;int, int&gt;，值为 {1, 2}
</code></pre>
</li>
<li>
<p><code>insert(iterator pos, const T&amp; value)</code>: 在指定位置 <code>pos</code> 插入元素 <code>value</code>，插入操作会将 <code>pos</code> 后面的元素向后移动。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 4, 5};
deq.insert(deq.begin() + 2, 3);  // 在位置2插入3，deq 变为 {1, 2, 3, 4, 5}
</code></pre>
</li>
<li>
<p><code>insert(iterator pos, size_t count, const T&amp; value)</code>: 在指定位置 <code>pos</code> 插入 <code>count</code> 个元素，所有的元素值为 <code>value</code>。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 4, 5};
deq.insert(deq.begin() + 2, 2, 3);  // 在位置2插入两个3，deq 变为 {1, 2, 3, 3, 4, 5}
</code></pre>
</li>
<li>
<p><code>insert(iterator pos, InputIterator first, InputIterator last)</code>: 将 <code>[first, last)</code> 区间的元素插入到指定位置 <code>pos</code>。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq1 = {1, 2, 3};
std::deque&lt;int&gt; deq2 = {4, 5};
deq1.insert(deq1.begin() + 2, deq2.begin(), deq2.end());  // 在位置2插入 deq2 中的元素，deq1 变为 {1, 2, 4, 5, 3}
</code></pre>
</li>
</ol>
<h3 id="4-删除函数-3"><a class="header" href="#4-删除函数-3">(4) 删除函数</a></h3>
<ol>
<li>
<p><code>pop_back()</code>: 删除 <code>std::deque</code> 中的最后一个元素。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3, 4};
deq.pop_back();  // 删除最后一个元素，deq 变为 {1, 2, 3}
</code></pre>
</li>
<li>
<p><code>pop_front()</code>: 删除 <code>std::deque</code> 中的第一个元素。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3, 4};
deq.pop_front();  // 删除第一个元素，deq 变为 {2, 3, 4}
</code></pre>
</li>
<li>
<p><code>erase(iterator pos)</code>: 删除指定位置 <code>pos</code> 处的元素，删除操作后，<code>pos</code> 后面的元素会向前移动。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3, 4};
deq.erase(deq.begin() + 2);  // 删除索引为2的元素，deq 变为 {1, 2, 4}
</code></pre>
</li>
<li>
<p><code>erase(iterator first, iterator last)</code>: 删除区间 <code>[first, last)</code> 内的所有元素。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3, 4, 5};
deq.erase(deq.begin() + 1, deq.begin() + 4);  // 删除从索引1到3的元素，deq 变为 {1, 5}
</code></pre>
</li>
<li>
<p><code>clear()</code>: 删除 <code>std::deque</code> 中的所有元素，使容器变为空。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3, 4};
deq.clear();  // 删除所有元素，deq 变为空 {}
</code></pre>
</li>
</ol>
<h3 id="5-遍历函数-2"><a class="header" href="#5-遍历函数-2">(5) 遍历函数</a></h3>
<ol>
<li>
<p><code>reference at(int pos)</code>: 同Vector, 返回 <code>pos</code> 位置元素的引用。与 <code>operator[]</code> 类似，但会检查边界，如果访问无效的位置会抛出 <code>std::out_of_range</code> 异常。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
int&amp; element = vec.at(2);  // 返回位置 2 处元素的引用，即值为 3
element = 10;  // 修改元素为 10
std::cout &lt;&lt; vec[2] &lt;&lt; std::endl;  // 输出: 10
</code></pre>
</li>
<li>
<p><code>iterator begin()</code>: 返回指向 <code>std::deque</code> 第一个元素的迭代器。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3};
std::deque&lt;int&gt;::iterator it = deq.begin();  // 返回指向第一个元素的迭代器
std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 1
</code></pre>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 <code>std::deque</code> 最后一个元素之后位置的迭代器。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3};
std::deque&lt;int&gt;::iterator it = deq.end();  // 返回指向最后一个元素之后位置的迭代器
--it;  // 移动到最后一个元素
std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 3
</code></pre>
</li>
<li>
<p><code>reverse_iterator rbegin()</code>: 返回指向 <code>std::deque</code> 最后一个元素的反向迭代器。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3};
std::deque&lt;int&gt;::reverse_iterator rit = deq.rbegin();  // 返回指向最后一个元素的反向迭代器
std::cout &lt;&lt; *rit &lt;&lt; std::endl;  // 输出: 3
</code></pre>
</li>
<li>
<p><code>reverse_iterator rend()</code>: 返回指向 <code>std::deque</code> 第一个元素之前位置的反向迭代器。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3};
std::deque&lt;int&gt;::reverse_iterator rit = deq.rend();  // 返回指向第一个元素之前位置的反向迭代器
++rit;  // 移动到第一个元素
std::cout &lt;&lt; *rit &lt;&lt; std::endl;  // 输出: 1
</code></pre>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 直接遍历 <code>std::deque</code> 中的每个元素。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3};
for (const int&amp; num : deq) {
    std::cout &lt;&lt; num &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）: 使用迭代器来遍历 <code>std::deque</code>。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq = {1, 2, 3};
for (auto it = deq.begin(); it != deq.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
</ol>
<h3 id="6-其他函数-2"><a class="header" href="#6-其他函数-2">(6) 其他函数</a></h3>
<ol>
<li>
<p><code>swap(deque&amp; other)</code>: 交换当前 <code>std::deque</code> 和另一个 <code>std::deque</code> 的内容。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq1 = {1, 2, 3};
std::deque&lt;int&gt; deq2 = {4, 5, 6};
deq1.swap(deq2);  // deq1 变为 {4, 5, 6}，deq2 变为 {1, 2, 3}
</code></pre>
</li>
<li>
<p><code>assign(size_t count, const T&amp; value)</code>: 将 <code>count</code> 个 <code>value</code> 元素赋值给当前 <code>std::deque</code>，替换原有内容。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq;
deq.assign(5, 10);  // 将 deq 赋值为 {10, 10, 10, 10, 10}
</code></pre>
</li>
<li>
<p><code>assign(InputIterator first, InputIterator last)</code>: 使用区间 <code>[first, last)</code> 的元素来填充当前 <code>std::deque</code>，替换原有内容。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; deq1 = {1, 2, 3};
std::deque&lt;int&gt; deq2;
deq2.assign(deq1.begin(), deq1.end());  // deq2 变为 {1, 2, 3}
</code></pre>
</li>
<li>
<p><code>std::allocator&lt;T&gt; get_allocator() const</code>: 返回容器所使用的分配器（allocator）。分配器负责容器内存的管理，包括内存的分配、释放等操作。在默认情况下，C++ 标准库容器使用 std::allocator 作为默认的分配器。通过调用 get_allocator()，你可以获取容器使用的分配器，并利用该分配器进行自定义内存操作，或者检查容器如何管理内存。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; vec;

    // 获取分配器
    std::allocator&lt;int&gt; alloc = vec.get_allocator();

    // 使用分配器进行内存分配
    int* p = alloc.allocate(5);  // 分配5个int元素的内存

    // 显示分配的内存地址
    std::cout &lt;&lt; "Allocated memory at: " &lt;&lt; p &lt;&lt; std::endl;

    // 记得释放分配的内存
    alloc.deallocate(p, 5);  // 释放之前分配的5个int内存

    return 0;
}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdset"><a class="header" href="#stdset">std::set</a></h1>
<p><code>std::set</code> 是一个排序的关联容器，它存储唯一的元素，并根据元素的顺序进行自动排序。与 <code>std::list</code> 不同，<code>std::set</code> 提供了对元素的高效查找、插入和删除操作，但不支持直接的索引访问。其底层通常是基于平衡二叉树实现（红黑树），因此在查找、插入和删除操作上的时间复杂度通常为 O(log n)。</p>
<h2 id="1-引入-9"><a class="header" href="#1-引入-9">1. 引入</a></h2>
<pre><code class="language-C++">#include &lt;set&gt;
</code></pre>
<h2 id="2-存储方式-6"><a class="header" href="#2-存储方式-6">2. 存储方式</a></h2>
<p><code>std::set</code> 是基于平衡二叉树（通常是红黑树）实现的容器。与 <code>std::list</code> 和 <code>std::vector</code> 不同，<code>std::set</code> 具有自动排序的特性，元素会按升序（默认情况下）进行排列。每个元素都是唯一的，无法存储重复的元素。</p>
<p>在 <code>std::set</code> 中，元素会以节点的形式存储，每个节点包含一个元素以及指向父节点、左子节点和右子节点的指针。通过这种方式，<code>std::set</code> 保证了所有元素的排序特性，并支持高效的查找、插入和删除操作。</p>
<ul>
<li><strong>插入</strong>：由于元素在插入时会自动排序并且不允许重复，插入一个新元素的时间复杂度为 O(log n)，这也保证了元素始终保持有序。</li>
<li><strong>查找</strong>：在 <code>std::set</code> 中查找元素的时间复杂度为 O(log n)，这是因为它依赖于平衡二叉树的结构。</li>
<li><strong>删除</strong>：删除操作也有 O(log n) 的时间复杂度，因为删除节点时需要保持树的平衡。</li>
</ul>
<p>与 <code>std::vector</code> 和 <code>std::list</code> 不同，<code>std::set</code> 的元素是按照某种顺序排列的，因此它支持基于顺序的迭代。由于不允许重复元素，<code>std::set</code> 会自动忽略重复的插入请求。</p>
<p>尽管 <code>std::set</code> 提供了很高效的插入、删除和查找操作，但它并不支持快速的随机访问。要访问集合中的某个元素，必须按顺序遍历元素，无法通过索引直接访问。</p>
<h2 id="3-方法-6"><a class="header" href="#3-方法-6">3. 方法</a></h2>
<h3 id="1构造方法-2"><a class="header" href="#1构造方法-2">(1)构造方法</a></h3>
<ol>
<li>
<p><code>set()</code>: 创建一个空的 <code>std::set</code>，默认构造函数。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s;
std::set&lt;int&gt; s = {1, 2, 3, 4, 5};
std::set&lt;int&gt; s{1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p><code>set(const set&amp;)</code>: 复制构造函数，创建一个与另一个 <code>std::set</code> 完全相同的副本。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s1 = {1, 2, 3, 4, 5};
std::set&lt;int&gt; s2(s1);  // s2 是 s1 的一个复制版本
std::set&lt;int&gt; s3(std::move(s3));  // 移动构造（s3 变为有效但未指定状态，移除所有权）
</code></pre>
</li>
<li>
<p><code>set(begin, end)</code>: 使用另一个容器或迭代器区间中的元素初始化 <code>std::set</code>。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::set&lt;int&gt; s(vec.begin(), vec.end());  // 复制 vector 的元素到 set
</code></pre>
</li>
<li>
<p><code>std::set&lt;T&amp;, std::greater&lt;T&amp;&gt;&gt;</code>: 按照降序创建set</p>
</li>
</ol>
<h3 id="2大小函数-1"><a class="header" href="#2大小函数-1">(2)大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>: 返回 <code>std::set</code> 中元素的个数。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s = {1, 2, 3, 4};
std::cout &lt;&lt; s.size();  // 输出 4
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::set</code> 是否为空，若为空返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s;
if (s.empty()) {
    std::cout &lt;&lt; "Set is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>size_t max_size() const</code>: 返回最大可允许的set元素数量值</p>
</li>
</ol>
<h3 id="3增加函数"><a class="header" href="#3增加函数">(3)增加函数</a></h3>
<ol>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert(const T&amp; value)</code>: 插入元素到set中，返回一个pair，其first是指向插入元素所在位置的迭代器，其second是插入是否成功(存在重复元素几插入失败)</p>
<pre><code class="language-c++">s.insert({1,2,3});                     // initializer_list
s.insert(s.begin(), 42);               // 带 hint 的插入
s.insert(vec.begin(), vec.end());      // 区间插入
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; emplace(_Args&amp;&amp;... __args)</code>: 就地构建并插入元素</p>
</li>
<li>
<p><code>iterator emplace_hint(const_iterator __pos, _Args&amp;&amp;... __args)</code>: 就地构建并插入元素，且指定插入位置，但是如果指定位置错误会发生重排序，最坏情况下可能会降低插入的效率</p>
</li>
</ol>
<h3 id="4删除元素"><a class="header" href="#4删除元素">(4)删除元素</a></h3>
<ol>
<li>
<p><code>void clear()</code>: 删除 <code>std::set</code> 中的所有元素，使容器变为空。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s = {1, 2, 3, 4};
s.clear();  // 删除所有元素，s 变为空 {}
</code></pre>
</li>
<li>
<p><code>void erase(iterator pos)</code>: 删除指定位置 <code>pos</code> 处的元素</p>
<pre><code class="language-c++">std::set&lt;int&gt; s = {1, 2, 3, 4};
s.erase(std::next(s.begin(), 2));  // 删除索引为2的元素，lst 变为 {1, 2, 4}
</code></pre>
</li>
<li>
<p><code>size_t erase(const key_type&amp; key)</code>: 删除指定键，返回删除个数。</p>
</li>
<li>
<p><code>erase(first, last)</code>: 删除迭代器区间。</p>
</li>
</ol>
<h3 id="5查找函数"><a class="header" href="#5查找函数">(5)查找函数</a></h3>
<ol>
<li>
<p><code>iterator find(const T&amp; value)</code>: 查找某元素在set中的位置，返回一个指向该元素的迭代器，如果找不到会返回end()</p>
</li>
<li>
<p><code>std::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; __x) const</code>: 返回一对迭代器，表示所有具有等于k的键的元素的范围。由于set包含唯一元素，因此下界将是元素本身，上限将指向键k之后的下一个元素。如果没有与键K匹配的元素，则根据容器的内部比较对象(key_comp)，返回的范围的长度为0，两个迭代器均指向大于k的第一个元素。如果键超过了set容器中的最大元素，它将返回一个指向set容器中最后一个元素的迭代器。</p>
<pre><code class="language-c++">    std::set&lt;int&gt; s = {1, 2, 3, 4};
    std::pair p = s.equal_range(2);
    std::cout&lt;&lt;*p.first&lt;&lt;std::endl; // 输出2
    std::cout&lt;&lt;*p.second&lt;&lt;std::endl;// 输出3
</code></pre>
</li>
<li>
<p><code>size_t count(const T&amp; value)</code>: 返回是否存在（0 或 1）。</p>
</li>
<li>
<p><code>iterator lower_bound(const T&amp; value)</code>: 返回第一个不小于 value 的迭代器。</p>
</li>
<li>
<p><code>iterator upper_bound(const T&amp; value)</code>: 返回第一个大于 value 的迭代器。</p>
</li>
<li>
<p><code>bool contains(const T&amp; value) const</code>（C++20）: 检查是否包含元素。</p>
</li>
</ol>
<h3 id="6遍历函数"><a class="header" href="#6遍历函数">(6)遍历函数</a></h3>
<ol>
<li>
<p><code>iterator begin()</code>: 返回指向 <code>std::set</code> 第一个元素的迭代器。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s = {1, 2, 3};
std::set&lt;int&gt;::iterator it = s.begin();  // 返回指向第一个元素的迭代器
std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 1
</code></pre>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 <code>std::set</code> 最后一个元素之后位置的迭代器。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s = {1, 2, 3};
std::set&lt;int&gt;::iterator it = s.end();  // 返回指向最后一个元素之后位置的迭代器
--it;  // 移动到最后一个元素
std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 3
</code></pre>
</li>
<li>
<p><code>reverse_iterator rbegin()</code>: 返回指向 <code>std::set</code> 最后一个元素的反向迭代器。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s = {1, 2, 3};
std::set&lt;int&gt;::reverse_iterator rit = s.rbegin();  // 返回指向最后一个元素的反向迭代器
std::cout &lt;&lt; *rit &lt;&lt; std::endl;  // 输出: 3
</code></pre>
</li>
<li>
<p><code>reverse_iterator rend()</code>: 返回指向 <code>std::set</code> 第一个元素之前位置的反向迭代器。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s = {1, 2, 3};
std::set&lt;int&gt;::reverse_iterator rit = s.rend();  // 返回指向第一个元素之前位置的反向迭代器
++rit;  // 移动到第一个元素
std::cout &lt;&lt; *rit &lt;&lt; std::endl;  // 输出: 1
</code></pre>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 直接遍历 <code>std::set</code> 中的每个元素。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s = {1, 2, 3};
for (const int&amp; num : s) {
    std::cout &lt;&lt; num &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）: 使用迭代器来遍历 <code>std::set</code>。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s = {1, 2, 3};
for (auto it = s.begin(); it != s.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
</ol>
<h3 id="7其他函数"><a class="header" href="#7其他函数">(7)其他函数</a></h3>
<ol>
<li>
<p><code>swap(set&amp; other)</code>: 交换当前 <code>std::set</code> 和另一个 <code>std::set</code> 的内容。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s1 = {1, 2, 3};
std::set&lt;int&gt; s2 = {4, 5, 6};
s1.swap(s2);  // s1 变为 {4, 5, 6}，s2 变为 {1, 2, 3}
</code></pre>
</li>
<li>
<p><code>void merge(set&amp; other)</code>: <code>merge</code> 会将另一个 set 中不与当前容器重复的元素“移动”过来（O(log n) 插入），保持有序性。即使 <code>other</code> 是乱序的（但它本身仍然是一个 set，天然有序），结果依旧有序。</p>
<pre><code class="language-c++">std::set&lt;int&gt; s1 = {1, 3, 5};
std::set&lt;int&gt; s2 = {2, 4, 6};
s1.merge(s2);  // s1 合并 s2 后，变为 {1, 2, 3, 4, 5, 6}
</code></pre>
</li>
<li>
<p><code>std::allocator&lt;T&gt; get_allocator() const</code>: 返回容器所使用的分配器（allocator）。分配器负责容器内存的管理，包括内存的分配、释放等操作。在默认情况下，C++ 标准库容器使用 std::allocator 作为默认的分配器。通过调用 get_allocator()，你可以获取容器使用的分配器，并利用该分配器进行自定义内存操作，或者检查容器如何管理内存。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::set&lt;int&gt; s;

    // 获取分配器
    std::allocator&lt;int&gt; alloc = s.get_allocator();

    // 使用分配器进行内存分配
    int* p = alloc.allocate(5);  // 分配5个int元素的内存

    // 显示分配的内存地址
    std::cout &lt;&lt; "Allocated memory at: " &lt;&lt; p &lt;&lt; std::endl;

    // 记得释放分配的内存
    alloc.deallocate(p, 5);  // 释放之前分配的5个int内存

    return 0;
}
</code></pre>
</li>
<li>
<p>比较运算符：支持 ==, !=, &lt;, &lt;=, &gt;, &gt;=，C++20 起支持 &lt;=&gt;，但移除了!=, &lt;, &lt;=, &gt;, &gt;=。</p>
<blockquote>
<p>例如 <code>&lt;</code> (小于比较)比较两个 std::set 的顺序，即按照元素的字典顺序（升序排列）来进行比较。如果第一个集合的元素在第一个不相等的地方小于第二个集合，则返回 true。</p>
</blockquote>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdmultiset"><a class="header" href="#stdmultiset">std::multiset</a></h1>
<p><code>std::multiset</code> 是与 <code>std::set</code> 类似的一个容器，但与 <code>std::set</code> 不同，<code>std::multiset</code> 允许存储重复的元素。在 <code>std::multiset</code> 中，元素会按顺序排列，并且可以包含多个相同的元素。<code>std::multiset</code> 也提供了高效的查找、插入和删除操作，底层通常使用红黑树结构实现，时间复杂度通常为 O(log n)。</p>
<h2 id="1-引入-10"><a class="header" href="#1-引入-10">1. 引入</a></h2>
<pre><code class="language-C++">#include &lt;set&gt;
</code></pre>
<h2 id="2-存储方式-7"><a class="header" href="#2-存储方式-7">2. 存储方式</a></h2>
<p><code>std::multiset</code> 是基于平衡二叉树（通常是红黑树）实现的容器。与 <code>std::set</code> 相似，<code>std::multiset</code> 也具有自动排序的特性，元素会按升序（默认情况下）进行排列。但是，不同于 <code>std::set</code>，<code>std::multiset</code> 允许存储重复的元素。</p>
<p>在 <code>std::multiset</code> 中，元素存储在节点中，每个节点包含一个元素及其数量（即该元素出现的次数）。这种方式保证了所有元素的排序特性，同时允许插入多个相同的元素。</p>
<ul>
<li><strong>插入</strong>：插入一个新元素的时间复杂度为 O(log n)，并且插入重复元素时，<code>std::multiset</code> 会将元素的数量增加，而不是替换现有的元素。</li>
<li><strong>查找</strong>：在 <code>std::multiset</code> 中查找元素的时间复杂度为 O(log n)，因为它依赖于平衡二叉树的结构。</li>
<li><strong>删除</strong>：删除操作也有 O(log n) 的时间复杂度，因为删除节点时需要保持树的平衡。</li>
</ul>
<p>与 <code>std::set</code> 不同，<code>std::multiset</code> 允许插入重复元素，因此 <code>std::multiset</code> 可以包含多个相同的元素。std::multiset也不支持快速的随机访问。</p>
<h2 id="3-方法-7"><a class="header" href="#3-方法-7">3. 方法</a></h2>
<h3 id="1-构造方法-4"><a class="header" href="#1-构造方法-4">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>multiset()</code>: 创建一个空的 <code>std::multiset</code>，默认构造函数。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms;
std::multiset&lt;int&gt; ms = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p><code>multiset(const multiset&amp;)</code>: 复制构造函数，创建一个与另一个 <code>std::multiset</code> 完全相同的副本。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms1 = {1, 2, 3, 4, 5};
std::multiset&lt;int&gt; ms2(ms1);  // ms2 是 ms1 的一个复制版本
</code></pre>
</li>
<li>
<p><code>multiset(begin, end)</code>: 使用另一个容器或迭代器区间中的元素初始化 <code>std::multiset</code>。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::multiset&lt;int&gt; ms(vec.begin(), vec.end());  // 复制 vector 的元素到 multiset
</code></pre>
</li>
<li>
<p><code>std::multiset&lt;T&amp;, std::greater&lt;T&amp;&gt;&gt;</code>: 按照降序创建 <code>multiset</code>。</p>
</li>
</ol>
<h3 id="2-大小函数-4"><a class="header" href="#2-大小函数-4">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>: 返回 <code>std::multiset</code> 中元素的个数。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms = {1, 2, 3, 4};
std::cout &lt;&lt; ms.size();  // 输出 4
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::multiset</code> 是否为空，若为空返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms;
if (ms.empty()) {
    std::cout &lt;&lt; "Multiset is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>size_t max_size() const</code>: 返回最大可允许的 <code>multiset</code> 元素数量。</p>
</li>
</ol>
<h3 id="3-增加函数-4"><a class="header" href="#3-增加函数-4">(3) 增加函数</a></h3>
<ol>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert(const T&amp; value)</code>: 插入元素到 <code>multiset</code> 中，返回一个 <code>pair</code>，其 <code>first</code> 是指向插入元素所在位置的迭代器，<code>second</code> 是插入是否成功（是否为重复元素）。</p>
<pre><code class="language-c++">ms.insert({1, 2, 3});                     // initializer_list
ms.insert(ms.begin(), 42);               // 带 hint 的插入
ms.insert(vec.begin(), vec.end());      // 区间插入
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; emplace(_Args&amp;&amp;... __args)</code>: 就地构建并插入元素。</p>
</li>
<li>
<p><code>iterator emplace_hint(const_iterator __pos, _Args&amp;&amp;... __args)</code>: 就地构建并插入元素，且指定插入位置。</p>
</li>
</ol>
<h3 id="4-删除元素"><a class="header" href="#4-删除元素">(4) 删除元素</a></h3>
<ol>
<li>
<p><code>void clear()</code>: 删除 <code>std::multiset</code> 中的所有元素，使容器变为空。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms = {1, 2, 3, 4};
ms.clear();  // 删除所有元素，ms 变为空 {}
</code></pre>
</li>
<li>
<p><code>void erase(iterator pos)</code>: 删除指定位置 <code>pos</code> 处的元素。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms = {1, 2, 3, 4};
ms.erase(std::next(ms.begin(), 2));  // 删除索引为2的元素，ms 变为 {1, 2, 4}
</code></pre>
</li>
<li>
<p><code>size_t erase(const key_type&amp; key)</code>: 删除指定键，返回删除个数。</p>
</li>
<li>
<p><code>erase(first, last)</code>: 删除迭代器区间。</p>
</li>
</ol>
<h3 id="5-查找函数"><a class="header" href="#5-查找函数">(5) 查找函数</a></h3>
<ol>
<li>
<p><code>iterator find(const T&amp; value)</code>: 查找某元素在 <code>multiset</code> 中的位置，返回一个指向该元素的迭代器，如果找不到会返回 <code>end()</code>。</p>
</li>
<li>
<p><code>std::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; __x) const</code>: 返回一对迭代器，表示所有具有等于 <code>k</code> 的键的元素的范围。由于 <code>multiset</code> 允许重复元素，因此该范围可能包含多个相同的元素。如果没有与键K匹配的元素，则根据容器的内部比较对象(key_comp)，返回的范围的长度为0，两个迭代器均指向大于k的第一个元素。如果键超过了multiset容器中的最大元素，它将返回一个指向multiset容器中最后一个元素的迭代器。</p>
<pre><code class="language-c++">    std::multiset&lt;int&gt; ms = {1, 2, 3, 3, 4};
    std::pair p = ms.equal_range(3);
    std::cout &lt;&lt; *p.first &lt;&lt; std::endl; // 输出 3
    std::cout &lt;&lt; *p.second &lt;&lt; std::endl;// 输出 4
</code></pre>
</li>
<li>
<p><code>size_t count(const T&amp; value)</code>: 返回元素出现的次数。</p>
</li>
<li>
<p><code>iterator lower_bound(const T&amp; value)</code>: 返回第一个不小于 <code>value</code> 的迭代器。</p>
</li>
<li>
<p><code>iterator upper_bound(const T&amp; value)</code>: 返回第一个大于 <code>value</code> 的迭代器。</p>
</li>
<li>
<p><code>bool contains(const T&amp; value) const</code>（C++20）：检查是否包含元素。</p>
</li>
</ol>
<h3 id="6-遍历函数-1"><a class="header" href="#6-遍历函数-1">(6) 遍历函数</a></h3>
<ol>
<li>
<p><code>iterator begin()</code>: 返回指向 <code>std::multiset</code> 第一个元素的迭代器。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms = {1, 2, 3};
std::multiset&lt;int&gt;::iterator it = ms.begin();  // 返回指向第一个元素的迭代器
std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 1
</code></pre>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 <code>std::multiset</code> 最后一个元素之后位置的迭代器。</p>
</li>
<li>
<p><code>reverse_iterator rbegin()</code>: 返回指向 <code>std::multiset</code> 最后一个元素的反向迭代器。</p>
</li>
<li>
<p><code>reverse_iterator rend()</code>: 返回指向 <code>std::multiset</code> 第一个元素之前位置的反向迭代器。</p>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 直接遍历 <code>std::multiset</code> 中的每个元素。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms = {1, 2, 3};
for (const int&amp; num : ms) {
    std::cout &lt;&lt; num &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）: 使用迭代器来遍历 <code>std::multiset</code>。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms = {1, 2, 3};
for (auto it = ms.begin(); it != ms.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
</ol>
<h3 id="7-其他函数"><a class="header" href="#7-其他函数">(7) 其他函数</a></h3>
<ol>
<li>
<p><code>swap(multiset&amp; other)</code>: 交换当前 <code>std::multiset</code> 和另一个 <code>std::multiset</code> 的内容。</p>
</li>
<li>
<p><code>void merge(multiset&amp; other)</code>: 将另一个 <code>multiset</code> 中的元素合并到当前 <code>multiset</code>，如果元素重复，则保留所有元素。</p>
<pre><code class="language-c++">std::multiset&lt;int&gt; ms1 = {1, 3, 5};
std::multiset&lt;int&gt; ms2 = {2, 4, 6};
ms1.merge(ms2);  // ms1 合并 ms2 后，变为 {1, 2, 3, 4, 5, 6}
</code></pre>
</li>
<li>
<p><code>std::allocator&lt;T&gt; get_allocator() const</code>: 返回容器所使用的分配器（allocator）。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdmap"><a class="header" href="#stdmap">std::map</a></h1>
<p><code>std::map</code> 是 C++ 标准库中的一个关联容器，它用于存储一组键值对（<code>key-value</code>），并根据键进行自动排序。每个键在 <code>std::map</code> 中是唯一的，因此不允许存储重复的键。<code>std::map</code> 底层通常使用红黑树结构实现，时间复杂度通常为 O(log n) 用于插入、查找和删除操作。</p>
<h2 id="1-引入-11"><a class="header" href="#1-引入-11">1. 引入</a></h2>
<pre><code class="language-cpp">#include &lt;map&gt;
</code></pre>
<h2 id="2-存储方式-8"><a class="header" href="#2-存储方式-8">2. 存储方式</a></h2>
<p><code>std::map</code> 是基于平衡二叉树（通常是红黑树）实现的容器。与 <code>std::set</code> 类似，<code>std::map</code> 也具有自动排序的特性，元素会根据键（key）进行升序排序（默认情况下）。与 <code>std::set</code> 的区别是，<code>std::map</code> 存储的是键值对，每个键对应一个值，且键是唯一的。</p>
<p>在 <code>std::map</code> 中，元素存储为节点，每个节点包含一个键值对和指向父节点、左子节点和右子节点的指针。通过这种方式，<code>std::map</code> 保证了所有键的排序特性，并支持高效的查找、插入和删除操作。</p>
<ul>
<li><strong>插入</strong>：插入一个新元素的时间复杂度为 O(log n)，并且如果插入的键已经存在，新的值会覆盖原来的值。</li>
<li><strong>查找</strong>：在 <code>std::map</code> 中查找元素的时间复杂度为 O(log n)，这是因为它依赖于平衡二叉树的结构。</li>
<li><strong>删除</strong>：删除操作也有 O(log n) 的时间复杂度，因为删除节点时需要保持树的平衡。</li>
</ul>
<p><code>std::map</code> 不允许重复的键，因此每个键只能对应一个值。如果尝试插入一个已存在的键，插入操作会被忽略。</p>
<h2 id="3-方法-8"><a class="header" href="#3-方法-8">3. 方法</a></h2>
<h3 id="1-构造方法-5"><a class="header" href="#1-构造方法-5">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>map()</code>: 创建一个空的 <code>std::map</code>，默认构造函数。</p>
<pre><code class="language-cpp">// std::map&lt;key_type, value_type&gt; myMap;
std::map&lt;int, std::string&gt; m;
std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}, {3, "three"}};
</code></pre>
</li>
<li>
<p><code>map(const map&amp;)</code>: 复制构造函数，创建一个与另一个 <code>std::map</code> 完全相同的副本。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m1 = {{1, "one"}, {2, "two"}};
std::map&lt;int, std::string&gt; m2(m1);  // m2 是 m1 的一个复制版本
</code></pre>
</li>
<li>
<p><code>map(begin, end)</code>: 使用另一个容器或迭代器区间中的元素初始化 <code>std::map</code>。</p>
<pre><code class="language-cpp">std::vector&lt;std::pair&lt;int, std::string&gt;&gt; vec = {{1, "one"}, {2, "two"}};
std::map&lt;int, std::string&gt; m(vec.begin(), vec.end());  // 复制 vector 的元素到 map
</code></pre>
</li>
<li>
<p><code>std::map&lt;Key, T, Compare&gt;</code>: 使用自定义的比较器来进行键的排序。</p>
</li>
</ol>
<h3 id="2-大小函数-5"><a class="header" href="#2-大小函数-5">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>: 返回 <code>std::map</code> 中元素的个数。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
std::cout &lt;&lt; m.size();  // 输出 2
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::map</code> 是否为空，若为空返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m;
if (m.empty()) {
    std::cout &lt;&lt; "Map is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>size_t max_size() const</code>: 返回最大可允许的 <code>map</code> 元素数量。</p>
</li>
</ol>
<h3 id="3-增加函数-5"><a class="header" href="#3-增加函数-5">(3) 增加函数</a></h3>
<ol>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert(const value_type&amp; value)</code>: 插入一个元素到 <code>std::map</code> 中，返回一个 <code>pair</code>，其中 <code>first</code> 是指向插入元素所在位置的迭代器，<code>second</code> 表示插入是否成功（如果键已存在，则插入失败）。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m;
m.insert({1, "one"});
m.insert({2, "two"});
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; emplace(_Args&amp;&amp;... args)</code>: 就地构建并插入元素。</p>
</li>
<li>
<p><code>iterator emplace_hint(const_iterator hint, _Args&amp;&amp;... args)</code>: 就地构建并插入元素，且指定插入位置。</p>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; try_emplace(const key_type&amp; key, Args&amp;&amp;... args)</code>: 是 C++17 引入的一种插入方式。它尝试插入一个元素，如果给定的键已经存在，则不会插入新元素，并且不会更改已有元素的值。它还允许通过参数传递构造函数的参数，避免不必要的拷贝或移动。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m;
auto result = m.try_emplace(1, "one");
if (result.second) {
    std::cout &lt;&lt; "Element inserted: " &lt;&lt; result.first-&gt;second &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Element with key " &lt;&lt; result.first-&gt;first &lt;&lt; " already exists." &lt;&lt; std::endl;
}

auto result2 = m.try_emplace(1, "uno");  // 不会插入新元素，因为键1已存在
std::cout &lt;&lt; "Element: " &lt;&lt; result2.first-&gt;second &lt;&lt; std::endl;  // 输出: "one"
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert_or_assign(const key_type&amp; key, const mapped_type&amp; obj)</code>和<code>std::pair&lt;iterator, bool&gt; insert_or_assign(const key_type&amp; key, mapped_type&amp;&amp; obj)</code>: 是 C++17 引入的另一种插入方式，它的作用是：如果键不存在，就插入该键值对；如果键已经存在，则更新其对应的值。</p>
</li>
<li>
<p><code>operator[]</code> 插入方式(<code>mapped_type&amp; operator[](const key_type&amp; key)</code>或<code>mapped_type&amp; operator[](key_type&amp;&amp; key);</code>): 最常见的插入方式。它会检查 std::map 中是否存在给定的键。如果键存在，它返回该键对应的值；如果键不存在，它会插入该键并且初始化对应的值为 mapped_type 的默认值（对于非内置类型，是通过默认构造函数进行初始化）。同样的，这样的方式还可以用来获取键对应的值。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m;
m[1] = "one";  // 插入新元素
std::cout &lt;&lt; m[1] &lt;&lt; std::endl;  // 输出: one

m[1] = "uno";  // 更新已有的元素
std::cout &lt;&lt; m[1] &lt;&lt; std::endl;  // 输出: uno

m[2];  // 键2不存在，会插入键2，并将对应的值初始化为默认值 "" (空字符串)
std::cout &lt;&lt; m[2] &lt;&lt; std::endl;  // 输出: (空字符串)
</code></pre>
</li>
</ol>
<h3 id="4-删除元素-1"><a class="header" href="#4-删除元素-1">(4) 删除元素</a></h3>
<ol>
<li>
<p><code>void clear()</code>: 删除 <code>std::map</code> 中的所有元素，使容器变为空。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
m.clear();  // 删除所有元素，m 变为空 {}
</code></pre>
</li>
<li>
<p><code>void erase(iterator pos)</code>: 删除指定位置 <code>pos</code> 处的元素。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
m.erase(m.begin());  // 删除第一个元素
</code></pre>
</li>
<li>
<p><code>size_t erase(const key_type&amp; key)</code>: 删除指定键，返回删除个数。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
m.erase(1);  // 删除键为1的元素
</code></pre>
</li>
<li>
<p><code>erase(first, last)</code>: 删除迭代器区间。</p>
</li>
</ol>
<h3 id="5-查找函数-1"><a class="header" href="#5-查找函数-1">(5) 查找函数</a></h3>
<ol>
<li>
<p><code>iterator find(const key_type&amp; key)</code>: 查找某个键在 <code>map</code> 中的位置，返回一个指向该元素的迭代器，如果找不到会返回 <code>end()</code>。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
auto it = m.find(1);  // 返回指向键1的迭代器
std::cout &lt;&lt; it-&gt;second;  // 输出 "one"
</code></pre>
</li>
<li>
<p><code>std::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; key) const</code>: 返回一对迭代器，表示所有具有等于键 <code>key</code> 的元素的范围。在 <code>std::map</code> 中，由于键是唯一的，因此这个范围包含一个元素。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
auto range = m.equal_range(1);
std::cout &lt;&lt; range.first-&gt;second &lt;&lt; std::endl;  // 输出 "one"
</code></pre>
</li>
<li>
<p><code>size_t count(const key_type&amp; key)</code>: 返回容器中是否包含指定键，<code>map</code> 中每个键最多出现一次，因此返回值要么是 <code>0</code>，要么是 <code>1</code>。</p>
</li>
<li>
<p><code>iterator lower_bound(const key_type&amp; key)</code>: 返回第一个不小于 <code>key</code> 的迭代器。</p>
</li>
<li>
<p><code>iterator upper_bound(const key_type&amp; key)</code>: 返回第一个大于 <code>key</code> 的迭代器。</p>
</li>
<li>
<p><code>bool contains(const key_type&amp; key) const</code>（C++20）：检查是否包含该键。</p>
</li>
</ol>
<h3 id="6-遍历函数-2"><a class="header" href="#6-遍历函数-2">(6) 遍历函数</a></h3>
<ol>
<li>
<p><code>iterator begin()</code>: 返回指向 <code>std::map</code> 第一个元素的迭代器。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
auto it = m.begin();  // 返回指向第一个元素的迭代器
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; std::endl;  // 输出 1: one
</code></pre>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 <code>std::map</code> 最后一个元素之后位置的迭代器。</p>
</li>
<li>
<p><code>reverse_iterator rbegin()</code>: 返回指向 <code>std::map</code> 最后一个元素的反向迭代器。</p>
</li>
<li>
<p><code>reverse_iterator rend()</code>: 返回指向 <code>std::map</code> 第一个元素之前位置的反向迭代器。</p>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 直接遍历 <code>std::map</code> 中的每个元素。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
for (const auto&amp; pair : m) {
    std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; " ";  // 输出: 1: one 2: two
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）: 使用迭代器来遍历 <code>std::map</code>。</p>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
for (auto it = m.begin(); it != m.end(); ++it) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";  // 输出: 1: one 2: two
}
</code></pre>
</li>
</ol>
<h3 id="7-其他函数-1"><a class="header" href="#7-其他函数-1">(7) 其他函数</a></h3>
<ol>
<li>
<p><code>swap(map&amp; other)</code>: 交换当前 <code>std::map</code> 和另一个 <code>std::map</code> 的内容。</p>
</li>
<li>
<p><code>std::allocator&lt;T&gt; get_allocator() const</code>: 返回容器所使用的分配器（allocator）。</p>
</li>
<li>
<p><code>std::map&lt;Key, T, Compare&gt; merge(map&amp; other)</code>: 将另一个<code>map</code>容器合并过来，保持有序性。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdmultimap"><a class="header" href="#stdmultimap">std::multimap</a></h1>
<p><code>std::multimap</code> 是一个与 <code>std::map</code> 类似的关联容器，但与 <code>std::map</code> 不同，<code>std::multimap</code> 允许存储重复的键。在 <code>std::multimap</code> 中，键是可以重复的，而每个键都可以关联多个不同的值。与 <code>std::map</code> 相同，<code>std::multimap</code> 也会自动按照键的顺序进行排序。<code>std::multimap</code> 的底层实现通常使用红黑树，时间复杂度通常为 O(log n) 用于插入、查找和删除操作。</p>
<h2 id="1-引入-12"><a class="header" href="#1-引入-12">1. 引入</a></h2>
<pre><code class="language-cpp">#include &lt;map&gt;
</code></pre>
<h2 id="2-存储方式-9"><a class="header" href="#2-存储方式-9">2. 存储方式</a></h2>
<p><code>std::multimap</code> 与 <code>std::map</code> 类似，都是基于平衡二叉树（通常是红黑树）实现的容器。与 <code>std::map</code> 不同，<code>std::multimap</code> 允许同一个键对应多个值，因此在插入重复的键时，<code>std::multimap</code> 会将新的键值对插入到现有键的下方，而不是替换原有的键值对。</p>
<p><code>std::multimap</code> 中的每个元素都是一个键值对（<code>key-value</code>），并且元素根据键自动排序。每个键在 <code>std::multimap</code> 中可以重复多次，不同的键值对可以共享同一个键。</p>
<ul>
<li><strong>插入</strong>：插入一个新元素的时间复杂度为 O(log n)，并且允许插入多个具有相同键的元素。</li>
<li><strong>查找</strong>：在 <code>std::multimap</code> 中查找元素的时间复杂度为 O(log n)，因为它依赖于平衡二叉树的结构。</li>
<li><strong>删除</strong>：删除操作也有 O(log n) 的时间复杂度，因为删除节点时需要保持树的平衡。</li>
</ul>
<p><code>std::multimap</code> 适用于需要存储多个值并能够按键排序的场景。</p>
<h2 id="3-方法-9"><a class="header" href="#3-方法-9">3. 方法</a></h2>
<h3 id="1-构造方法-6"><a class="header" href="#1-构造方法-6">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>multimap()</code>: 创建一个空的 <code>std::multimap</code>，默认构造函数。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm;
std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {2, "two"}, {3, "three"}};
</code></pre>
</li>
<li>
<p><code>multimap(const multimap&amp;)</code>: 复制构造函数，创建一个与另一个 <code>std::multimap</code> 完全相同的副本。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm1 = {{1, "one"}, {2, "two"}};
std::multimap&lt;int, std::string&gt; mm2(mm1);  // mm2 是 mm1 的一个复制版本
</code></pre>
</li>
<li>
<p><code>multimap(begin, end)</code>: 使用另一个容器或迭代器区间中的元素初始化 <code>std::multimap</code>。</p>
<pre><code class="language-cpp">std::vector&lt;std::pair&lt;int, std::string&gt;&gt; vec = {{1, "one"}, {2, "two"}};
std::multimap&lt;int, std::string&gt; mm(vec.begin(), vec.end());  // 复制 vector 的元素到 multimap
</code></pre>
</li>
<li>
<p><code>std::multimap&lt;Key, T, Compare&gt;</code>: 使用自定义的比较器来进行键的排序。</p>
</li>
</ol>
<h3 id="2-大小函数-6"><a class="header" href="#2-大小函数-6">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>: 返回 <code>std::multimap</code> 中元素的个数。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {2, "two"}};
std::cout &lt;&lt; mm.size();  // 输出 2
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::multimap</code> 是否为空，若为空返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm;
if (mm.empty()) {
    std::cout &lt;&lt; "Multimap is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>size_t max_size() const</code>: 返回最大可允许的 <code>multimap</code> 元素数量。</p>
</li>
</ol>
<h3 id="3-增加函数-6"><a class="header" href="#3-增加函数-6">(3) 增加函数</a></h3>
<ol>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert(const value_type&amp; value)</code>: 插入一个元素到 <code>std::multimap</code> 中，返回一个 <code>pair</code>，其中 <code>first</code> 是指向插入元素所在位置的迭代器，<code>second</code> 表示插入是否成功（即该键是否已经存在）。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm;
mm.insert({1, "one"});
mm.insert({2, "two"});
mm.insert({1, "uno"});  // 允许插入重复键
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; emplace(_Args&amp;&amp;... args)</code>: 就地构建并插入元素。</p>
</li>
<li>
<p><code>iterator emplace_hint(const_iterator hint, _Args&amp;&amp;... args)</code>: 就地构建并插入元素，且指定插入位置。</p>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; try_emplace(const key_type&amp; key, Args&amp;&amp;... args)</code>: 是 C++17 引入的一种插入方式。它尝试插入一个元素，如果给定的键已经存在，则不会插入新元素，并且不会更改已有元素的值。它还允许通过参数传递构造函数的参数，避免不必要的拷贝或移动。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; m;
auto result = m.try_emplace(1, "one");
if (result.second) {
    std::cout &lt;&lt; "Element inserted: " &lt;&lt; result.first-&gt;second &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Element with key " &lt;&lt; result.first-&gt;first &lt;&lt; " already exists." &lt;&lt; std::endl;
}

auto result2 = m.try_emplace(1, "uno");  // 不会插入新元素，因为键1已存在
std::cout &lt;&lt; "Element: " &lt;&lt; result2.first-&gt;second &lt;&lt; std::endl;  // 输出: "one"
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert_or_assign(const key_type&amp; key, const mapped_type&amp; obj)</code>和<code>std::pair&lt;iterator, bool&gt; insert_or_assign(const key_type&amp; key, mapped_type&amp;&amp; obj)</code>: 是 C++17 引入的另一种插入方式，它的作用是：如果键不存在，就插入该键值对；如果键已经存在，则更新其对应的值。</p>
</li>
<li>
<p><code>operator[]</code> 插入方式(<code>mapped_type&amp; operator[](const key_type&amp; key)</code>或<code>mapped_type&amp; operator[](key_type&amp;&amp; key);</code>): 最常见的插入方式。它会检查 std::multimap 中是否存在给定的键。如果键存在，它返回该键对应的值；如果键不存在，它会插入该键并且初始化对应的值为 mapped_type 的默认值（对于非内置类型，是通过默认构造函数进行初始化）。同样的，这样的方式还可以用来获取键对应的值。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; m;
m[1] = "one";  // 插入新元素
std::cout &lt;&lt; m[1] &lt;&lt; std::endl;  // 输出: one

m[1] = "uno";  // 更新已有的元素
std::cout &lt;&lt; m[1] &lt;&lt; std::endl;  // 输出: uno

m[2];  // 键2不存在，会插入键2，并将对应的值初始化为默认值 "" (空字符串)
std::cout &lt;&lt; m[2] &lt;&lt; std::endl;  // 输出: (空字符串)
</code></pre>
</li>
</ol>
<h3 id="4-删除元素-2"><a class="header" href="#4-删除元素-2">(4) 删除元素</a></h3>
<ol>
<li>
<p><code>void clear()</code>: 删除 <code>std::multimap</code> 中的所有元素，使容器变为空。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {2, "two"}};
mm.clear();  // 删除所有元素，mm 变为空 {}
</code></pre>
</li>
<li>
<p><code>void erase(iterator pos)</code>: 删除指定位置 <code>pos</code> 处的元素。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {2, "two"}};
mm.erase(mm.begin());  // 删除第一个元素
</code></pre>
</li>
<li>
<p><code>size_t erase(const key_type&amp; key)</code>: 删除指定键，返回删除的元素个数。如果键有重复元素，则会删除所有具有该键的元素。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {1, "uno"}, {2, "two"}};
mm.erase(1);  // 删除键为 1 的所有元素
</code></pre>
</li>
<li>
<p><code>erase(first, last)</code>: 删除迭代器区间。</p>
</li>
</ol>
<h3 id="5-查找函数-2"><a class="header" href="#5-查找函数-2">(5) 查找函数</a></h3>
<ol>
<li>
<p><code>iterator find(const key_type&amp; key)</code>: 查找某个键在 <code>multimap</code> 中的位置，返回一个指向该元素的迭代器，如果找不到会返回 <code>end()</code>。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {2, "two"}};
auto it = mm.find(1);  // 返回指向键1的迭代器
std::cout &lt;&lt; it-&gt;second;  // 输出 "one"
</code></pre>
</li>
<li>
<p><code>std::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; key) const</code>: 返回一对迭代器，表示所有具有等于键 <code>key</code> 的元素的范围。在 <code>std::multimap</code> 中，由于键是可以重复的，因此这个范围可能包含多个相同的元素。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {1, "uno"}, {2, "two"}};
auto range = mm.equal_range(1);
std::cout &lt;&lt; range.first-&gt;second &lt;&lt; " " &lt;&lt; range.second-&gt;second &lt;&lt; std::endl;
</code></pre>
</li>
<li>
<p><code>size_t count(const key_type&amp; key)</code>: 返回容器中某个键的元素个数（在 <code>std::multimap</code> 中可以有多个相同键）。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {1, "uno"}, {2, "two"}};
std::cout &lt;&lt; mm.count(1);  // 输出 2，因为键1出现了两次
</code></pre>
</li>
<li>
<p><code>iterator lower_bound(const key_type&amp; key)</code>: 返回第一个不小于 <code>key</code> 的迭代器。</p>
</li>
<li>
<p><code>iterator upper_bound(const key_type&amp; key)</code>: 返回第一个大于 <code>key</code> 的迭代器。</p>
</li>
<li>
<p><code>bool contains(const key_type&amp; key) const</code>（C++20）：检查是否包含该键。</p>
</li>
</ol>
<h3 id="6-遍历函数-3"><a class="header" href="#6-遍历函数-3">(6) 遍历函数</a></h3>
<ol>
<li>
<p><code>iterator begin()</code>: 返回指向 <code>std::multimap</code> 第一个元素的迭代器。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {2, "two"}};
auto it = mm.begin();  // 返回指向第一个元素的迭代器
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; std::endl;  // 输出 1: one
</code></pre>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 <code>std::multimap</code> 最后一个元素之后位置的迭代器。</p>
</li>
<li>
<p><code>reverse_iterator rbegin()</code>: 返回指向 <code>std::multimap</code> 最后一个元素的反向迭代器。</p>
</li>
<li>
<p><code>reverse_iterator rend()</code>: 返回指向 <code>std::multimap</code> 第一个元素之前位置的反向迭代器。</p>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 直接遍历 <code>std::multimap</code> 中的每个元素。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {2, "two"}};
for (const auto&amp; pair : mm) {
    std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; " ";  // 输出: 1: one 2: two
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）: 使用迭代器来遍历 <code>std::multimap</code>。</p>
<pre><code class="language-cpp">std::multimap&lt;int, std::string&gt; mm = {{1, "one"}, {2, "two"}};
for (auto it = mm.begin(); it != mm.end(); ++it) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";  // 输出: 1: one 2: two
}
</code></pre>
</li>
</ol>
<h3 id="7-其他函数-2"><a class="header" href="#7-其他函数-2">(7) 其他函数</a></h3>
<ol>
<li>
<p><code>swap(multimap&amp; other)</code>: 交换当前 <code>std::multimap</code> 和另一个 <code>std::multimap</code> 的内容。</p>
</li>
<li>
<p><code>std::allocator&lt;T&gt; get_allocator() const</code>: 返回容器所使用的分配器（allocator）。</p>
</li>
<li>
<p><code>std::multimap&lt;Key, T, Compare&gt; merge(multimap&amp; other)</code>: 将另一个<code>multimap</code>容器合并过来，保持有序性。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdunordered_set"><a class="header" href="#stdunordered_set">std::unordered_set</a></h1>
<p><code>std::unordered_set</code> 是一个无序的关联容器，它与 <code>std::set</code> 的主要区别在于元素的存储顺序。<code>std::set</code> 按照元素的升序排列，而 <code>std::unordered_set</code> 不保持任何顺序，它依赖于哈希表实现，因此元素的存储位置是由哈希函数决定的。<code>std::unordered_set</code> 提供了高效的查找、插入和删除操作，底层通常使用哈希表，查找、插入和删除操作的平均时间复杂度为 O(1)，但最坏情况下为 O(n)。</p>
<p><code>unordered_map</code>是一个模板类，其定义如下：</p>
<pre><code class="language-cpp">std::unordered_set&lt;Key, Hash = std::hash&lt;Key&gt;, Pred = std::equal_to&lt;Key&gt;, Alloc = std::allocator&lt;Key&gt;&gt;
</code></pre>
<ul>
<li>Key 是存储在 <code>unordered_set</code> 中的元素类型。</li>
<li>Hash 是一个函数或函数对象，用于生成元素的哈希值，默认为 <code>std::hash&lt;Key&gt;</code>。</li>
<li>Pred 是一个二元谓词，用于比较两个元素是否相等，默认为 <code>std::equal_to&lt;Key&gt;</code>。</li>
<li>Alloc 是分配器类型，用于管理内存分配，默认为 <code>std::allocator&lt;Key&gt;</code>。</li>
</ul>
<h2 id="1-引入-13"><a class="header" href="#1-引入-13">1. 引入</a></h2>
<pre><code class="language-C++">#include &lt;unordered_set&gt;
</code></pre>
<h2 id="2-存储方式-10"><a class="header" href="#2-存储方式-10">2. 存储方式</a></h2>
<p><code>std::unordered_set</code> 使用哈希表（hash table）来存储元素。每个元素的存储位置由哈希函数计算出来，因此它不保证元素的顺序。哈希表允许非常高效的查找、插入和删除操作，通常时间复杂度为 O(1)，但在哈希冲突的情况下，最坏情况的时间复杂度可能退化为 O(n)。</p>
<ul>
<li><strong>插入</strong>：插入一个元素时，哈希函数会计算该元素的哈希值，并将元素存储在哈希表中。</li>
<li><strong>查找</strong>：查找操作的时间复杂度为 O(1)，但是哈希冲突可能导致时间复杂度退化为 O(n)。</li>
<li><strong>删除</strong>：删除操作的时间复杂度通常为 O(1)，但最坏情况下可能退化为 O(n)。</li>
</ul>
<p><code>std::unordered_set</code> 与 <code>std::set</code> 最大的区别是，它使用哈希表来存储元素，因此没有顺序性，无法进行按顺序的遍历。</p>
<h2 id="3-方法-10"><a class="header" href="#3-方法-10">3. 方法</a></h2>
<h3 id="1构造方法-3"><a class="header" href="#1构造方法-3">(1)构造方法</a></h3>
<ol>
<li>
<p><code>unordered_set()</code>: 创建一个空的 <code>std::unordered_set</code>，默认构造函数。</p>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us;
std::unordered_set&lt;int&gt; us = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p><code>unordered_set(const unordered_set&amp;)</code>: 复制构造函数，创建一个与另一个 <code>std::unordered_set</code> 完全相同的副本。</p>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us1 = {1, 2, 3, 4, 5};
std::unordered_set&lt;int&gt; us2(us1);  // us2 是 us1 的一个复制版本
</code></pre>
</li>
<li>
<p><code>unordered_set(begin, end)</code>: 使用另一个容器或迭代器区间中的元素初始化 <code>std::unordered_set</code>。</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::unordered_set&lt;int&gt; us(vec.begin(), vec.end());  // 复制 vector 的元素到 unordered_set
</code></pre>
</li>
</ol>
<h4 id="2-大小函数-7"><a class="header" href="#2-大小函数-7">(2) 大小函数</a></h4>
<ol>
<li>
<p><code>size_t size() const</code>: 返回 <code>std::unordered_set</code> 中元素的个数。</p>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us = {1, 2, 3, 4};
std::cout &lt;&lt; us.size();  // 输出 4
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::unordered_set</code> 是否为空，若为空返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us;
if (us.empty()) {
    std::cout &lt;&lt; "Unordered Set is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>size_t max_size() const</code>: 返回最大可允许的 <code>unordered_set</code> 元素数量。</p>
</li>
<li>
<p><code>void reserve(size_t n)</code>: 用于预先分配哈希表的桶数量。这可以有效减少动态扩容的开销，特别是在你知道将要插入大量元素时。</p>
</li>
</ol>
<h4 id="3-增加函数-7"><a class="header" href="#3-增加函数-7">(3) 增加函数</a></h4>
<ol>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert(const T&amp; value)</code>: 插入元素到 <code>unordered_set</code> 中，返回一个 <code>pair</code>，其中 <code>first</code> 是指向插入元素所在位置的迭代器，<code>second</code> 是插入是否成功（如果存在重复元素，则插入失败）。</p>
<pre><code class="language-cpp">us.insert({1, 2, 3});                     // initializer_list
us.insert(us.begin(), 42);               // 带 hint 的插入
us.insert(vec.begin(), vec.end());      // 区间插入
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; emplace(_Args&amp;&amp;... args)</code>: 就地构建并插入元素。</p>
</li>
<li>
<p><code>iterator emplace_hint(const_iterator hint, _Args&amp;&amp;... args)</code>: 就地构建并插入元素，且指定插入位置，但是如果指定位置错误会发生重排序，最坏情况下可能会降低插入的效率。在哈希索引的前提下是无序的，因此该插入操作等效于<code>insert</code>。</p>
</li>
</ol>
<h4 id="4-删除元素-3"><a class="header" href="#4-删除元素-3">(4) 删除元素</a></h4>
<ol>
<li>
<p><code>void clear()</code>: 删除 <code>std::unordered_set</code> 中的所有元素，使容器变为空。</p>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us = {1, 2, 3, 4};
us.clear();  // 删除所有元素，us 变为空 {}
</code></pre>
</li>
<li>
<p><code>void erase(iterator pos)</code>: 删除指定位置 <code>pos</code> 处的元素。</p>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us = {1, 2, 3, 4};
us.erase(std::next(us.begin(), 2));  // 删除索引为2的元素，us 变为 {1, 2, 4}
</code></pre>
</li>
<li>
<p><code>size_t erase(const key_type&amp; key)</code>: 删除指定键，返回删除个数。</p>
</li>
<li>
<p><code>erase(first, last)</code>: 删除迭代器区间。</p>
</li>
</ol>
<h4 id="5-查找函数-3"><a class="header" href="#5-查找函数-3">(5) 查找函数</a></h4>
<ol>
<li>
<p><code>iterator find(const T&amp; value)</code>: 查找某元素在 <code>unordered_set</code> 中的位置，返回一个指向该元素的迭代器，如果找不到会返回 <code>end()</code>。</p>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us = {1, 2, 3, 4};
auto it = us.find(1);  // 返回指向键1的迭代器
if (it != us.end()) {
    std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 1
}
</code></pre>
</li>
<li>
<p><code>std::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; __x) const</code>: 返回一对迭代器，表示所有具有等于k的键的元素的范围。由于set包含唯一元素，因此下界将是元素本身，上限将指向键k之后的下一个元素。如果没有与键K匹配的元素，则根据容器的内部比较对象(key_comp)，返回的范围的长度为0，两个迭代器均指向大于k的第一个元素。如果键超过了set容器中的最大元素，它将返回一个指向set容器中最后一个元素的迭代器。</p>
</li>
<li>
<p><code>size_t count(const T&amp; value)</code>: 返回元素是否存在（0 或 1）。</p>
</li>
<li>
<p><code>bool contains(const T&amp; value) const</code>（C++20）：检查是否包含该元素。</p>
</li>
</ol>
<h4 id="6-遍历函数-4"><a class="header" href="#6-遍历函数-4">(6) 遍历函数</a></h4>
<ol>
<li>
<p><code>iterator begin()</code>: 返回指向 <code>std::unordered_set</code> 第一个元素的迭代器。</p>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 <code>std::unordered_set</code> 最后一个元素之后位置的迭代器。</p>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 直接遍历 <code>std::unordered_set</code> 中的每个元素。</p>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us = {1, 2, 3};
for (const int&amp; num : us) {
    std::cout &lt;&lt; num &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）: 使用迭代器来遍历 <code>std::unordered_set</code>。</p>
<pre><code class="language-cpp">std::unordered_set&lt;int&gt; us = {1, 2, 3};
for (auto it = us.begin(); it != us.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";  // 输出: 1 2 3
}
</code></pre>
</li>
</ol>
<h3 id="7哈希相关函数"><a class="header" href="#7哈希相关函数">(7)哈希相关函数</a></h3>
<ol>
<li>
<p><code>size_type max_bucket_count() const noexcept</code>: max_bucket_count() 返回 std::unordered_set 中可用的最大哈希桶数量。哈希表是由一组桶（bucket）构成的，每个桶存储一定数量的元素。当元素的数量增加时，std::unordered_set 可能会自动扩展桶的数量，以减少哈希冲突。max_bucket_count() 允许你查看哈希表最多能支持多少个桶。</p>
</li>
<li>
<p><code>float max_load_factor() const noexcept</code>: max_load_factor() 返回或设置哈希表的最大负载因子。负载因子是哈希表中元素的数量与桶数量之比。它决定了哈希表何时扩展——当负载因子超过最大值时，std::unordered_set 会增加桶的数量，减少哈希冲突，从而提高性能。</p>
<ul>
<li>负载因子是指：负载因子 = 元素个数 / 桶的数量</li>
<li>最大负载因子是哈希表在扩展之前允许的最大负载因子。负载因子越高，意味着桶的数量相对较少，这可能导致更多的哈希冲突，降低查找效率。</li>
</ul>
</li>
<li>
<p><code>void max_load_factor(float __z)</code>: 设置最大负载因子。</p>
</li>
<li>
<p><code>size_t bucket_count() const</code>: 返回当前 unordered_set 的桶数量。哈希表的桶数量与容器中元素的数量以及负载因子相关，通常哈希表会在元素数量增加时自动扩展桶的数量。</p>
</li>
<li>
<p><code>size_t bucket_size(size_t n) const</code>: 返回指定桶的元素数量。哈希表中的每个桶可能包含多个元素，特别是当哈希冲突发生时，多个元素可能会存储在同一个桶中。</p>
</li>
<li>
<p><code>size_t bucket(const key_type&amp; key) const</code>: 返回给定键所在的桶的索引。这个函数对于理解元素是如何分布在哈希表中的非常有用。</p>
</li>
<li>
<p><code>float load_factor() const</code>: 返回当前哈希表的负载因子，即元素的数量与桶数量的比值。负载因子越高，哈希冲突的可能性越大，因此负载因子对于性能非常重要。</p>
</li>
<li>
<p><code>void rehash(size_t n)</code>: 用来调整哈希表中的桶数量。它的作用是根据新的元素数量来调整桶的数量，避免哈希冲突过多。rehash() 会导致重新分配桶并重新哈希元素。n 是希望容器能够容纳的元素数量。</p>
</li>
</ol>
<h4 id="8-其他函数"><a class="header" href="#8-其他函数">(8) 其他函数</a></h4>
<ol>
<li>
<p><code>swap(unordered_set&amp; other)</code>: 交换当前 <code>std::unordered_set</code> 和另一个 <code>std::unordered_set</code> 的内容。</p>
</li>
<li>
<p><code>std::allocator&lt;T&gt; get_allocator() const</code>: 返回容器所使用的分配器（allocator）。</p>
</li>
<li>
<p><code>void merge(unordered_set&amp; other)</code>: <code>merge</code> 会将另一个 unordered_set 中不与当前容器重复的元素“移动”过来。</p>
<pre><code class="language-c++">std::unordered_set&lt;int&gt; s1 = {1, 3, 5};
std::unordered_set&lt;int&gt; s2 = {2, 4, 6};
s1.merge(s2);  // s1 合并 s2 后，变为 {1, 2, 3, 4, 5, 6}
</code></pre>
</li>
<li>
<p><code>key_equal_type key_eq() const</code>： 返回一个比较器，用于判断两个键是否相等</p>
<pre><code class="language-cpp">std::unordered_set&lt;Person, PersonHash&gt; people;

Person p1 = {"Alice", 30};
Person p2 = {"Bob", 25};
people.insert(p1);
people.insert(p2);

// 使用 key_eq 获取比较函数
auto eq = people.key_eq();

// 使用 key_eq 函数比较两个键
std::cout &lt;&lt; "Are p1 and p2 equal? " &lt;&lt; std::boolalpha &lt;&lt; eq(p1, p2) &lt;&lt; std::endl;
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdunordered_multiset"><a class="header" href="#stdunordered_multiset">std::unordered_multiset</a></h1>
<p><code>std::unordered_multiset</code> 是一个类似于 <code>std::unordered_set</code> 的容器，唯一的区别在于它允许元素重复。它同样使用哈希表实现，不保证元素的顺序，能够提供高效的查找、插入和删除操作。</p>
<p>为了支持重复键，<code>unordered_multiset</code>通过将每个元素存储为一个“桶”中的链表或其他结构。每个“桶”会存储多个相同的元素，而 <code>unordered_set</code> 只允许每个桶中最多存储一个元素。</p>
<p><code>unordered_multiset</code> 的模板定义如下：</p>
<pre><code class="language-cpp">template&lt;
    class Key,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt;
&gt; class unordered_multiset; // since C++11
</code></pre>
<pre><code class="language-cpp">namespace pmr {
    template&lt;
        class Key,
        class Hash = std::hash&lt;Key&gt;,
        class Pred = std::equal_to&lt;Key&gt;
    &gt; using unordered_multiset = std::unordered_multiset&lt;Key, Hash, Pred,
                                     std::pmr::polymorphic_allocator&lt;Key&gt;&gt;;
} // since C++17
</code></pre>
<ul>
<li>Key：存储在 <code>unordered_multiset</code> 中的元素类型。</li>
<li>Hash：用于计算元素哈希值的函数或函数对象，默认为 <code>std::hash&lt;Key&gt;</code>。</li>
<li>Pred：用于比较两个元素是否相等的二元谓词，默认为 <code>std::equal_to&lt;Key&gt;</code>。</li>
<li>Alloc：分配器类型，用于内存分配，默认为 <code>std::allocator&lt;Key&gt;</code>。</li>
</ul>
<h2 id="1-引入-14"><a class="header" href="#1-引入-14">1. 引入</a></h2>
<pre><code class="language-cpp">#include &lt;unordered_set&gt;
</code></pre>
<h2 id="2-存储方式-11"><a class="header" href="#2-存储方式-11">2. 存储方式</a></h2>
<p><code>std::unordered_multiset</code> 使用哈希表（hash table）来存储元素。每个元素的存储位置由哈希函数计算出来，多个相同的元素会被存储在同一个桶中。</p>
<ul>
<li><strong>插入</strong>：插入一个元素时，哈希函数计算该元素的哈希值，将元素存储在相应的桶中，允许同一元素的多个副本被插入。</li>
<li><strong>查找</strong>：查找操作的时间复杂度通常为 O(1)，但最坏情况下会退化为 O(n)，具体取决于哈希表的负载因子和哈希冲突。</li>
<li><strong>删除</strong>：删除操作通常是 O(1)，但最坏情况下会退化为 O(n)。</li>
</ul>
<p>与 <code>unordered_set</code> 不同，<code>unordered_multiset</code> 允许在同一个哈希表的桶中存储多个相同的元素。</p>
<h2 id="3-方法-11"><a class="header" href="#3-方法-11">3. 方法</a></h2>
<h3 id="1-构造方法-7"><a class="header" href="#1-构造方法-7">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>unordered_multiset()</code>：创建一个空的 <code>std::unordered_multiset</code>，使用默认构造函数。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us;
std::unordered_multiset&lt;int&gt; us = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p><code>unordered_multiset(const unordered_multiset&amp;)</code>：复制构造函数，创建一个与另一个 <code>std::unordered_multiset</code> 完全相同的副本。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us1 = {1, 2, 3, 4, 5};
std::unordered_multiset&lt;int&gt; us2(us1);  // us2 是 us1 的一个复制版本
</code></pre>
</li>
<li>
<p><code>unordered_multiset(begin, end)</code>：使用另一个容器或迭代器区间中的元素初始化 <code>std::unordered_multiset</code>。</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
std::unordered_multiset&lt;int&gt; us(vec.begin(), vec.end());  // 复制 vector 的元素到 unordered_multiset
</code></pre>
</li>
</ol>
<h3 id="2-大小函数-8"><a class="header" href="#2-大小函数-8">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>：返回 <code>std::unordered_multiset</code> 中元素的个数。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us = {1, 2, 3, 4};
std::cout &lt;&lt; us.size();  // 输出 4
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>：检查 <code>std::unordered_multiset</code> 是否为空，若为空返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us;
if (us.empty()) {
    std::cout &lt;&lt; "Unordered Multiset is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>size_t max_size() const</code>：返回最大可允许的 <code>unordered_multiset</code> 元素数量。</p>
</li>
<li>
<p><code>void reserve(size_t n)</code>：用于预先分配哈希表的桶数量。这可以有效减少动态扩容的开销，特别是在你知道将要插入大量元素时。</p>
</li>
</ol>
<h3 id="3-增加函数-8"><a class="header" href="#3-增加函数-8">(3) 增加函数</a></h3>
<ol>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert(const T&amp; value)</code>：插入元素到 <code>unordered_multiset</code> 中，返回一个 <code>pair</code>，其中 <code>first</code> 是指向插入元素所在位置的迭代器，<code>second</code> 是插入是否成功（如果存在重复元素，则插入成功并增加该元素的数量）。</p>
<pre><code class="language-cpp">us.insert({1, 2, 3});  // 插入多个元素
us.insert(us.begin(), 42);  // 带 hint 的插入
us.insert(vec.begin(), vec.end());  // 区间插入
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; emplace(_Args&amp;&amp;... args)</code>：就地构建并插入元素。</p>
</li>
<li>
<p><code>iterator emplace_hint(const_iterator hint, _Args&amp;&amp;... args)</code>：就地构建并插入元素，并指定插入位置。与 <code>insert</code> 一样，最坏情况下会发生重排序。在哈希索引的前提下是无序的，因此该插入操作等效于<code>insert</code>。</p>
</li>
</ol>
<h3 id="4-删除元素-4"><a class="header" href="#4-删除元素-4">(4) 删除元素</a></h3>
<ol>
<li>
<p><code>void clear()</code>：删除 <code>std::unordered_multiset</code> 中的所有元素，使容器变为空。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us = {1, 2, 3, 4};
us.clear();  // 删除所有元素，us 变为空 {}
</code></pre>
</li>
<li>
<p><code>void erase(iterator pos)</code>：删除指定位置 <code>pos</code> 处的元素。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us = {1, 2, 3, 4};
us.erase(std::next(us.begin(), 2));  // 删除索引为2的元素，us 变为 {1, 2, 4}
</code></pre>
</li>
<li>
<p><code>size_t erase(const key_type&amp; key)</code>：删除指定键的元素并返回删除的数量，注意一个键可能有多个副本，因此返回的数量可能大于 1。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us = {1, 2, 2, 3, 4};
us.erase(2);  // 删除所有值为 2 的元素，us 变为 {1, 3, 4}
</code></pre>
</li>
<li>
<p><code>erase(first, last)</code>：删除指定范围的元素。</p>
</li>
</ol>
<h3 id="5-查找函数-4"><a class="header" href="#5-查找函数-4">(5) 查找函数</a></h3>
<ol>
<li>
<p><code>iterator find(const T&amp; value)</code>：查找某元素在 <code>unordered_multiset</code> 中的位置，返回一个指向该元素的迭代器。如果找不到会返回 <code>end()</code>。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us = {1, 2, 3, 4};
auto it = us.find(1);  // 返回指向键1的迭代器
if (it != us.end()) {
    std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 输出: 1
}
</code></pre>
</li>
<li>
<p><code>std::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; __x) const</code>：返回一个迭代器对，表示所有具有等于 <code>x</code> 的键的元素的范围。由于 <code>unordered_multiset</code> 允许重复元素，这个范围包含所有相同的键。</p>
</li>
<li>
<p><code>size_t count(const T&amp; value)</code>：返回指定元素在 <code>unordered_multiset</code> 中出现的次数。对于 <code>unordered_multiset</code>，返回的次数可能大于 1，因为允许重复元素。</p>
</li>
<li>
<p><code>bool contains(const T&amp; value) const</code>（C++20）：检查是否包含该元素。</p>
</li>
</ol>
<h3 id="6-遍历函数-5"><a class="header" href="#6-遍历函数-5">(6) 遍历函数</a></h3>
<ol>
<li>
<p><code>iterator begin()</code>：返回指向 <code>std::unordered_multiset</code> 第一个元素的迭代器。</p>
</li>
<li>
<p><code>iterator end()</code>：返回指向 <code>std::unordered_multiset</code> 最后一个元素之后位置的迭代器。</p>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 直接遍历 <code>std::unordered_multiset</code> 中的每个元素。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us = {1, 2, 2, 3};
for (const int&amp; num : us) {
    std::cout &lt;&lt; num &lt;&lt; " ";  // 输出: 1 2 2 3
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）: 使用迭代器来遍历 <code>std::unordered_multiset</code>。</p>
<pre><code class="language-cpp">std::unordered_multiset&lt;int&gt; us = {1, 2, 2, 3};
for (auto it = us.begin(); it != us.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";  // 输出: 1 2 2 3
}
</code></pre>
</li>
</ol>
<h3 id="7-哈希相关函数"><a class="header" href="#7-哈希相关函数">(7) 哈希相关函数</a></h3>
<ol>
<li>
<p><code>size_type max_bucket_count() const noexcept</code>：返回 <code>unordered_multiset</code> 中可用的最大哈希桶数量。</p>
</li>
<li>
<p><code>float max_load_factor() const noexcept</code>：返回或设置哈希表的最大负载因子。</p>
</li>
<li>
<p><code>void max_load_factor(float __z)</code>：设置最大负载因子。</p>
</li>
<li>
<p><code>size_t bucket_count() const</code>：返回当前 <code>unordered_multiset</code> 的桶数量。</p>
</li>
<li>
<p><code>size_t bucket_size(size_t n) const</code>：返回指定桶的元素数量。</p>
</li>
<li>
<p><code>size_t bucket(const key_type&amp; key) const</code>：返回给定键所在的桶的索引。</p>
</li>
<li>
<p><code>float load_factor() const</code>：返回当前哈希表的负载因子。</p>
</li>
<li>
<p><code>void rehash(size_t n)</code>：用来调整哈希表中的桶数量。</p>
</li>
</ol>
<h3 id="8-其他函数-1"><a class="header" href="#8-其他函数-1">(8) 其他函数</a></h3>
<ol>
<li>
<p><code>swap(unordered_multiset&amp; other)</code>：交换当前 <code>unordered_multiset</code> 和另一个 <code>unordered_multiset</code> 的内容。</p>
</li>
<li>
<p><code>std::allocator&lt;T&gt; get_allocator() const</code>：返回容器所使用的分配器（allocator）。</p>
</li>
<li>
<p><code>void merge(unordered_multiset&amp; other)</code>：合并另一个 <code>unordered_multiset</code> 中不重复的元素。</p>
</li>
<li>
<p><code>key_equal_type key_eq() const</code>：返回一个比较器，用于判断两个键是否相等。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdunordered_map"><a class="header" href="#stdunordered_map">std::unordered_map</a></h1>
<p><code>std::unordered_map</code> 是 C++ 标准库中的一个无序关联容器，用于存储键值对（<code>key-value</code>）。与 <code>std::map</code> 不同的是，<code>unordered_map</code> 内部使用 <strong>哈希表</strong> 来组织元素，因此元素的顺序不固定，完全由哈希函数决定。
它能在平均 <strong>O(1)</strong> 时间内完成查找、插入和删除操作（最坏情况下退化为 O(n)）。</p>
<p><code>unordered_map</code> 的定义如下：</p>
<pre><code class="language-cpp">template&lt;
    class Key,
    class T,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;
&gt; class unordered_map; // since C++11
</code></pre>
<pre><code class="language-cpp">namespace pmr {
    template&lt;
        class Key,
        class T,
        class Hash = std::hash&lt;Key&gt;,
        class KeyEqual = std::equal_to&lt;Key&gt;
    &gt; using unordered_map =
          std::unordered_map&lt;Key, T, Hash, KeyEqual,
              std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;;
} // since C++17
</code></pre>
<ul>
<li>Key：键的类型（必须支持哈希和比较相等操作）。</li>
<li>T：映射值的类型。</li>
<li>Hash：哈希函数对象，默认为 <code>std::hash&lt;Key&gt;</code>。</li>
<li>Pred：相等比较函数对象，默认为 <code>std::equal_to&lt;Key&gt;</code>。</li>
<li>Alloc：分配器类型，默认为 <code>std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;</code>。</li>
</ul>
<h2 id="1-引入-15"><a class="header" href="#1-引入-15">1. 引入</a></h2>
<pre><code class="language-cpp">#include &lt;unordered_map&gt;
</code></pre>
<h2 id="2-存储方式-12"><a class="header" href="#2-存储方式-12">2. 存储方式</a></h2>
<ul>
<li><code>std::map</code> 使用 <strong>红黑树</strong>，有序，查找/插入/删除是 O(log n)。</li>
<li><code>std::unordered_map</code> 使用 <strong>哈希表</strong>，无序，查找/插入/删除平均是 O(1)，但在哈希冲突严重时，最坏情况可能退化为 O(n)。</li>
</ul>
<p>每个键值对通过哈希函数映射到某个 <strong>桶（bucket）</strong> 中，冲突时使用链表或开链方式解决。
键必须唯一，如果插入相同的键，新值会覆盖旧值。</p>
<h2 id="3-方法-12"><a class="header" href="#3-方法-12">3. 方法</a></h2>
<h3 id="1-构造方法-8"><a class="header" href="#1-构造方法-8">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>unordered_map()</code>: 默认构造函数</p>
<pre><code class="language-cpp">std::unordered_map&lt;int, std::string&gt; m;
std::unordered_map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
</code></pre>
</li>
<li>
<p><code>unordered_map(const unordered_map&amp;)</code>: 复制构造函数</p>
<pre><code class="language-cpp">std::unordered_map&lt;int, std::string&gt; m1 = {{1, "one"}, {2, "two"}};
std::unordered_map&lt;int, std::string&gt; m2(m1);
</code></pre>
</li>
<li>
<p><code>unordered_map(begin, end)</code>: 使用另一个容器或迭代器的区间中的元素初始化</p>
<pre><code class="language-cpp">std::vector&lt;std::pair&lt;int, std::string&gt;&gt; vec = {{1, "one"}, {2, "two"}};
std::unordered_map&lt;int, std::string&gt; m(vec.begin(), vec.end());
</code></pre>
</li>
<li>
<p><code>std::unordered_map&lt;key, T, Compare&gt;</code>: 使用自定义的比较器来进行键的排序</p>
<pre><code class="language-cpp">struct MyHash {
    size_t operator()(int x) const { return x % 10; }
};
std::unordered_map&lt;int, std::string, MyHash&gt; m;
</code></pre>
</li>
</ol>
<h3 id="2-大小函数-9"><a class="header" href="#2-大小函数-9">(2) 大小函数</a></h3>
<ol>
<li><code>size_t size() const</code>： 返回元素个数</li>
<li><code>bool empty() const</code>： 是否为空</li>
<li><code>size_t max_size() const</code>： 返回最大可允许元素数量</li>
<li><code>void reserve(size_type __n)</code>： 预分配桶的数量，减少扩容开销</li>
</ol>
<h3 id="3-增加函数-9"><a class="header" href="#3-增加函数-9">(3) 增加函数</a></h3>
<ol>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert(const value_type&amp; __x)</code>: 插入一个键值对，返回保存指向添加键值对位置的迭代器和是否添加成功的标志的pair</p>
<pre><code class="language-cpp">m.insert({1, "one"});
m.insert(std::make_pair(2, "two"));
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; emplace(Key&amp;&amp; key, T&amp;&amp; obj)</code>: 如果键 key 不存在，就直接插入一个新元素。</p>
<pre><code class="language-cpp">m.emplace(3, "three");
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; try_emplace(const Key&amp; key, Args&amp;&amp;... args)</code>: 只有在 key 不存在时，才插入新元素（避免额外的拷贝）。</p>
<pre><code class="language-cpp">m.try_emplace(1, "one");
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert_or_assign(const Key&amp; key, T&amp;&amp; obj)</code></p>
<pre><code class="language-cpp">m.insert_or_assign(1, "uno");
</code></pre>
</li>
<li>
<p><code>operator[](const Key&amp; key)</code>: 如果 key 存在，返回对应的值；如果 key 不存在，插入一个新的键值对，值为默认构造的类型 T。</p>
<pre><code class="language-cpp">m[4] = "four";   // 插入
m[1] = "uno";    // 更新
</code></pre>
</li>
<li>
<p><code>at(const Key&amp; key)</code>：如果 key 已存在，更新对应的值；如果 key 不存在，插入一个新的键值对。</p>
<pre><code class="language-cpp">std::cout &lt;&lt; m.at(1);
</code></pre>
</li>
</ol>
<h3 id="4-删除元素-5"><a class="header" href="#4-删除元素-5">(4) 删除元素</a></h3>
<ol>
<li><code>void clear()</code>：清空所有元素</li>
<li><code>iterator erase(iterator pos)</code>：删除迭代器位置的元素</li>
<li><code>iterator erase(const key_type&amp; key)</code>：删除指定键，返回删除个数</li>
<li><code>iterator erase(first, last)</code>：删除范围</li>
</ol>
<h3 id="5-查找函数-5"><a class="header" href="#5-查找函数-5">(5) 查找函数</a></h3>
<ol>
<li>
<p><code>iterator find(const key_type&amp; key)</code>: 查找某个键在 <code>unordered_map</code> 中的位置，返回一个指向该元素的迭代器，如果找不到会返回 <code>end()</code>。</p>
<pre><code class="language-cpp">std::unordered_map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
auto it = m.find(1);  // 返回指向键1的迭代器
std::cout &lt;&lt; it-&gt;second;  // 输出 "one"
</code></pre>
</li>
<li>
<p><code>std::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; key) const</code>: 返回一对迭代器，表示所有具有等于键 <code>key</code> 的元素的范围。在 <code>std::unordered_map</code> 中，由于键是唯一的，因此这个范围包含一个元素。</p>
<pre><code class="language-cpp">std::unordered_map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
auto range = m.equal_range(1);
std::cout &lt;&lt; range.first-&gt;second &lt;&lt; std::endl;  // 输出 "one"
</code></pre>
</li>
<li>
<p><code>size_t count(const key_type&amp; key)</code>: 返回容器中是否包含指定键，<code>unordered_map</code> 中每个键最多出现一次，因此返回值要么是 <code>0</code>，要么是 <code>1</code>。</p>
</li>
<li>
<p><code>iterator lower_bound(const key_type&amp; key)</code>: 返回第一个不小于 <code>key</code> 的迭代器。</p>
</li>
<li>
<p><code>iterator upper_bound(const key_type&amp; key)</code>: 返回第一个大于 <code>key</code> 的迭代器。</p>
</li>
<li>
<p><code>bool contains(const key_type&amp; key) const</code>（C++20）：检查是否包含该键。</p>
</li>
</ol>
<h3 id="6-遍历函数-6"><a class="header" href="#6-遍历函数-6">(6) 遍历函数</a></h3>
<ol>
<li>
<p><code>iterator begin()</code>: 返回指向 <code>std::unordered_map</code> 第一个元素的迭代器。</p>
<pre><code class="language-cpp">std::unordered_map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
auto it = m.begin();  // 返回指向第一个元素的迭代器
std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; std::endl;  // 输出 1: one
</code></pre>
</li>
<li>
<p><code>iterator end()</code>: 返回指向 <code>std::unordered_map</code> 最后一个元素之后位置的迭代器。</p>
</li>
<li>
<p><code>reverse_iterator rbegin()</code>: 返回指向 <code>std::unordered_map</code> 最后一个元素的反向迭代器。</p>
</li>
<li>
<p><code>reverse_iterator rend()</code>: 返回指向 <code>std::unordered_map</code> 第一个元素之前位置的反向迭代器。</p>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环（C++11 及以上）: 直接遍历 <code>std::unordered_map</code> 中的每个元素。</p>
<pre><code class="language-cpp">std::unordered_map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
for (const auto&amp; pair : m) {
    std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; " ";  // 输出: 1: one 2: two
}
</code></pre>
</li>
<li>
<p>使用传统的 <code>for</code> 循环（基于迭代器）: 使用迭代器来遍历 <code>std::unordered_map</code>。</p>
<pre><code class="language-cpp">std::unordered_map&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
for (auto it = m.begin(); it != m.end(); ++it) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; " ";  // 输出: 1: one 2: two
}
</code></pre>
</li>
</ol>
<h3 id="7-哈希相关函数-1"><a class="header" href="#7-哈希相关函数-1">(7) 哈希相关函数</a></h3>
<ol>
<li>
<p><code>size_type max_bucket_count() const noexcept</code>: max_bucket_count() 返回 std::unordered_set 中可用的最大哈希桶数量。哈希表是由一组桶（bucket）构成的，每个桶存储一定数量的元素。当元素的数量增加时，std::unordered_set 可能会自动扩展桶的数量，以减少哈希冲突。max_bucket_count() 允许你查看哈希表最多能支持多少个桶。</p>
</li>
<li>
<p><code>float max_load_factor() const noexcept</code>: max_load_factor() 返回或设置哈希表的最大负载因子。负载因子是哈希表中元素的数量与桶数量之比。它决定了哈希表何时扩展——当负载因子超过最大值时，std::unordered_set 会增加桶的数量，减少哈希冲突，从而提高性能。</p>
<ul>
<li>负载因子是指：负载因子 = 元素个数 / 桶的数量</li>
<li>最大负载因子是哈希表在扩展之前允许的最大负载因子。负载因子越高，意味着桶的数量相对较少，这可能导致更多的哈希冲突，降低查找效率。</li>
</ul>
</li>
<li>
<p><code>void max_load_factor(float __z)</code>: 设置最大负载因子。</p>
</li>
<li>
<p><code>size_t bucket_count() const</code>: 返回当前 unordered_set 的桶数量。哈希表的桶数量与容器中元素的数量以及负载因子相关，通常哈希表会在元素数量增加时自动扩展桶的数量。</p>
</li>
<li>
<p><code>size_t bucket_size(size_t n) const</code>: 返回指定桶的元素数量。哈希表中的每个桶可能包含多个元素，特别是当哈希冲突发生时，多个元素可能会存储在同一个桶中。</p>
</li>
<li>
<p><code>size_t bucket(const key_type&amp; key) const</code>: 返回给定键所在的桶的索引。这个函数对于理解元素是如何分布在哈希表中的非常有用。</p>
</li>
<li>
<p><code>float load_factor() const</code>: 返回当前哈希表的负载因子，即元素的数量与桶数量的比值。负载因子越高，哈希冲突的可能性越大，因此负载因子对于性能非常重要。</p>
</li>
<li>
<p><code>void rehash(size_t n)</code>: 用来调整哈希表中的桶数量。它的作用是根据新的元素数量来调整桶的数量，避免哈希冲突过多。rehash() 会导致重新分配桶并重新哈希元素。n 是希望容器能够容纳的元素数量。</p>
</li>
</ol>
<h3 id="8-其他函数-2"><a class="header" href="#8-其他函数-2">(8) 其他函数</a></h3>
<ol>
<li>
<p><code>swap(unordered_map&amp; other)</code>: 交换当前 <code>std::unordered_map</code> 和另一个 <code>std::unordered_map</code> 的内容。</p>
</li>
<li>
<p><code>std::allocator&lt;T&gt; get_allocator() const</code>: 返回容器所使用的分配器（allocator）。</p>
</li>
<li>
<p><code>void merge(unordered_map&amp; other)</code>: <code>merge</code> 会将另一个 unordered_map 中不与当前容器重复的元素“移动”过来。</p>
<pre><code class="language-c++">std::unordered_map&lt;int&gt; s1 = {1, 3, 5};
std::unordered_map&lt;int&gt; s2 = {2, 4, 6};
s1.merge(s2);  // s1 合并 s2 后，变为 {1, 2, 3, 4, 5, 6}
</code></pre>
</li>
<li>
<p><code>key_equal_type key_eq() const</code>： 返回一个比较器，用于判断两个键是否相等</p>
<pre><code class="language-cpp">std::unordered_map&lt;Person, PersonHash&gt; people;

Person p1 = {"Alice", 30};
Person p2 = {"Bob", 25};
people.insert(p1);
people.insert(p2);

// 使用 key_eq 获取比较函数
auto eq = people.key_eq();

// 使用 key_eq 函数比较两个键
std::cout &lt;&lt; "Are p1 and p2 equal? " &lt;&lt; std::boolalpha &lt;&lt; eq(p1, p2) &lt;&lt; std::endl;
</code></pre>
</li>
<li>
<p><code>hasher hash_function() const</code>：返回当前使用的哈希函数对象</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdunordered_multimap"><a class="header" href="#stdunordered_multimap">std::unordered_multimap</a></h1>
<p><code>std::unordered_multimap</code> 是 C++ 标准库中的一个无序关联容器，存储一组键值对（<code>key-value</code>）。与 <code>std::unordered_map</code> 类似，<code>std::unordered_multimap</code> 也使用 <strong>哈希表</strong> 来组织元素，但不同的是，它允许 <strong>键重复</strong>。
由于其底层实现为哈希表，元素顺序并不固定，完全由哈希函数决定。平均查找、插入、删除的时间复杂度为 O(1)，最坏情况下会退化为 O(n)。</p>
<p><code>std::unordered_multimap</code> 的定义如下：</p>
<pre><code class="language-cpp">template&lt;
    class Key,
    class T,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;
&gt; class unordered_multimap; // since C++11
</code></pre>
<pre><code class="language-cpp">namespace pmr {
    template&lt;
        class Key,
        class T,
        class Hash = std::hash&lt;Key&gt;,
        class Pred = std::equal_to&lt;Key&gt;
    &gt; using unordered_multimap =
          std::unordered_multimap&lt;Key, T, Hash, Pred,
              std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;;
} // since C++17
</code></pre>
<ul>
<li>Key：键的类型（必须支持哈希和比较相等操作）。</li>
<li>T：映射值的类型。</li>
<li>Hash：哈希函数对象，默认为 <code>std::hash&lt;Key&gt;</code>。</li>
<li>Pred：相等比较函数对象，默认为 <code>std::equal_to&lt;Key&gt;</code>。</li>
<li>Alloc：分配器类型，默认为 <code>std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;</code>。</li>
</ul>
<h2 id="1-引入-16"><a class="header" href="#1-引入-16">1. 引入</a></h2>
<pre><code class="language-cpp">#include &lt;unordered_map&gt;
</code></pre>
<h2 id="2-存储方式-13"><a class="header" href="#2-存储方式-13">2. 存储方式</a></h2>
<ul>
<li><code>std::unordered_multimap</code> 底层使用 <strong>哈希表</strong> 来存储元素，每个元素（键值对）会根据其 <strong>键</strong> 被哈希到一个桶中。</li>
<li><strong>键的唯一性</strong>：与 <code>std::unordered_map</code> 不同，<code>std::unordered_multimap</code> 允许 <strong>多个相同的键</strong> 存在，每个键对应多个值。相同键的元素会存储在同一个桶中。</li>
<li><strong>插入与查找</strong>：所有操作（查找、插入、删除）平均时间复杂度为 <strong>O(1)</strong>，但在哈希冲突严重时，最坏情况可能退化为 <strong>O(n)</strong>。</li>
</ul>
<h2 id="3-方法-13"><a class="header" href="#3-方法-13">3. 方法</a></h2>
<h3 id="1-构造方法-9"><a class="header" href="#1-构造方法-9">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>unordered_multimap()</code>: 默认构造函数</p>
<pre><code class="language-cpp">std::unordered_multimap&lt;int, std::string&gt; m;
std::unordered_multimap&lt;int, std::string&gt; m = {{1, "one"}, {2, "two"}};
</code></pre>
</li>
<li>
<p><code>unordered_multimap(const unordered_multimap&amp;)</code>: 复制构造函数</p>
<pre><code class="language-cpp">std::unordered_multimap&lt;int, std::string&gt; m1 = {{1, "one"}, {2, "two"}};
std::unordered_multimap&lt;int, std::string&gt; m2(m1);
</code></pre>
</li>
<li>
<p><code>unordered_multimap(begin, end)</code>: 使用另一个容器或迭代器的区间中的元素初始化</p>
<pre><code class="language-cpp">std::vector&lt;std::pair&lt;int, std::string&gt;&gt; vec = {{1, "one"}, {2, "two"}};
std::unordered_multimap&lt;int, std::string&gt; m(vec.begin(), vec.end());
</code></pre>
</li>
<li>
<p><code>std::unordered_multimap&lt;key, T, Hash&gt;</code>: 使用自定义的哈希函数</p>
<pre><code class="language-cpp">struct MyHash {
    size_t operator()(int x) const { return x % 10; }
};
std::unordered_multimap&lt;int, std::string, MyHash&gt; m;
</code></pre>
</li>
</ol>
<h3 id="2-大小函数-10"><a class="header" href="#2-大小函数-10">(2) 大小函数</a></h3>
<ol>
<li><code>size_t size() const</code>: 返回元素个数</li>
<li><code>bool empty() const</code>: 是否为空</li>
<li><code>size_t max_size() const</code>: 返回最大可允许元素数量</li>
<li><code>void reserve(size_type __n)</code>: 预分配桶的数量，减少扩容开销</li>
</ol>
<h3 id="3-插入函数"><a class="header" href="#3-插入函数">(3) 插入函数</a></h3>
<ol>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert(const value_type&amp; __x)</code>: 插入一个键值对，返回保存指向添加键值对位置的迭代器和是否添加成功的标志的pair</p>
<pre><code class="language-cpp">m.insert({1, "one"});
m.insert(std::make_pair(2, "two"));
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; emplace(Key&amp;&amp; key, T&amp;&amp; obj)</code>: 如果键 <code>key</code> 不存在，就直接插入一个新元素。</p>
<pre><code class="language-cpp">m.emplace(3, "three");
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; try_emplace(const Key&amp; key, Args&amp;&amp;... args)</code>: 只有在 <code>key</code> 不存在时，才插入新元素（避免额外的拷贝）。</p>
<pre><code class="language-cpp">m.try_emplace(1, "one");
</code></pre>
</li>
<li>
<p><code>std::pair&lt;iterator, bool&gt; insert_or_assign(const Key&amp; key, T&amp;&amp; obj)</code>: 如果 <code>key</code> 存在，更新对应的值；如果 <code>key</code> 不存在，插入一个新的键值对。</p>
<pre><code class="language-cpp">m.insert_or_assign(1, "uno");
</code></pre>
</li>
<li>
<p><code>operator[](const Key&amp; key)</code>: 如果 <code>key</code> 存在，返回对应的值；如果 <code>key</code> 不存在，插入一个新的键值对，值为默认构造的类型 T。</p>
<pre><code class="language-cpp">m[4] = "four";   // 插入
m[1] = "uno";    // 更新
</code></pre>
</li>
<li>
<p><code>at(const Key&amp; key)</code>: 如果 <code>key</code> 已存在，返回对应的值；如果 <code>key</code> 不存在，抛出 <code>std::out_of_range</code>。</p>
<pre><code class="language-cpp">std::cout &lt;&lt; m.at(1);  // 输出值
</code></pre>
</li>
</ol>
<h3 id="4-删除元素-6"><a class="header" href="#4-删除元素-6">(4) 删除元素</a></h3>
<ol>
<li>
<p><code>void clear()</code>: 清空所有元素</p>
</li>
<li>
<p><code>iterator erase(iterator pos)</code>: 删除迭代器位置的元素</p>
</li>
<li>
<p><code>size_t erase(const key_type&amp; key)</code>: 删除指定键的所有元素，返回删除的数量</p>
<pre><code class="language-cpp">m.erase(1);  // 删除键为1的所有元素
</code></pre>
</li>
<li>
<p><code>iterator erase(first, last)</code>: 删除指定迭代器区间的元素</p>
</li>
</ol>
<h3 id="5-查找函数-6"><a class="header" href="#5-查找函数-6">(5) 查找函数</a></h3>
<ol>
<li>
<p><code>iterator find(const key_type&amp; key)</code>: 查找指定键的第一个匹配元素，返回一个指向该元素的迭代器，如果找不到返回 <code>end()</code>。</p>
<pre><code class="language-cpp">auto it = m.find(2);
if (it != m.end()) {
    std::cout &lt;&lt; it-&gt;second &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>std::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; key) const</code>: 返回一对迭代器，表示所有具有等于键 <code>key</code> 的元素的范围。</p>
<pre><code class="language-cpp">auto range = m.equal_range(2);
for (auto it = range.first; it != range.second; ++it) {
    std::cout &lt;&lt; it-&gt;second &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p><code>size_t count(const key_type&amp; key)</code>: 返回容器中指定键的元素数量（对于 <code>unordered_multimap</code>，返回值可能大于 1）。</p>
<pre><code class="language-cpp">size_t n = m.count(2);  // 返回键2的数量
</code></pre>
</li>
<li>
<p><code>bool contains(const key_type&amp; key) const</code>（C++20）：检查是否包含指定键。</p>
<pre><code class="language-cpp">if (m.contains(2)) {
    std::cout &lt;&lt; "Key 2 exists!" &lt;&lt; std::endl;
}
</code></pre>
</li>
</ol>
<h3 id="6-遍历函数-7"><a class="header" href="#6-遍历函数-7">(6) 遍历函数</a></h3>
<ol>
<li>
<p><code>iterator begin()</code>: 返回指向容器第一个元素的迭代器</p>
<pre><code class="language-cpp">auto it = m.begin();
std::cout &lt;&lt; it-&gt;first &lt;&lt; " -&gt; " &lt;&lt; it-&gt;second &lt;&lt; std::endl;
</code></pre>
</li>
<li>
<p><code>iterator end()</code>: 返回指向容器最后一个元素之后位置的迭代器</p>
</li>
<li>
<p><code>reverse_iterator rbegin()</code>: 返回指向容器最后一个元素的反向迭代器</p>
</li>
<li>
<p><code>reverse_iterator rend()</code>: 返回指向容器第一个元素之前位置的反向迭代器</p>
</li>
<li>
<p>使用基于范围的 <code>for</code> 循环：</p>
<pre><code class="language-cpp">for (const auto&amp; [key, value] : m) {
    std::cout &lt;&lt; key &lt;&lt; " -&gt; " &lt;&lt; value &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p>使用传统的迭代器遍历：</p>
<pre><code class="language-cpp">for (auto it = m.begin(); it != m.end(); ++it) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; " -&gt; " &lt;&lt; it-&gt;second &lt;&lt; std::endl;
}
</code></pre>
</li>
</ol>
<h3 id="7-哈希相关函数-2"><a class="header" href="#7-哈希相关函数-2">(7) 哈希相关函数</a></h3>
<ol>
<li><code>size_t bucket_count() const</code>: 返回桶的数量</li>
<li><code>size_t bucket_size(size_t n) const</code>: 返回指定桶的元素数量</li>
<li><code>size_t bucket(const key_type&amp; key) const</code>: 返回给定键所落入的桶的索引</li>
<li><code>float load_factor() const</code>: 返回当前负载因子（元素数 / 桶数）</li>
<li><code>void rehash(size_t n)</code>: 强制调整桶的数量，避免哈希冲突</li>
<li><code>void reserve(size_t n)</code>: 确保容器至少可以容纳 <code>n</code> 个元素</li>
</ol>
<h3 id="8-其他函数-3"><a class="header" href="#8-其他函数-3">(8) 其他函数</a></h3>
<ol>
<li><code>swap(unordered_multimap&amp; other)</code>: 交换当前 <code>unordered_multimap</code> 和另一个容器的内容</li>
<li><code>std::allocator&lt;T&gt; get_allocator() const</code>: 返回容器的分配器</li>
<li><code>void merge(unordered_multimap&amp; other)</code>: 将另一个 <code>unordered_multimap</code> 中不重复的元素“移动”过来（C++17）</li>
<li><code>hasher hash_function() const</code>: 返回当前使用的哈希函数</li>
<li><code>key_equal_type key_eq() const</code>: 返回用于判断键是否相等的谓词</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdstack"><a class="header" href="#stdstack">std::stack</a></h1>
<p><code>std::stack</code> (栈) 是一个<strong>容器适配器 (Container Adapter)</strong>，它不是一个独立的容器，而是对现有顺序容器（如 <code>std::deque</code>、<code>std::list</code> 或 <code>std::vector</code>）的封装，限制了对其元素的访问，使其遵循 <strong>LIFO (Last-In, First-Out)</strong> 的数据结构规则。</p>
<p>想象一下堆叠起来的盘子，你只能在<strong>顶部</strong>放一个新盘子，也只能从<strong>顶部</strong>取走盘子。在 <code>std::stack</code> 中，这个“顶部”对应于底层容器的<strong>尾部</strong>。</p>
<h2 id="1-引入-17"><a class="header" href="#1-引入-17">1. 引入</a></h2>
<pre><code class="language-c++">#include &lt;stack&gt;
</code></pre>
<h2 id="2-存储方式-14"><a class="header" href="#2-存储方式-14">2. 存储方式</a></h2>
<p><code>std::stack</code> 通过封装一个<strong>底层容器 (Underlying Container)</strong> 来存储数据。它只暴露了符合栈（LIFO）操作的方法，例如：</p>
<ul>
<li><strong>推入 (Push)：</strong> 插入元素到栈顶（对应底层容器的 <code>push_back()</code>）。</li>
<li><strong>弹出 (Pop)：</strong> 移除栈顶元素（对应底层容器的 <code>pop_back()</code>）。</li>
<li><strong>查看 (Top)：</strong> 访问栈顶元素（对应底层容器的 <code>back()</code>）。</li>
</ul>
<p><strong>默认底层容器</strong>：如果创建 <code>std::stack</code> 时不指定底层容器，它默认使用 <strong><code>std::deque&lt;T&gt;</code></strong>。</p>
<p><strong>可选底层容器</strong>：任何满足 LIFO 访问要求的顺序容器都可以作为底层容器，包括：</p>
<ol>
<li><strong><code>std::deque&lt;T&gt;</code> (默认)</strong>：通常是栈操作的最佳选择，因为它在两端操作（<code>push_front/pop_front</code> 和 <code>push_back/pop_back</code>）都很快。</li>
<li><strong><code>std::vector&lt;T&gt;</code></strong>：如果内存是连续的且不需要在底部（前端）操作，这也是一个高效的选择。</li>
<li><strong><code>std::list&lt;T&gt;</code></strong>：如果需要存储不支持连续存储或拷贝构造/赋值操作的复杂对象，可以使用它。</li>
</ol>
<p><strong>声明带指定底层容器的栈：</strong></p>
<pre><code class="language-c++">// 使用 vector 作为底层容器
std::stack&lt;int, std::vector&lt;int&gt;&gt; stack_vec;

// 使用 list 作为底层容器
std::stack&lt;int, std::list&lt;int&gt;&gt; stack_list;
</code></pre>
<h2 id="3-方法-14"><a class="header" href="#3-方法-14">3. 方法</a></h2>
<p>由于 <code>std::stack</code> 是一个适配器，它不提供任何迭代器（如 <code>begin()</code>/<code>end()</code>），也不支持随机访问（如 <code>operator[]</code>），只能通过 LIFO 接口进行操作。</p>
<h3 id="1-构造方法-10"><a class="header" href="#1-构造方法-10">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>stack()</code>: 创建一个空的 <code>std::stack</code>。</p>
<pre><code class="language-c++">std::stack&lt;int&gt; s; // 使用默认的 std::deque 作为底层容器
</code></pre>
</li>
<li>
<p><code>stack(const Container&amp; cont)</code>: 使用一个已存在的底层容器副本进行初始化。</p>
<pre><code class="language-c++">std::deque&lt;int&gt; d = {1, 2, 3};
std::stack&lt;int&gt; s(d);  // s 变为 {1, 2, 3} (1 是底，3 是顶)
</code></pre>
</li>
<li>
<p><code>stack(const stack&amp;)</code>: 复制构造函数。</p>
</li>
</ol>
<h3 id="2-大小函数-11"><a class="header" href="#2-大小函数-11">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>: 返回 <code>std::stack</code> 中元素的个数。</p>
<pre><code class="language-c++">std::stack&lt;int&gt; s = {1, 2, 3};
std::cout &lt;&lt; s.size();  // 输出 3
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>: 检查 <code>std::stack</code> 是否为空。若为空返回 <code>true</code>。</p>
<pre><code class="language-c++">std::stack&lt;int&gt; s;
if (s.empty()) {
    std::cout &lt;&lt; "Stack is empty." &lt;&lt; std::endl;
}
</code></pre>
</li>
</ol>
<h3 id="3-元素访问函数"><a class="header" href="#3-元素访问函数">(3) 元素访问函数</a></h3>
<p><code>std::stack</code> <strong>只允许访问顶部元素</strong>。</p>
<ol>
<li>
<p><code>reference top()</code>: 返回栈顶元素（即最近 <code>push</code> 进去的元素）的引用。调用前<strong>必须</strong>确保栈不为空。</p>
<pre><code class="language-c++">std::stack&lt;int&gt; s;
s.push(10);
s.push(20);
std::cout &lt;&lt; s.top(); // 输出 20
</code></pre>
</li>
</ol>
<h3 id="4-增加函数-推入"><a class="header" href="#4-增加函数-推入">(4) 增加函数 (推入)</a></h3>
<ol>
<li>
<p><code>void push(const T&amp; value)</code>: 将元素 <code>value</code> 复制或移动到栈的<strong>顶部</strong>。</p>
<pre><code class="language-c++">std::stack&lt;int&gt; s;
s.push(10); // 栈变为 {10}
s.push(20); // 栈变为 {10, 20} (20 在顶)
</code></pre>
</li>
<li>
<p><code>template&lt;class... Args&gt; void emplace(Args&amp;&amp;... args)</code>: 在栈的顶部<strong>就地构造</strong>一个元素，无需拷贝或移动。这是推荐的推入方式，尤其是对于复杂对象。</p>
<pre><code class="language-c++">std::stack&lt;std::pair&lt;int, int&gt;&gt; s;
s.emplace(1, 2); // 直接在栈顶构造 pair {1, 2}
</code></pre>
</li>
</ol>
<h3 id="5-删除函数-弹出"><a class="header" href="#5-删除函数-弹出">(5) 删除函数 (弹出)</a></h3>
<ol>
<li>
<p><code>void pop()</code>: 移除栈顶的元素。此函数<strong>不返回</strong>被移除的元素。调用前<strong>必须</strong>确保栈不为空。</p>
<pre><code class="language-c++">std::stack&lt;int&gt; s;
s.push(10);
s.push(20); // 栈为 {10, 20}
s.pop();    // 移除 20，栈变为 {10}
// 注意：要获取并移除元素，需要先调用 top()，再调用 pop()
</code></pre>
</li>
</ol>
<h3 id="6-其他函数-3"><a class="header" href="#6-其他函数-3">(6) 其他函数</a></h3>
<ol>
<li>
<p><code>void swap(stack&amp; other)</code>: 交换当前 <code>std::stack</code> 和另一个 <code>std::stack</code> 的内容。底层容器的内容也会随之交换。</p>
<pre><code class="language-c++">std::stack&lt;int&gt; s1; s1.push(1);
std::stack&lt;int&gt; s2; s2.push(2);
s1.swap(s2); // s1 变为 {2}，s2 变为 {1}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdqueue"><a class="header" href="#stdqueue">std::queue</a></h1>
<p><code>std::queue</code> (队列) 和 <code>std::stack</code> 类似，也是 C++ 标准库中的一个<strong>容器适配器 (Container Adapter)</strong>。它将底层容器的功能限制在一个特定的访问模式上，以实现 <strong>FIFO (First-In, First-Out，先进先出)</strong> 的数据结构。</p>
<p>想象一下排队等候的队伍：第一个进入队伍的人也是第一个离开队伍的人。在 <code>std::queue</code> 中，元素从尾部（Back）进入，从头部（Front）离开。</p>
<h2 id="1-引入-18"><a class="header" href="#1-引入-18">1. 引入</a></h2>
<pre><code class="language-cpp">#include &lt;queue&gt;
</code></pre>
<h2 id="2-存储方式与底层容器"><a class="header" href="#2-存储方式与底层容器">2. 存储方式与底层容器</a></h2>
<p><code>std::queue</code> 通过封装一个<strong>底层容器 (Underlying Container)</strong> 来存储数据。它只暴露了符合队列（FIFO）操作的方法：</p>
<ul>
<li><strong>入队 (Push)：</strong> 插入元素到队列的<strong>尾部</strong>（对应底层容器的 <code>push_back()</code>）。</li>
<li><strong>出队 (Pop)：</strong> 移除队列的<strong>头部</strong>元素（对应底层容器的 <code>pop_front()</code>）。</li>
<li><strong>查看 (Front/Back)：</strong> 访问头部/尾部元素。</li>
</ul>
<p><strong>默认底层容器</strong>：如果创建 <code>std::queue</code> 时不指定，它默认使用 <strong><code>std::deque&lt;T&gt;</code></strong>。</p>
<p><strong>可选底层容器</strong>：底层容器必须同时支持在头部（前端）移除元素（<code>pop_front()</code>）和在尾部（后端）添加元素（<code>push_back()</code>）。</p>
<p>满足这些要求的标准容器有：</p>
<ol>
<li><strong><code>std::deque&lt;T&gt;</code> (默认)</strong>：通常是最佳选择，因为它在两端操作（<code>push_back</code> 和 <code>pop_front</code>）都非常高效且 \(O(1)\)$。</li>
<li><strong><code>std::list&lt;T&gt;</code></strong>：如果元素类型不可复制，或者需要频繁地插入/删除，这也是一个合适的选择，操作复杂度也是 \(O(1)\)$。</li>
</ol>
<p>注意：<strong><code>std::vector&lt;T&gt;</code> 不能作为 <code>std::queue</code> 的底层容器</strong>，因为它不支持高效地从头部移除元素（<code>pop_front</code>），<code>std::vector</code> 的 <code>erase(begin())</code> 操作是 \(O(N)\) 的。</p>
<p><strong>声明带指定底层容器的队列：</strong></p>
<pre><code class="language-cpp">// 使用 list 作为底层容器
std::queue&lt;int, std::list&lt;int&gt;&gt; queue_list;

// 使用默认的 deque 作为底层容器
std::queue&lt;int&gt; queue_deque;
</code></pre>
<h2 id="3-常用方法-操作"><a class="header" href="#3-常用方法-操作">3. 常用方法 (操作)</a></h2>
<p><code>std::queue</code> 同样<strong>不提供迭代器</strong>，因此不能像 <code>std::vector</code> 或 <code>std::list</code> 那样遍历所有元素。</p>
<h3 id="1-构造方法-11"><a class="header" href="#1-构造方法-11">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>queue()</code>: 创建一个空的 <code>std::queue</code>。</p>
<pre><code class="language-cpp">std::queue&lt;int&gt; q;
</code></pre>
</li>
<li>
<p><code>queue(const Container&amp; cont)</code>: 使用一个已存在的底层容器副本进行初始化。</p>
<pre><code class="language-cpp">std::deque&lt;int&gt; d = {10, 20, 30}; // 10 是 front, 30 是 back
std::queue&lt;int&gt; q(d);             // q 变为 {10, 20, 30}
</code></pre>
</li>
</ol>
<h3 id="2-大小函数-12"><a class="header" href="#2-大小函数-12">(2) 大小函数</a></h3>
<ol>
<li><code>size_t size() const</code>: 返回 <code>std::queue</code> 中元素的个数。</li>
<li><code>bool empty() const</code>: 检查 <code>std::queue</code> 是否为空。若为空返回 <code>true</code>。</li>
</ol>
<h3 id="3-元素访问函数-1"><a class="header" href="#3-元素访问函数-1">(3) 元素访问函数</a></h3>
<p><code>std::queue</code> 允许访问队列的头部和尾部元素。</p>
<ol>
<li>
<p><code>reference front()</code>: 返回队列<strong>头部</strong>元素（即<strong>最先</strong>进入队列的元素）的引用。调用前<strong>必须</strong>确保队列不为空。</p>
</li>
<li>
<p><code>reference back()</code>: 返回队列<strong>尾部</strong>元素（即<strong>最近</strong>进入队列的元素）的引用。调用前<strong>必须</strong>确保队列不为空。</p>
<pre><code class="language-cpp">std::queue&lt;int&gt; q;
q.push(10); // q: {10}
q.push(20); // q: {10, 20}
std::cout &lt;&lt; q.front(); // 输出 10
std::cout &lt;&lt; q.back();  // 输出 20
</code></pre>
</li>
</ol>
<h3 id="4-增加函数-入队"><a class="header" href="#4-增加函数-入队">(4) 增加函数 (入队)</a></h3>
<ol>
<li>
<p><code>void push(const T&amp; value)</code>: 将元素 <code>value</code> 复制或移动到队列的<strong>尾部</strong>。</p>
</li>
<li>
<p><code>template&lt;class... Args&gt; void emplace(Args&amp;&amp;... args)</code>: 在队列的<strong>尾部</strong>就地构造一个元素。这是<strong>首选</strong>的入队方式。</p>
<pre><code class="language-cpp">std::queue&lt;std::string&gt; q;
q.push("Apple"); // 尾部插入
q.emplace("Banana"); // 尾部就地构造
</code></pre>
</li>
<li>
<p><code>template&lt;container-compatible-range R&gt; void push_range(R&amp;&amp; rg)</code> (C++23): 将一个范围（range）内的所有元素插入到队列的<strong>尾部</strong>。</p>
</li>
</ol>
<h3 id="5-删除函数-出队"><a class="header" href="#5-删除函数-出队">(5) 删除函数 (出队)</a></h3>
<ol>
<li>
<p><code>void pop()</code>: 移除队列<strong>头部</strong>的元素。此函数<strong>不返回</strong>被移除的元素。调用前<strong>必须</strong>确保队列不为空。</p>
<pre><code class="language-cpp">std::queue&lt;int&gt; q;
q.push(10);
q.push(20); // q: {10, 20}

// 要取出元素 10，需要两步操作：
int oldest = q.front(); // 访问头部 (10)
q.pop();                // 移除头部 (10)，q 变为 {20}
</code></pre>
</li>
</ol>
<h3 id="6-交换"><a class="header" href="#6-交换">(6) 交换</a></h3>
<ol>
<li><code>void swap(queue&amp; other)</code>: 交换两个 <code>std::queue</code> 的内容。</li>
</ol>
<h2 id="4-示例-fifo-原则"><a class="header" href="#4-示例-fifo-原则">4. 示例 (FIFO 原则)</a></h2>
<p>通过一个简单的例子来演示 <strong>FIFO</strong> 的工作原理：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
    std::queue&lt;int&gt; my_queue;

    // 入队 (Enroll)
    my_queue.push(100); // 100 先进
    my_queue.push(200);
    my_queue.push(300); // 300 后进

    std::cout &lt;&lt; "队列头部 (Front/First-in): " &lt;&lt; my_queue.front() &lt;&lt; std::endl; // 输出 100
    std::cout &lt;&lt; "队列尾部 (Back/Last-in): " &lt;&lt; my_queue.back() &lt;&lt; std::endl;   // 输出 300

    std::cout &lt;&lt; "--------------------" &lt;&lt; std::endl;

    // 出队 (Serve)
    while (!my_queue.empty()) {
        std::cout &lt;&lt; "服务并移除: " &lt;&lt; my_queue.front() &lt;&lt; std::endl;
        my_queue.pop();
    }

    // 元素的移除顺序为 100, 200, 300，严格遵循先进先出。
    return 0;
}
</code></pre>
<p><strong>输出:</strong></p>
<pre><code class="language-text">队列头部 (Front/First-in): 100
队列尾部 (Back/Last-in): 300
--------------------
服务并移除: 100
服务并移除: 200
服务并移除: 300
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdpriority_queue"><a class="header" href="#stdpriority_queue">std::priority_queue</a></h1>
<p><code>std::priority_queue</code> 是一个 <strong>容器适配器 (Container Adapter)</strong>，它基于堆 (heap) 实现，能够在对数时间内插入元素，并且始终允许在常数时间内访问到“优先级最高”的元素。</p>
<p>默认情况下，它是一个 <strong>最大堆 (Max Heap)</strong>，即 <code>top()</code> 返回容器中的最大元素。通过自定义比较器，可以变成最小堆或实现任意的优先级规则。</p>
<p>典型应用场景：调度系统、Dijkstra 最短路、Huffman 编码、任务队列等。</p>
<h2 id="1-引入-19"><a class="header" href="#1-引入-19">1. 引入</a></h2>
<pre><code class="language-c++">#include &lt;queue&gt;
</code></pre>
<h2 id="2-存储方式-15"><a class="header" href="#2-存储方式-15">2. 存储方式</a></h2>
<p><code>std::priority_queue</code> 内部使用一个 <strong>底层容器 (Underlying Container)</strong> 和一个 <strong>比较器 (Compare)</strong> 来实现堆的功能。</p>
<h3 id="模板定义"><a class="header" href="#模板定义">模板定义</a></h3>
<pre><code class="language-c++">template&lt;
    class T,
    class Container = std::vector&lt;T&gt;,
    class Compare = std::less&lt;typename Container::value_type&gt;
&gt; class priority_queue;
</code></pre>
<ul>
<li><strong>T</strong>：存储的元素类型。</li>
<li><strong>Container</strong>：底层容器，默认为 <code>std::vector&lt;T&gt;</code>。必须支持随机访问迭代器和 <code>push_back()</code>/<code>pop_back()</code>。</li>
<li><strong>Compare</strong>：比较器，默认为 <code>std::less&lt;T&gt;</code>（大顶堆）。若改为 <code>std::greater&lt;T&gt;</code>，则变为小顶堆。</li>
</ul>
<h3 id="默认实现"><a class="header" href="#默认实现">默认实现</a></h3>
<ul>
<li><strong>大顶堆</strong>：<code>Compare = std::less&lt;T&gt;</code></li>
<li><strong>小顶堆</strong>：<code>Compare = std::greater&lt;T&gt;</code></li>
</ul>
<h3 id="示例指定底层容器和比较器"><a class="header" href="#示例指定底层容器和比较器">示例：指定底层容器和比较器</a></h3>
<pre><code class="language-c++">// 默认：大顶堆
std::priority_queue&lt;int&gt; pq1;

// 小顶堆
std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; pq2;

// 使用 deque 作为底层容器
std::priority_queue&lt;int, std::deque&lt;int&gt;&gt; pq3;
</code></pre>
<h2 id="3-方法-15"><a class="header" href="#3-方法-15">3. 方法</a></h2>
<p><code>std::priority_queue</code> 同样不提供迭代器（不能遍历），只能通过专门的接口进行操作。</p>
<h3 id="1-构造方法-12"><a class="header" href="#1-构造方法-12">(1) 构造方法</a></h3>
<ol>
<li>
<p><code>priority_queue()</code>：构造一个空的优先队列。</p>
<pre><code class="language-c++">std::priority_queue&lt;int&gt; pq;  // 空的大顶堆
</code></pre>
</li>
<li>
<p><code>priority_queue(const Compare&amp; comp, const Container&amp; cont)</code>：用已有容器构造。</p>
<pre><code class="language-c++">std::vector&lt;int&gt; vec = {1, 5, 3};
std::priority_queue&lt;int&gt; pq(std::less&lt;int&gt;(), vec);
</code></pre>
</li>
<li>
<p>复制构造 / 移动构造。</p>
</li>
</ol>
<h3 id="2-大小函数-13"><a class="header" href="#2-大小函数-13">(2) 大小函数</a></h3>
<ol>
<li>
<p><code>size_t size() const</code>：返回元素个数。</p>
<pre><code class="language-c++">std::priority_queue&lt;int&gt; pq;
pq.push(10); pq.push(20);
std::cout &lt;&lt; pq.size(); // 输出 2
</code></pre>
</li>
<li>
<p><code>bool empty() const</code>：检查是否为空。</p>
<pre><code class="language-c++">if (pq.empty()) std::cout &lt;&lt; "Empty\n";
</code></pre>
</li>
</ol>
<h3 id="3-元素访问函数-2"><a class="header" href="#3-元素访问函数-2">(3) 元素访问函数</a></h3>
<ol>
<li>
<p><code>const_reference top() const</code>：返回堆顶元素（优先级最高的元素），复杂度 O(1)。
调用前必须确保不为空。</p>
<pre><code class="language-c++">pq.push(10);
pq.push(30);
pq.push(20);
std::cout &lt;&lt; pq.top(); // 输出 30（大顶堆）
</code></pre>
</li>
</ol>
<h3 id="4-增加函数-插入"><a class="header" href="#4-增加函数-插入">(4) 增加函数 (插入)</a></h3>
<ol>
<li>
<p><code>void push(const T&amp; value)</code>：插入元素到队列，自动保持堆序。复杂度 O(log n)。</p>
<pre><code class="language-c++">pq.push(15);
pq.push(40);
</code></pre>
</li>
<li>
<p><code>template&lt;class... Args&gt; void emplace(Args&amp;&amp;... args)</code>：原地构造元素并插入。</p>
<pre><code class="language-c++">std::priority_queue&lt;std::pair&lt;int,int&gt;&gt; pq;
pq.emplace(1, 2); // 构造 pair(1,2)
</code></pre>
</li>
</ol>
<h3 id="5-删除函数-移除"><a class="header" href="#5-删除函数-移除">(5) 删除函数 (移除)</a></h3>
<ol>
<li>
<p><code>void pop()</code>：移除堆顶元素，复杂度 O(log n)。调用前必须非空。</p>
<pre><code class="language-c++">pq.push(10);
pq.push(20);
pq.pop(); // 移除 20（大顶堆）
</code></pre>
</li>
</ol>
<h3 id="6-其他函数-4"><a class="header" href="#6-其他函数-4">(6) 其他函数</a></h3>
<ol>
<li>
<p><code>void swap(priority_queue&amp; other)</code>：交换两个队列的内容。</p>
<pre><code class="language-c++">std::priority_queue&lt;int&gt; pq1, pq2;
pq1.push(1); pq2.push(2);
pq1.swap(pq2);
</code></pre>
</li>
</ol>
<h2 id="4-示例"><a class="header" href="#4-示例">4. 示例</a></h2>
<h3 id="大顶堆"><a class="header" href="#大顶堆">大顶堆</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

int main() {
    priority_queue&lt;int&gt; pq;

    pq.push(10);
    pq.push(5);
    pq.push(20);

    cout &lt;&lt; pq.top() &lt;&lt; endl; // 20

    pq.pop();
    cout &lt;&lt; pq.top() &lt;&lt; endl; // 10
}
</code></pre>
<h3 id="小顶堆"><a class="header" href="#小顶堆">小顶堆</a></h3>
<pre><code class="language-c++">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap;
min_heap.push(10);
min_heap.push(5);
min_heap.push(20);

cout &lt;&lt; min_heap.top() &lt;&lt; endl; // 5
</code></pre>
<h3 id="自定义比较器例如比较-pair-的第二个元素"><a class="header" href="#自定义比较器例如比较-pair-的第二个元素">自定义比较器（例如：比较 pair 的第二个元素）</a></h3>
<pre><code class="language-c++">struct Compare {
    bool operator()(const pair&lt;int,int&gt;&amp; a, const pair&lt;int,int&gt;&amp; b) {
        return a.second &gt; b.second; // 小顶堆，按第二个元素比较
    }
};

priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, Compare&gt; pq;
pq.push({1, 10});
pq.push({2, 5});
cout &lt;&lt; pq.top().first &lt;&lt; endl; // 输出 2，因为 (2,5) 的 second 更小
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h1>
<p>C++ 标准库中的算法 (Algorithms) 是一组强大的函数模板，用于对容器或其他范围（<code>[first, last)</code>）内的元素进行搜索、排序、计数、修改等操作。自 C++20 以来，<strong>Ranges (约束算法)</strong> 的引入极大地简化了算法的使用，并增强了其通用性。C++17 则引入了<strong>执行策略</strong>，允许算法进行并行或乱序执行以提升性能。</p>
<h2 id="c20-约束算法-constrained-algorithms--ranges"><a class="header" href="#c20-约束算法-constrained-algorithms--ranges">C++20 约束算法 (Constrained Algorithms / Ranges)</a></h2>
<p><strong>Ranges</strong> 是 C++20 引入的一项革命性特性，它极大地简化了 STL 算法的使用，并增强了它们的组合性。</p>
<h3 id="核心概念与优势"><a class="header" href="#核心概念与优势">核心概念与优势</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">特性</th><th style="text-align: left">优势和示例</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>单一 Range 参数</strong></td><td style="text-align: left">您不再需要手动传递 <code>begin()</code> 和 <code>end()</code> 迭代器。只需将整个容器（或 Range 视图）作为<strong>一个参数</strong>传递给算法即可。</td></tr>
<tr><td style="text-align: left"><strong>Projections (投影)</strong></td><td style="text-align: left"><strong>简化复杂对象操作。</strong> 算法可以直接操作容器内元素的某个成员变量或计算结果，而无需使用复杂的 Lambda 表达式。例如，对一个 <code>vector&lt;Person&gt;</code> 按照 <code>Person::age</code> 成员进行排序。</td></tr>
<tr><td style="text-align: left"><strong>返回类型增强</strong></td><td style="text-align: left"><strong>提供所有有用的信息。</strong> 大多数 <code>std::ranges::</code> 算法不再只返回一个迭代器，而是返回一个包含所有相关结果的<strong>结构体</strong>（如 <code>std::ranges::sort_result</code>）。例如，<code>ranges::copy</code> 会返回输入范围和输出范围的结束迭代器，方便后续操作。</td></tr>
<tr><td style="text-align: left"><strong>更强的约束</strong></td><td style="text-align: left">它们是“约束算法”，这意味着它们使用 C++20 的 <strong>Concepts</strong> 确保传入的迭代器和 Range 满足算法所需的最低要求，从而提供<strong>更清晰的编译错误</strong>。</td></tr>
</tbody></table>
</div>
<p><strong>示例:</strong></p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v{7, 1, 4, 0, -1};

// 经典算法：需要显式传入begin()和end()
std::sort(v.begin(), v.end());

// C++20 Ranges 算法：更简洁
std::ranges::sort(v);
</code></pre>
<hr />
<h2 id="c17c20-执行策略-execution-policies"><a class="header" href="#c17c20-执行策略-execution-policies">C++17/C++20 执行策略 (Execution Policies)</a></h2>
<p><strong>执行策略</strong> 是 C++17 引入的功能，它允许程序员通过向算法传递一个策略对象，来指示算法如何执行——是串行、并行还是乱序执行，从而在多核 CPU 上实现<strong>性能优化</strong>。</p>
<h3 id="核心策略类型"><a class="header" href="#核心策略类型">核心策略类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">策略类型</th><th style="text-align: left">全局对象</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong><code>sequenced_policy</code></strong></td><td style="text-align: left"><code>seq</code></td><td style="text-align: left">C++17</td><td style="text-align: left"><strong>序列化执行</strong>：算法按顺序执行，不会使用并行或乱序操作。这是所有算法的默认行为。</td></tr>
<tr><td style="text-align: left"><strong><code>parallel_policy</code></strong></td><td style="text-align: left"><code>par</code></td><td style="text-align: left">C++17</td><td style="text-align: left"><strong>并行执行</strong>：算法可以在不同的线程中并发执行。它保证了并发性，但不保证指令的顺序。</td></tr>
<tr><td style="text-align: left"><strong><code>parallel_unsequenced_policy</code></strong></td><td style="text-align: left"><code>par_unseq</code></td><td style="text-align: left">C++17</td><td style="text-align: left"><strong>并行且乱序执行</strong>：结合了并行和乱序执行，允许并发执行，同时允许编译器进行<strong>矢量化 (vectorization)</strong> 优化。</td></tr>
<tr><td style="text-align: left"><strong><code>unsequenced_policy</code></strong></td><td style="text-align: left"><code>unseq</code></td><td style="text-align: left">C++20</td><td style="text-align: left"><strong>乱序执行</strong>：<strong>不保证并行</strong>，但允许编译器对单个线程中的操作进行乱序处理（矢量化），以提高性能。</td></tr>
</tbody></table>
</div>
<p><strong>头文件：</strong> 所有执行策略都定义在 <code>&lt;execution&gt;</code> 头文件中，并位于 <code>std::execution</code> 命名空间下（尽管全局对象如 <code>std::par</code> 在 <code>std</code> 命名空间）。</p>
<p><strong>示例:</strong></p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;execution&gt;
#include &lt;vector&gt;

std::vector&lt;int&gt; data = ...;

// 使用并行策略对数据进行排序，以利用多核CPU
std::sort(std::execution::par, data.begin(), data.end());

// C++20 Ranges 版本也支持策略（如果算法有重载）
std::ranges::sort(std::execution::par, data);
</code></pre>
<h3 id="并行算法的技术限制"><a class="header" href="#并行算法的技术限制">并行算法的技术限制</a></h3>
<p>在使用执行策略时，有一个关键的<strong>安全限制</strong>需要注意：</p>
<p>对于大多数并行算法（除了 <code>std::for_each</code> 和 <code>std::for_each_n</code>）：</p>
<ul>
<li>如果 Range 中的元素类型 \( T \) 满足 <strong>Trivial Copy Construction</strong> (<code>std::is_trivially_copy_constructible_v&lt;T&gt; == true</code>) 和 <strong>Trivial Destruction</strong> (<code>std::is_trivially_destructible_v&lt;T&gt; == true</code>)，<strong>库可以对元素进行任意复制</strong>，以便在不同的并行线程之间分发数据。</li>
</ul>
<p><strong>这意味着：</strong> 如果你的自定义对象具有非平凡（复杂）的构造函数、析构函数或资源管理，使用并行策略时需要额外小心，以确保你的操作是线程安全的。对于基本类型（如 <code>int</code>, <code>float</code>）和简单的 C 结构体，这通常不是问题。</p>
<h2 id="一非修改序列操作-non-modifying-sequence-operations"><a class="header" href="#一非修改序列操作-non-modifying-sequence-operations">一、非修改序列操作 (Non-modifying sequence operations)</a></h2>
<p><strong>主要头文件：</strong></p>
<ul>
<li><strong><code>&lt;algorithm&gt;</code></strong>：包含绝大多数经典的非修改序列操作。</li>
<li><strong><code>&lt;ranges&gt;</code></strong>：包含所有 <code>ranges::</code> 版本的算法。</li>
</ul>
<h3 id="批处理操作-batch-operations"><a class="header" href="#批处理操作-batch-operations">批处理操作 (Batch operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">批处理操作 (Batch operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>for_each</strong> / <strong>ranges::for_each</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">对范围内的元素应用一个一元函数对象</td></tr>
<tr><td style="text-align: left"><strong>for_each_n</strong> / <strong>ranges::for_each_n</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">对序列的前 \( N \) 个元素应用一个函数对象</td></tr>
</tbody></table>
</div>
<h3 id="搜索操作-search-operations"><a class="header" href="#搜索操作-search-operations">搜索操作 (Search operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">搜索操作 (Search operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>all_of</strong> / <strong>ranges::all_of</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">检查一个谓词对范围内的<strong>所有</strong>元素是否为真</td></tr>
<tr><td style="text-align: left"><strong>any_of</strong> / <strong>ranges::any_of</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">检查一个谓词对范围内的<strong>任一</strong>元素是否为真</td></tr>
<tr><td style="text-align: left"><strong>none_of</strong> / <strong>ranges::none_of</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">检查一个谓词对范围内的<strong>所有</strong>元素是否为假</td></tr>
<tr><td style="text-align: left"><strong>ranges::contains</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">检查范围是否包含给定元素</td></tr>
<tr><td style="text-align: left"><strong>ranges::contains_subrange</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">检查范围是否包含给定子范围</td></tr>
<tr><td style="text-align: left"><strong>find</strong> / <strong>ranges::find</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">查找满足特定条件的<strong>第一个</strong>元素</td></tr>
<tr><td style="text-align: left"><strong>find_if</strong> / <strong>ranges::find_if</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">查找满足<strong>谓词</strong>的<strong>第一个</strong>元素</td></tr>
<tr><td style="text-align: left"><strong>find_if_not</strong> / <strong>ranges::find_if_not</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">查找<strong>不满足谓词</strong>的<strong>第一个</strong>元素</td></tr>
<tr><td style="text-align: left"><strong>ranges::find_last</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">查找满足特定条件的<strong>最后一个</strong>元素</td></tr>
<tr><td style="text-align: left"><strong>ranges::find_last_if</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">查找满足<strong>谓词</strong>的<strong>最后一个</strong>元素</td></tr>
<tr><td style="text-align: left"><strong>ranges::find_last_if_not</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">查找<strong>不满足谓词</strong>的<strong>最后一个</strong>元素</td></tr>
<tr><td style="text-align: left"><strong>find_end</strong> / <strong>ranges::find_end</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">查找某一范围内的<strong>最后一个</strong>序列</td></tr>
<tr><td style="text-align: left"><strong>find_first_of</strong> / <strong>ranges::find_first_of</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">搜索一组元素中的<strong>任意一个</strong></td></tr>
<tr><td style="text-align: left"><strong>adjacent_find</strong> / <strong>ranges::adjacent_find</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">查找<strong>第一个</strong>两个相邻且相等的项（或满足给定谓词）</td></tr>
<tr><td style="text-align: left"><strong>count</strong> / <strong>ranges::count</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回满足特定条件的元素的<strong>数量</strong></td></tr>
<tr><td style="text-align: left"><strong>count_if</strong> / <strong>ranges::count_if</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回满足<strong>谓词</strong>的元素的<strong>数量</strong></td></tr>
<tr><td style="text-align: left"><strong>mismatch</strong> / <strong>ranges::mismatch</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">查找两个范围<strong>第一次不同</strong>的位置</td></tr>
<tr><td style="text-align: left"><strong>equal</strong> / <strong>ranges::equal</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">确定两组元素是否<strong>相同</strong></td></tr>
<tr><td style="text-align: left"><strong>search</strong> / <strong>ranges::search</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">搜索一个元素范围的<strong>第一次出现</strong></td></tr>
<tr><td style="text-align: left"><strong>search_n</strong> / <strong>ranges::search_n</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">搜索一个元素在范围中<strong>连续出现 \( N \) 次</strong>的第一次出现</td></tr>
<tr><td style="text-align: left"><strong>ranges::starts_with</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">检查一个范围是否<strong>以另一个范围开始</strong></td></tr>
<tr><td style="text-align: left"><strong>ranges::ends_with</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">检查一个范围是否<strong>以另一个范围结束</strong></td></tr>
</tbody></table>
</div>
<h3 id="折叠操作-fold-operations"><a class="header" href="#折叠操作-fold-operations">折叠操作 (Fold operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">折叠操作 (Fold operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>ranges::fold_left</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">对一系列元素进行<strong>左折叠</strong></td></tr>
<tr><td style="text-align: left"><strong>ranges::fold_left_first</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">使用<strong>第一个元素</strong>作为初始值对一系列元素进行<strong>左折叠</strong></td></tr>
<tr><td style="text-align: left"><strong>ranges::fold_right</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">对一系列元素进行<strong>右折叠</strong></td></tr>
<tr><td style="text-align: left"><strong>ranges::fold_right_last</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">使用<strong>最后一个元素</strong>作为初始值对一系列元素进行<strong>右折叠</strong></td></tr>
<tr><td style="text-align: left"><strong>ranges::fold_left_with_iter</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">对一系列元素进行<strong>左折叠</strong>，并返回 (迭代器, 值) 对</td></tr>
<tr><td style="text-align: left"><strong>ranges::fold_left_first_with_iter</strong></td><td style="text-align: left">(C++23)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">使用<strong>第一个元素</strong>作为初始值对一系列元素进行<strong>左折叠</strong>，并返回 (迭代器, 可选值) 对</td></tr>
</tbody></table>
</div>
<h2 id="二修改序列操作-modifying-sequence-operations"><a class="header" href="#二修改序列操作-modifying-sequence-operations">二、修改序列操作 (Modifying sequence operations)</a></h2>
<p><strong>主要头文件：</strong></p>
<ul>
<li><strong><code>&lt;algorithm&gt;</code></strong>：包含绝大多数经典的修改序列操作。</li>
<li><strong><code>&lt;ranges&gt;</code></strong>：包含所有 <code>ranges::</code> 版本的算法。</li>
<li><strong><code>&lt;utility&gt;</code></strong>：包含 <code>std::swap</code> 和 <code>std::iter_swap</code>。</li>
</ul>
<h3 id="复制操作-copy-operations"><a class="header" href="#复制操作-copy-operations">复制操作 (Copy operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">复制操作 (Copy operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>copy</strong> / <strong>ranges::copy</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将一个元素范围<strong>复制</strong>到一个新位置</td></tr>
<tr><td style="text-align: left"><strong>copy_if</strong> / <strong>ranges::copy_if</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>有条件地复制</strong>一个元素范围到新位置</td></tr>
<tr><td style="text-align: left"><strong>copy_n</strong> / <strong>ranges::copy_n</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将<strong>指定数量</strong>的元素复制到一个新位置</td></tr>
<tr><td style="text-align: left"><strong>copy_backward</strong> / <strong>ranges::copy_backward</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">以<strong>向后顺序复制</strong>一个元素范围</td></tr>
<tr><td style="text-align: left"><strong>move</strong> / <strong>ranges::move</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将一个元素范围<strong>移动</strong>到一个新位置</td></tr>
<tr><td style="text-align: left"><strong>move_backward</strong> / <strong>ranges::move_backward</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">以<strong>向后顺序移动</strong>一个元素范围</td></tr>
</tbody></table>
</div>
<h3 id="交换操作-swap-operations"><a class="header" href="#交换操作-swap-operations">交换操作 (Swap operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">交换操作 (Swap operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>swap</strong></td><td style="text-align: left">(C++11)</td><td style="text-align: left"><code>&lt;utility&gt;</code></td><td style="text-align: left"><strong>交换</strong>两个对象的值</td></tr>
<tr><td style="text-align: left"><strong>swap_ranges</strong> / <strong>ranges::swap_ranges</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>交换</strong>两个元素范围</td></tr>
<tr><td style="text-align: left"><strong>iter_swap</strong></td><td style="text-align: left"></td><td style="text-align: left"><code>&lt;utility&gt;</code></td><td style="text-align: left"><strong>交换</strong>两个迭代器所指向的元素</td></tr>
</tbody></table>
</div>
<h3 id="变换操作-transformation-operations"><a class="header" href="#变换操作-transformation-operations">变换操作 (Transformation operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">变换操作 (Transformation operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>transform</strong> / <strong>ranges::transform</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">对一个元素范围<strong>应用一个函数</strong>，并将结果存储在目标范围中</td></tr>
<tr><td style="text-align: left"><strong>replace</strong> / <strong>ranges::replace</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将所有满足特定条件的值<strong>替换</strong>为另一个值</td></tr>
<tr><td style="text-align: left"><strong>replace_if</strong> / <strong>ranges::replace_if</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将所有满足<strong>谓词</strong>的值<strong>替换</strong>为另一个值</td></tr>
<tr><td style="text-align: left"><strong>replace_copy</strong> / <strong>ranges::replace_copy</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>复制</strong>一个范围，并将满足特定条件的元素<strong>替换</strong>为另一个值</td></tr>
<tr><td style="text-align: left"><strong>replace_copy_if</strong> / <strong>ranges::replace_copy_if</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>复制</strong>一个范围，并将满足<strong>谓词</strong>的元素<strong>替换</strong>为另一个值</td></tr>
</tbody></table>
</div>
<h3 id="生成操作-generation-operations"><a class="header" href="#生成操作-generation-operations">生成操作 (Generation operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">生成操作 (Generation operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>fill</strong> / <strong>ranges::fill</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将给定值<strong>赋值</strong>给范围内的每个元素</td></tr>
<tr><td style="text-align: left"><strong>fill_n</strong> / <strong>ranges::fill_n</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将给定值<strong>赋值</strong>给范围内的 \( N \) 个元素</td></tr>
<tr><td style="text-align: left"><strong>generate</strong> / <strong>ranges::generate</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将连续函数调用的结果<strong>赋值</strong>给范围内的每个元素</td></tr>
<tr><td style="text-align: left"><strong>generate_n</strong> / <strong>ranges::generate_n</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将连续 \( N \) 次函数调用的结果<strong>赋值</strong>给范围内的 \( N \) 个元素</td></tr>
</tbody></table>
</div>
<h3 id="移除操作-removing-operations"><a class="header" href="#移除操作-removing-operations">移除操作 (Removing operations)</a></h3>
<p>这里的“移除”通常是<strong>逻辑移除</strong>，通过将未被移除的元素移动到范围的前部来实现，并返回新的逻辑尾部。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">移除操作 (Removing operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>remove</strong> / <strong>ranges::remove</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>移除</strong>满足特定条件的元素（逻辑移除）</td></tr>
<tr><td style="text-align: left"><strong>remove_if</strong> / <strong>ranges::remove_if</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>移除</strong>满足<strong>谓词</strong>的元素（逻辑移除）</td></tr>
<tr><td style="text-align: left"><strong>remove_copy</strong> / <strong>ranges::remove_copy</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>复制</strong>一个范围，<strong>省略</strong>满足特定条件的元素</td></tr>
<tr><td style="text-align: left"><strong>remove_copy_if</strong> / <strong>ranges::remove_copy_if</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>复制</strong>一个范围，<strong>省略</strong>满足<strong>谓词</strong>的元素</td></tr>
<tr><td style="text-align: left"><strong>unique</strong> / <strong>ranges::unique</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>移除</strong>范围内的<strong>连续重复</strong>元素（逻辑移除）</td></tr>
<tr><td style="text-align: left"><strong>unique_copy</strong> / <strong>ranges::unique_copy</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>创建</strong>一个不含<strong>连续重复</strong>元素的范围<strong>副本</strong></td></tr>
</tbody></table>
</div>
<h3 id="顺序改变操作-order-changing-operations"><a class="header" href="#顺序改变操作-order-changing-operations">顺序改变操作 (Order-changing operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">顺序改变操作 (Order-changing operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>reverse</strong> / <strong>ranges::reverse</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>反转</strong>范围内的元素顺序</td></tr>
<tr><td style="text-align: left"><strong>reverse_copy</strong> / <strong>ranges::reverse_copy</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>创建</strong>一个<strong>反转</strong>后的范围<strong>副本</strong></td></tr>
<tr><td style="text-align: left"><strong>rotate</strong> / <strong>ranges::rotate</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>旋转</strong>范围内的元素顺序</td></tr>
<tr><td style="text-align: left"><strong>rotate_copy</strong> / <strong>ranges::rotate_copy</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>复制</strong>并<strong>旋转</strong>一个元素范围</td></tr>
<tr><td style="text-align: left"><strong>shift_left</strong> / <strong>ranges::shift_left</strong></td><td style="text-align: left">(C++20) / (C++23)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>左移</strong>范围内的元素</td></tr>
<tr><td style="text-align: left"><strong>shift_right</strong> / <strong>ranges::shift_right</strong></td><td style="text-align: left">(C++20) / (C++23)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>右移</strong>范围内的元素</td></tr>
<tr><td style="text-align: left"><strong>shuffle</strong> / <strong>ranges::shuffle</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>随机重新排序</strong>范围内的元素</td></tr>
</tbody></table>
</div>
<h3 id="采样操作-sampling-operations"><a class="header" href="#采样操作-sampling-operations">采样操作 (Sampling operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">采样操作 (Sampling operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>sample</strong> / <strong>ranges::sample</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">从序列中<strong>选择 \( N \) 个随机元素</strong></td></tr>
</tbody></table>
</div>
<h2 id="三排序及相关操作-sorting-and-related-operations"><a class="header" href="#三排序及相关操作-sorting-and-related-operations">三、排序及相关操作 (Sorting and related operations)</a></h2>
<p><strong>主要头文件：</strong></p>
<ul>
<li><strong><code>&lt;algorithm&gt;</code></strong>：包含绝大多数经典的排序及相关操作。</li>
<li><strong><code>&lt;ranges&gt;</code></strong>：包含所有 <code>ranges::</code> 版本的算法。</li>
</ul>
<h3 id="分区操作-partitioning-operations"><a class="header" href="#分区操作-partitioning-operations">分区操作 (Partitioning operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">分区操作 (Partitioning operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>is_partitioned</strong> / <strong>ranges::is_partitioned</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">确定范围是否被给定谓词<strong>分区</strong></td></tr>
<tr><td style="text-align: left"><strong>partition</strong> / <strong>ranges::partition</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将一个元素范围<strong>划分</strong>为两组</td></tr>
<tr><td style="text-align: left"><strong>partition_copy</strong> / <strong>ranges::partition_copy</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>复制</strong>一个范围，将元素<strong>划分</strong>为两组</td></tr>
<tr><td style="text-align: left"><strong>stable_partition</strong> / <strong>ranges::stable_partition</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将元素<strong>划分</strong>为两组，同时<strong>保持</strong>它们的<strong>相对顺序</strong></td></tr>
<tr><td style="text-align: left"><strong>partition_point</strong> / <strong>ranges::partition_point</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>定位</strong>一个已分区范围的<strong>分区点</strong></td></tr>
</tbody></table>
</div>
<h3 id="排序操作-sorting-operations"><a class="header" href="#排序操作-sorting-operations">排序操作 (Sorting operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">排序操作 (Sorting operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>sort</strong> / <strong>ranges::sort</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将一个范围<strong>排序</strong>为升序</td></tr>
<tr><td style="text-align: left"><strong>stable_sort</strong> / <strong>ranges::stable_sort</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>排序</strong>一个元素范围，同时<strong>保持</strong>相等元素间的<strong>相对顺序</strong></td></tr>
<tr><td style="text-align: left"><strong>partial_sort</strong> / <strong>ranges::partial_sort</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>排序</strong>一个范围的<strong>前 \( N \) 个</strong>元素</td></tr>
<tr><td style="text-align: left"><strong>partial_sort_copy</strong> / <strong>ranges::partial_sort_copy</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>复制</strong>并<strong>部分排序</strong>一个元素范围</td></tr>
<tr><td style="text-align: left"><strong>is_sorted</strong> / <strong>ranges::is_sorted</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">检查一个范围是否已<strong>排序</strong>为升序</td></tr>
<tr><td style="text-align: left"><strong>is_sorted_until</strong> / <strong>ranges::is_sorted_until</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">查找<strong>最大</strong>的<strong>已排序子范围</strong></td></tr>
<tr><td style="text-align: left"><strong>nth_element</strong> / <strong>ranges::nth_element</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>部分排序</strong>给定范围，确保它被给定元素<strong>分区</strong></td></tr>
</tbody></table>
</div>
<h3 id="二分搜索操作-binary-search-operations"><a class="header" href="#二分搜索操作-binary-search-operations">二分搜索操作 (Binary search operations)</a></h3>
<p>这些操作要求输入范围<strong>必须是已排序</strong>的。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">二分搜索操作 (Binary search operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>lower_bound</strong> / <strong>ranges::lower_bound</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回<strong>第一个不小于</strong>给定值的元素的迭代器</td></tr>
<tr><td style="text-align: left"><strong>upper_bound</strong> / <strong>ranges::upper_bound</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回<strong>第一个大于</strong>给定值的元素的迭代器</td></tr>
<tr><td style="text-align: left"><strong>equal_range</strong> / <strong>ranges::equal_range</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回<strong>匹配</strong>特定键的元素的<strong>范围</strong></td></tr>
<tr><td style="text-align: left"><strong>binary_search</strong> / <strong>ranges::binary_search</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">确定一个元素是否存在于一个<strong>部分有序</strong>的范围中</td></tr>
</tbody></table>
</div>
<h3 id="集合操作-set-operations"><a class="header" href="#集合操作-set-operations">集合操作 (Set operations)</a></h3>
<p>这些操作要求输入范围<strong>必须是已排序</strong>的。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">集合操作 (Set operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>includes</strong> / <strong>ranges::includes</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">如果一个序列是另一个序列的<strong>子序列</strong>则返回 true</td></tr>
<tr><td style="text-align: left"><strong>set_union</strong> / <strong>ranges::set_union</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">计算两个集合的<strong>并集</strong></td></tr>
<tr><td style="text-align: left"><strong>set_intersection</strong> / <strong>ranges::set_intersection</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">计算两个集合的<strong>交集</strong></td></tr>
<tr><td style="text-align: left"><strong>set_difference</strong> / <strong>ranges::set_difference</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">计算两个集合的<strong>差集</strong></td></tr>
<tr><td style="text-align: left"><strong>set_symmetric_difference</strong> / <strong>ranges::set_symmetric_difference</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">计算两个集合的<strong>对称差集</strong></td></tr>
</tbody></table>
</div>
<h3 id="合并操作-merge-operations"><a class="header" href="#合并操作-merge-operations">合并操作 (Merge operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">合并操作 (Merge operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>merge</strong> / <strong>ranges::merge</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left"><strong>合并</strong>两个已排序的范围</td></tr>
<tr><td style="text-align: left"><strong>inplace_merge</strong> / <strong>ranges::inplace_merge</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">在<strong>原地</strong>合并两个有序范围</td></tr>
</tbody></table>
</div>
<h3 id="堆操作-heap-operations"><a class="header" href="#堆操作-heap-operations">堆操作 (Heap operations)</a></h3>
<p>这些操作用于维护最大堆 (max heap) 的属性。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">堆操作 (Heap operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>push_heap</strong> / <strong>ranges::push_heap</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">向<strong>最大堆</strong>中添加一个元素</td></tr>
<tr><td style="text-align: left"><strong>pop_heap</strong> / <strong>ranges::pop_heap</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">从<strong>最大堆</strong>中移除最大的元素</td></tr>
<tr><td style="text-align: left"><strong>make_heap</strong> / <strong>ranges::make_heap</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将一个元素范围<strong>创建</strong>为<strong>最大堆</strong></td></tr>
<tr><td style="text-align: left"><strong>sort_heap</strong> / <strong>ranges::sort_heap</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将一个<strong>最大堆</strong>转换为一个<strong>升序排序</strong>的元素范围</td></tr>
<tr><td style="text-align: left"><strong>is_heap</strong> / <strong>ranges::is_heap</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">检查给定范围是否为<strong>最大堆</strong></td></tr>
<tr><td style="text-align: left"><strong>is_heap_until</strong> / <strong>ranges::is_heap_until</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">查找作为<strong>最大堆</strong>的<strong>最大子范围</strong></td></tr>
</tbody></table>
</div>
<h3 id="最小最大操作-minimummaximum-operations"><a class="header" href="#最小最大操作-minimummaximum-operations">最小/最大操作 (Minimum/maximum operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">最小/最大操作 (Minimum/maximum operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>max</strong> / <strong>ranges::max</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回给定值中的<strong>较大者</strong></td></tr>
<tr><td style="text-align: left"><strong>max_element</strong> / <strong>ranges::max_element</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回范围中的<strong>最大元素</strong></td></tr>
<tr><td style="text-align: left"><strong>min</strong> / <strong>ranges::min</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回给定值中的<strong>较小者</strong></td></tr>
<tr><td style="text-align: left"><strong>min_element</strong> / <strong>ranges::min_element</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回范围中的<strong>最小元素</strong></td></tr>
<tr><td style="text-align: left"><strong>minmax</strong> / <strong>ranges::minmax</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回两个元素中的<strong>较小者</strong>和<strong>较大者</strong></td></tr>
<tr><td style="text-align: left"><strong>minmax_element</strong> / <strong>ranges::minmax_element</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">返回范围中的<strong>最小</strong>和<strong>最大元素</strong></td></tr>
<tr><td style="text-align: left"><strong>clamp</strong> / <strong>ranges::clamp</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">将一个值<strong>钳制</strong>在一对边界值之间</td></tr>
</tbody></table>
</div>
<h3 id="字典序比较操作-lexicographical-comparison-operations"><a class="header" href="#字典序比较操作-lexicographical-comparison-operations">字典序比较操作 (Lexicographical comparison operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">字典序比较操作 (Lexicographical comparison operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>lexicographical_compare</strong> / <strong>ranges::lexicographical_compare</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">如果一个范围<strong>字典序上小于</strong>另一个，则返回 true</td></tr>
<tr><td style="text-align: left"><strong>lexicographical_compare_three_way</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code></td><td style="text-align: left">使用<strong>三路比较</strong>比较两个范围</td></tr>
</tbody></table>
</div>
<h3 id="排列操作-permutation-operations"><a class="header" href="#排列操作-permutation-operations">排列操作 (Permutation operations)</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">排列操作 (Permutation operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>next_permutation</strong> / <strong>ranges::next_permutation</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">生成范围元素的<strong>下一个更大</strong>的字典序排列</td></tr>
<tr><td style="text-align: left"><strong>prev_permutation</strong> / <strong>ranges::prev_permutation</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">生成范围元素的<strong>下一个更小</strong>的字典序排列</td></tr>
<tr><td style="text-align: left"><strong>is_permutation</strong> / <strong>ranges::is_permutation</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;algorithm&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">确定一个序列是否是另一个序列的<strong>排列</strong></td></tr>
</tbody></table>
</div>
<h2 id="四数值操作-numeric-operations"><a class="header" href="#四数值操作-numeric-operations">四、数值操作 (Numeric operations)</a></h2>
<p><strong>主要头文件：</strong></p>
<ul>
<li><strong><code>&lt;numeric&gt;</code></strong>：包含所有传统的数值算法和 C++17 的并行数值算法。</li>
<li><strong><code>&lt;ranges&gt;</code></strong>：包含 <code>ranges::iota</code>。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">数值操作 (Numeric operations)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>iota</strong> / <strong>ranges::iota</strong></td><td style="text-align: left">(C++11) / (C++23)</td><td style="text-align: left"><code>&lt;numeric&gt;</code> / <code>&lt;ranges&gt;</code></td><td style="text-align: left">用<strong>递增</strong>的起始值填充一个范围</td></tr>
<tr><td style="text-align: left"><strong>accumulate</strong></td><td style="text-align: left"></td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">对一个元素范围<strong>求和</strong>或<strong>折叠</strong></td></tr>
<tr><td style="text-align: left"><strong>inner_product</strong></td><td style="text-align: left"></td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">计算两个元素范围的<strong>内积</strong></td></tr>
<tr><td style="text-align: left"><strong>adjacent_difference</strong></td><td style="text-align: left"></td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">计算一个范围中<strong>相邻元素</strong>之间的<strong>差值</strong></td></tr>
<tr><td style="text-align: left"><strong>partial_sum</strong></td><td style="text-align: left"></td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">计算一个元素范围的<strong>部分和</strong></td></tr>
<tr><td style="text-align: left"><strong>reduce</strong></td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">类似于 <code>std::accumulate</code>，但<strong>无序</strong></td></tr>
<tr><td style="text-align: left"><strong>exclusive_scan</strong></td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">类似于 <code>std::partial_sum</code>，但<strong>不包括</strong>第 \( N \) 个输入元素在第 \( N \) 个和中</td></tr>
<tr><td style="text-align: left"><strong>inclusive_scan</strong></td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">类似于 <code>std::partial_sum</code>，<strong>包括</strong>第 \( N \) 个输入元素在第 \( N \) 个和中</td></tr>
<tr><td style="text-align: left"><strong>transform_reduce</strong></td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">应用一个可调用对象，然后<strong>无序归约</strong></td></tr>
<tr><td style="text-align: left"><strong>transform_exclusive_scan</strong></td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">应用一个可调用对象，然后计算<strong>独占扫描</strong></td></tr>
<tr><td style="text-align: left"><strong>transform_inclusive_scan</strong></td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;numeric&gt;</code></td><td style="text-align: left">应用一个可调用对象，然后计算<strong>包含扫描</strong></td></tr>
</tbody></table>
</div>
<h2 id="五未初始化内存操作-operations-on-uninitialized-memory"><a class="header" href="#五未初始化内存操作-operations-on-uninitialized-memory">五、未初始化内存操作 (Operations on uninitialized memory)</a></h2>
<p><strong>主要头文件：</strong></p>
<ul>
<li><strong><code>&lt;memory&gt;</code></strong>：包含所有未初始化内存操作。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">未初始化内存操作 (Operations on uninitialized memory)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>uninitialized_copy</strong> / <strong>ranges::uninitialized_copy</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">将一系列对象<strong>复制</strong>到一块<strong>未初始化内存</strong>区域</td></tr>
<tr><td style="text-align: left"><strong>uninitialized_copy_n</strong> / <strong>ranges::uninitialized_copy_n</strong></td><td style="text-align: left">(C++11) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">将<strong>指定数量</strong>的对象<strong>复制</strong>到一块<strong>未初始化内存</strong>区域</td></tr>
<tr><td style="text-align: left"><strong>uninitialized_fill</strong> / <strong>ranges::uninitialized_fill</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">将一个对象<strong>复制赋值</strong>给一块<strong>未初始化内存</strong>区域</td></tr>
<tr><td style="text-align: left"><strong>uninitialized_fill_n</strong> / <strong>ranges::uninitialized_fill_n</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">将一个对象<strong>复制赋值</strong>给<strong>指定数量</strong>的<strong>未初始化内存</strong>区域</td></tr>
<tr><td style="text-align: left"><strong>uninitialized_move</strong> / <strong>ranges::uninitialized_move</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">将一系列对象<strong>移动</strong>到一块<strong>未初始化内存</strong>区域</td></tr>
<tr><td style="text-align: left"><strong>uninitialized_move_n</strong> / <strong>ranges::uninitialized_move_n</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">将<strong>指定数量</strong>的对象<strong>移动</strong>到一块<strong>未初始化内存</strong>区域</td></tr>
<tr><td style="text-align: left"><strong>uninitialized_default_construct</strong> / <strong>ranges::uninitialized_default_construct</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">在一块<strong>未初始化内存</strong>区域中<strong>默认构造</strong>对象</td></tr>
<tr><td style="text-align: left"><strong>uninitialized_default_construct_n</strong> / <strong>ranges::uninitialized_default_construct_n</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">在一块<strong>未初始化内存</strong>区域中<strong>默认构造</strong> \( N \) 个对象</td></tr>
<tr><td style="text-align: left"><strong>uninitialized_value_construct</strong> / <strong>ranges::uninitialized_value_construct</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">在一块<strong>未初始化内存</strong>区域中<strong>值构造</strong>对象</td></tr>
<tr><td style="text-align: left"><strong>uninitialized_value_construct_n</strong> / <strong>ranges::uninitialized_value_construct_n</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">在一块<strong>未初始化内存</strong>区域中<strong>值构造</strong> \( N \) 个对象</td></tr>
<tr><td style="text-align: left"><strong>destroy</strong> / <strong>ranges::destroy</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left"><strong>销毁</strong>一系列对象</td></tr>
<tr><td style="text-align: left"><strong>destroy_n</strong> / <strong>ranges::destroy_n</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left"><strong>销毁</strong>范围内的 \( N \) 个对象</td></tr>
<tr><td style="text-align: left"><strong>destroy_at</strong> / <strong>ranges::destroy_at</strong></td><td style="text-align: left">(C++17) / (C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left"><strong>销毁</strong>给定地址处的对象</td></tr>
<tr><td style="text-align: left"><strong>construct_at</strong> / <strong>ranges::construct_at</strong></td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;memory&gt;</code></td><td style="text-align: left">在给定地址处<strong>创建</strong>一个对象</td></tr>
</tbody></table>
</div>
<h2 id="六其他算法和工具"><a class="header" href="#六其他算法和工具">六、其他算法和工具</a></h2>
<h3 id="随机数生成-random-number-generation"><a class="header" href="#随机数生成-random-number-generation">随机数生成 (Random number generation)</a></h3>
<p><strong>主要头文件：</strong></p>
<ul>
<li><strong><code>&lt;ranges&gt;</code></strong></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">随机数生成 (Random number generation)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>ranges::generate_random</strong></td><td style="text-align: left">(C++26)</td><td style="text-align: left"><code>&lt;ranges&gt;</code></td><td style="text-align: left">用<strong>均匀随机位生成器</strong>填充一个随机数范围</td></tr>
</tbody></table>
</div>
<h3 id="c-库函数-c-library-functions"><a class="header" href="#c-库函数-c-library-functions">C 库函数 (C library functions)</a></h3>
<p><strong>主要头文件：</strong></p>
<ul>
<li><strong><code>&lt;cstdlib&gt;</code></strong> (或 <code>&lt;stdlib.h&gt;</code>)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">C 库函数 (C library functions)</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>qsort</strong></td><td style="text-align: left"></td><td style="text-align: left"><code>&lt;cstdlib&gt;</code></td><td style="text-align: left"><strong>排序</strong>一个<strong>类型未指定</strong>的元素范围</td></tr>
<tr><td style="text-align: left"><strong>bsearch</strong></td><td style="text-align: left"></td><td style="text-align: left"><code>&lt;cstdlib&gt;</code></td><td style="text-align: left"><strong>搜索</strong>一个<strong>类型未指定</strong>的数组中的元素</td></tr>
</tbody></table>
</div>
<h3 id="附注执行策略-execution-policies"><a class="header" href="#附注执行策略-execution-policies">附注：执行策略 (Execution policies)</a></h3>
<p><strong>主要头文件：</strong></p>
<ul>
<li><strong><code>&lt;execution&gt;</code></strong></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">执行策略类型 (Execution policy types)</th><th style="text-align: left">宏/类/对象</th><th style="text-align: left">C++ 版本</th><th style="text-align: left">头文件</th><th style="text-align: left">描述 (功能)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>sequenced_policy</strong> (<code>seq</code>)</td><td style="text-align: left">类 / 全局对象</td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;execution&gt;</code></td><td style="text-align: left"><strong>序列化</strong>执行（无并行）</td></tr>
<tr><td style="text-align: left"><strong>parallel_policy</strong> (<code>par</code>)</td><td style="text-align: left">类 / 全局对象</td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;execution&gt;</code></td><td style="text-align: left"><strong>并行</strong>执行</td></tr>
<tr><td style="text-align: left"><strong>parallel_unsequenced_policy</strong> (<code>par\_unseq</code>)</td><td style="text-align: left">类 / 全局对象</td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;execution&gt;</code></td><td style="text-align: left"><strong>并行</strong>且<strong>乱序</strong>执行</td></tr>
<tr><td style="text-align: left"><strong>unsequenced_policy</strong> (<code>unseq</code>)</td><td style="text-align: left">类 / 全局对象</td><td style="text-align: left">(C++20)</td><td style="text-align: left"><code>&lt;execution&gt;</code></td><td style="text-align: left"><strong>乱序</strong>执行（允许编译器向量化）</td></tr>
<tr><td style="text-align: left"><strong>is_execution_policy</strong></td><td style="text-align: left">类模板</td><td style="text-align: left">(C++17)</td><td style="text-align: left"><code>&lt;execution&gt;</code></td><td style="text-align: left">测试一个类是否表示一个执行策略</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="文件与流files-and-streams"><a class="header" href="#文件与流files-and-streams">文件与流（Files and Streams）</a></h1>
<p>在 C++ 中，<strong>流（Stream）</strong> 是输入输出系统的核心概念。所有数据的读写操作——无论来自键盘、内存、文件还是网络——都被统一抽象为“流”的形式。
从概念上讲，<strong>文件是流的一种具体实现</strong>：流是一种数据传输通道，而文件流则是通向磁盘文件的通道。</p>
<h2 id="一流的基本概念"><a class="header" href="#一流的基本概念">一、流的基本概念</a></h2>
<p>在程序运行过程中，数据在设备之间不断流动。C++ 将数据的输入输出过程抽象为一个“流（stream）”，即：</p>
<blockquote>
<p>数据在内存与外部设备之间的有序传输。</p>
</blockquote>
<p>流有两种基本方向：</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>类名</th><th>说明</th></tr></thead><tbody>
<tr><td>输入流</td><td><code>istream</code></td><td>数据从设备流入程序（例如键盘输入、文件读取）</td></tr>
<tr><td>输出流</td><td><code>ostream</code></td><td>数据从程序流向设备（例如屏幕输出、文件写入）</td></tr>
</tbody></table>
</div>
<p>C++ 的标准输入输出（如 <code>cin</code>、<code>cout</code>、<code>cerr</code>、<code>clog</code>）都是基于这套流机制实现的。</p>
<h2 id="二c-流类层次结构"><a class="header" href="#二c-流类层次结构">二、C++ 流类层次结构</a></h2>
<p>C++ 标准库为不同的数据来源提供了不同种类的流类，这些类共同组成一个继承体系：</p>
<pre><code class="language-text">ios_base
 └── ios
      ├── istream          // 输入流
      │    ├── ifstream     // 文件输入流
      │    └── istringstream// 字符串输入流
      ├── ostream          // 输出流
      │    ├── ofstream     // 文件输出流
      │    └── ostringstream// 字符串输出流
      └── iostream         // 输入输出流
           ├── fstream      // 文件输入输出流
           └── stringstream // 字符串输入输出流
</code></pre>
<p>可以看到，无论是文件流、字符串流还是标准流，它们都共享相同的接口和操作方式。
因此，掌握流的基本用法，就能轻松在不同输入输出介质之间迁移代码。</p>
<h2 id="三流的分类与用途"><a class="header" href="#三流的分类与用途">三、流的分类与用途</a></h2>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>头文件</th><th>主要类</th><th>典型用途</th></tr></thead><tbody>
<tr><td>标准输入输出流</td><td><code>&lt;iostream&gt;</code></td><td><code>cin</code>, <code>cout</code>, <code>cerr</code>, <code>clog</code></td><td>控制台输入输出</td></tr>
<tr><td>文件流</td><td><code>&lt;fstream&gt;</code></td><td><code>ifstream</code>, <code>ofstream</code>, <code>fstream</code></td><td>读取与写入文件</td></tr>
<tr><td>字符串流</td><td><code>&lt;sstream&gt;</code></td><td><code>istringstream</code>, <code>ostringstream</code>, <code>stringstream</code></td><td>内存中字符串格式化与解析</td></tr>
</tbody></table>
</div>
<h2 id="四文件作为流的体现"><a class="header" href="#四文件作为流的体现">四、文件作为流的体现</a></h2>
<p>在操作文件时，我们使用 <code>ifstream</code>、<code>ofstream</code>、<code>fstream</code> 来打开磁盘文件并执行读写。
但本质上，这些类并没有引入新的 I/O 模型，而是继承自 <code>istream</code> / <code>ostream</code>，仅仅改变了<strong>流的来源或去向</strong>：</p>
<ul>
<li><code>ifstream</code>：从文件读取数据（输入流）</li>
<li><code>ofstream</code>：向文件写入数据（输出流）</li>
<li><code>fstream</code>：既可读也可写（双向流）</li>
</ul>
<p>这种统一的流模型让文件操作与普通输入输出完全一致：</p>
<pre><code class="language-cpp">std::ifstream fin("input.txt");
std::ofstream fout("output.txt");

int x;
fin &gt;&gt; x;       // 从文件读取
fout &lt;&lt; x * 2;  // 写入文件
</code></pre>
<p>同时，为了适应多种文件类型，还支持基于二进制操作文件流：</p>
<pre><code class="language-cpp">// 二进制写入
std::ofstream fout_bin("data.bin", std::ios::binary);
int x = 42;
fout_bin.write(reinterpret_cast&lt;const char*&gt;(&amp;x), sizeof(x));
</code></pre>
<h2 id="五字符串流的作用"><a class="header" href="#五字符串流的作用">五、字符串流的作用</a></h2>
<p><code>&lt;sstream&gt;</code> 提供了面向内存字符串的流操作。
它们与文件流类似，但数据读写的目标是内存字符串而非磁盘文件，非常适合：</p>
<ul>
<li>格式化文本（如将数值转为字符串）</li>
<li>从字符串中提取结构化数据</li>
<li>临时缓冲输出内容</li>
</ul>
<pre><code class="language-cpp">std::stringstream ss;
ss &lt;&lt; "Result: " &lt;&lt; 42;
std::string text = ss.str();  // "Result: 42"
</code></pre>
<blockquote>
<p>早期 C++ 还提供 <code>&lt;strstream&gt;</code> 实现基于字符数组的流，但由于安全性和内存管理问题，现已由 <code>&lt;sstream&gt;</code> 完全取代。</p>
</blockquote>
<h2 id="六流状态与错误处理"><a class="header" href="#六流状态与错误处理">六、流状态与错误处理</a></h2>
<p>在 C++ 的流系统中，无论是标准输入输出流、文件流还是字符串流，<strong>都共享一套统一的状态机制</strong>。
每个流对象都维护着一个内部状态，用于反映当前输入输出操作的健康状况。程序可以通过这些状态来判断流是否处于可用、结束或错误状态，从而实现可靠的错误控制。</p>
<h3 id="1-状态标志stream-state-flags"><a class="header" href="#1-状态标志stream-state-flags">1. 状态标志（Stream State Flags）</a></h3>
<p>C++ 通过四种主要的状态标志来描述流的状态，这些标志可能同时存在，用于表达复杂情况：</p>
<div class="table-wrapper"><table><thead><tr><th>状态名</th><th>成员常量</th><th>含义</th></tr></thead><tbody>
<tr><td><strong><code>goodbit</code></strong></td><td><code>std::ios::goodbit</code></td><td>一切正常，流处于可用状态</td></tr>
<tr><td><strong><code>eofbit</code></strong></td><td><code>std::ios::eofbit</code></td><td>已到达输入结束（End Of File）</td></tr>
<tr><td><strong><code>failbit</code></strong></td><td><code>std::ios::failbit</code></td><td>输入失败，通常是格式不匹配（如期望数字却读到字符）</td></tr>
<tr><td><strong><code>badbit</code></strong></td><td><code>std::ios::badbit</code></td><td>流已损坏，通常是严重的系统性错误（如设备失效）</td></tr>
</tbody></table>
</div>
<p>流的状态存储在 <code>std::ios</code> 基类中，因此所有继承自它的类（如 <code>istream</code>、<code>ostream</code>、<code>fstream</code>、<code>stringstream</code>）都拥有相同的状态接口。</p>
<h3 id="2-状态检查接口"><a class="header" href="#2-状态检查接口">2. 状态检查接口</a></h3>
<p>流对象提供了多种方式用于检查状态：</p>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>返回值</th><th>说明</th></tr></thead><tbody>
<tr><td><code>good()</code></td><td><code>true</code> / <code>false</code></td><td>流是否处于正常状态</td></tr>
<tr><td><code>eof()</code></td><td><code>true</code> / <code>false</code></td><td>是否到达文件或输入末尾</td></tr>
<tr><td><code>fail()</code></td><td><code>true</code> / <code>false</code></td><td>是否发生输入失败</td></tr>
<tr><td><code>bad()</code></td><td><code>true</code> / <code>false</code></td><td>是否出现系统性错误</td></tr>
<tr><td><code>rdstate()</code></td><td><code>iostate</code></td><td>返回全部状态标志的组合</td></tr>
</tbody></table>
</div>
<p>例如：</p>
<pre><code class="language-cpp">int x;
std::cin &gt;&gt; x;
if (std::cin.fail()) {
    std::cerr &lt;&lt; "输入错误：类型不匹配。" &lt;&lt; std::endl;
}
</code></pre>
<p>当用户输入非数字时，<code>cin.fail()</code> 将为 <code>true</code>，表示提取操作失败。</p>
<h3 id="3-状态恢复与忽略输入"><a class="header" href="#3-状态恢复与忽略输入">3. 状态恢复与忽略输入</a></h3>
<p>一旦流进入错误状态，后续输入输出操作将被阻塞。要恢复流，需要手动清除错误标志并可能丢弃无效输入：</p>
<pre><code class="language-cpp">std::cin.clear(); // 清除所有错误标志
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n'); // 忽略当前行
</code></pre>
<p>这段代码常用于防止错误输入导致程序陷入死循环，是交互式程序中非常典型的输入修复模式。</p>
<h3 id="4-状态机制的意义"><a class="header" href="#4-状态机制的意义">4. 状态机制的意义</a></h3>
<p>C++ 的流状态机制让输入输出更具鲁棒性和通用性。
无论是键盘输入、文件读取，还是内存字符串解析，都可以通过相同的方式检测和处理异常。这种设计体现了“<strong>统一的流模型</strong>”思想：</p>
<ul>
<li>所有流对象共享同一组状态接口；</li>
<li>程序可根据状态灵活决定后续逻辑；</li>
<li>错误恢复无需依赖具体 I/O 类型。</li>
</ul>
<p>这种一致性为大型项目中的 I/O 管理提供了强大的可移植性与可扩展性。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>“文件与流”既是 C++ I/O 系统的核心概念，也是工程实践中最常用的技术之一：</p>
<ul>
<li>日志系统基于文件流；</li>
<li>配置文件解析常通过字符串流；</li>
<li>网络传输底层也可抽象为流。</li>
</ul>
<p>掌握流的思想，意味着可以用同一套接口处理不同数据源，为程序的输入输出设计提供统一模型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准输入输出流iostream"><a class="header" href="#标准输入输出流iostream">标准输入输出流（iostream）</a></h1>
<p>C++ 的输入输出体系以 <code>&lt;iostream&gt;</code> 头文件为核心。它定义了程序与外部设备（例如键盘与显示器）交互的最基本机制，是所有流操作的基础。标准输入输出流提供了一组通用接口，用于在内存与外部设备之间以流的形式进行数据传输。</p>
<h2 id="一标准流对象"><a class="header" href="#一标准流对象">一、标准流对象</a></h2>
<p>C++ 预定义了四个标准流对象，分别用于输入、输出与错误处理：</p>
<div class="table-wrapper"><table><thead><tr><th>对象名</th><th>所属类</th><th>方向</th><th>描述</th></tr></thead><tbody>
<tr><td><code>cin</code></td><td><code>istream</code></td><td>输入</td><td>从标准输入（键盘）读取数据</td></tr>
<tr><td><code>cout</code></td><td><code>ostream</code></td><td>输出</td><td>向标准输出（控制台）写入数据</td></tr>
<tr><td><code>cerr</code></td><td><code>ostream</code></td><td>输出</td><td>向标准错误输出写入数据（不带缓冲）</td></tr>
<tr><td><code>clog</code></td><td><code>ostream</code></td><td>输出</td><td>向标准错误输出写入数据（带缓冲）</td></tr>
</tbody></table>
</div>
<p><code>cin</code> 和 <code>cout</code> 是最常用的两个流对象，它们对应于 C 语言中的 <code>stdin</code> 与 <code>stdout</code>。而 <code>cerr</code> 与 <code>clog</code> 则用于错误与日志输出：</p>
<ul>
<li><code>cerr</code> 立即输出，不经过缓冲，适合错误提示；</li>
<li><code>clog</code> 使用缓冲区，适合记录日志或调试信息。</li>
</ul>
<h2 id="二输入与输出运算符"><a class="header" href="#二输入与输出运算符">二、输入与输出运算符</a></h2>
<p>C++ 使用运算符重载机制，使输入与输出操作更自然直观：</p>
<pre><code class="language-cpp">int a;
std::cin &gt;&gt; a;       // 输入，将数据流入变量 a
std::cout &lt;&lt; a &lt;&lt; '\n'; // 输出，将数据流出到控制台
</code></pre>
<p><code>&gt;&gt;</code> 是提取运算符（extraction operator），从输入流中提取数据；
<code>&lt;&lt;</code> 是插入运算符（insertion operator），向输出流中插入数据。</p>
<p>这两个运算符被广泛重载，可用于所有基本类型与标准容器（通过 <code>operator&lt;&lt;</code> 的重载），使得流式编程成为 C++ 的一大特色。例如：</p>
<pre><code class="language-cpp">std::string name;
int age;
std::cin &gt;&gt; name &gt;&gt; age;
std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; std::endl;
</code></pre>
<p>每个操作符都返回流对象自身的引用，从而允许<strong>链式调用</strong>。</p>
<h2 id="三流缓冲与刷新机制"><a class="header" href="#三流缓冲与刷新机制">三、流缓冲与刷新机制</a></h2>
<p>所有标准输出流都带有缓冲区。输出内容首先被写入缓冲区，当缓冲区满、遇到换行符、调用 <code>flush</code> 或程序结束时，缓冲内容才会真正输出到设备。</p>
<p>常见的刷新方式有：</p>
<ul>
<li><code>std::endl</code>：输出换行并刷新缓冲区；</li>
<li><code>std::flush</code>：仅刷新缓冲区；</li>
<li><code>std::ends</code>：输出一个空字符并刷新缓冲区。</li>
</ul>
<pre><code class="language-cpp">std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;  // 换行并刷新
</code></pre>
<p>这种延迟输出机制提高了效率，但在交互程序中需要注意及时刷新，否则可能出现输出滞后。</p>
<h2 id="四格式化输出"><a class="header" href="#四格式化输出">四、格式化输出</a></h2>
<p>C++ 流提供了丰富的格式化控制机制，用于调整输出格式。最常见的控制包括：</p>
<ol>
<li>
<p><strong>操纵符（Manipulators）</strong>
通过 <code>&lt;iomanip&gt;</code> 头文件可以使用 <code>setw</code>, <code>setfill</code>, <code>setprecision</code>, <code>fixed</code>, <code>scientific</code> 等控制输出格式：</p>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
double pi = 3.14159265;
std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; pi;  // 输出 3.142
</code></pre>
</li>
<li>
<p><strong>流格式标志</strong>
可以通过 <code>setf()</code>、<code>unsetf()</code> 修改流的格式状态，例如控制对齐方式、进制表示、是否显示符号等：</p>
<pre><code class="language-cpp">std::cout.setf(std::ios::showpos);
std::cout &lt;&lt; 42;  // 输出 +42
</code></pre>
</li>
</ol>
<h2 id="五ios-与-ios_base"><a class="header" href="#五ios-与-ios_base">五、<code>ios</code> 与 <code>ios_base</code></a></h2>
<p><code>ios_base</code> 是所有流类的根基，提供全局的格式化与状态管理功能，如：</p>
<ul>
<li>格式标志（<code>fmtflags</code>）</li>
<li>I/O 状态（<code>iostate</code>）</li>
<li>用户自定义存储（<code>xalloc</code>, <code>iword</code>, <code>pword</code>）</li>
</ul>
<p>而 <code>ios</code> 则在此基础上增加了缓冲区管理与错误处理机制，是 <code>istream</code> 与 <code>ostream</code> 的共同父类。</p>
<h2 id="六标准流的重定向"><a class="header" href="#六标准流的重定向">六、标准流的重定向</a></h2>
<p>C++ 允许将标准输入输出流重定向到文件或其他流对象，实现灵活的数据通道。例如：</p>
<pre><code class="language-cpp">std::ofstream fout("log.txt");
std::streambuf* backup = std::cout.rdbuf(fout.rdbuf());  // 重定向 cout 到文件
std::cout &lt;&lt; "This will be written to file." &lt;&lt; std::endl;
std::cout.rdbuf(backup); // 恢复
</code></pre>
<p>这种技术常用于日志系统或单元测试环境，能够让程序在不修改逻辑的情况下改变输出目标。</p>
<h2 id="七非格式化输入与其他高级输入方法"><a class="header" href="#七非格式化输入与其他高级输入方法">七、非格式化输入与其他高级输入方法</a></h2>
<p>提取运算符 <code>&gt;&gt;</code>（格式化输入）在读取数据时会跳过开头的空白符，并且遇到空格、制表符或换行符时会停止，这不适用于读取包含空格的字符串或需要精确控制读取字节数的情况。C++ iostream 库提供了一系列<strong>非格式化输入函数</strong>来满足这些需求。</p>
<h3 id="1-读取整行getline"><a class="header" href="#1-读取整行getline">1. 读取整行：<code>getline()</code></a></h3>
<p><code>std::getline()</code> 是最常用的非格式化输入函数之一，用于读取一行文本，包括其中的空格。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">函数签名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>std::getline(istream&amp; is, std::string&amp; str, char delim)</code></td><td style="text-align: left">从输入流 <code>is</code> 中读取字符，直到遇到指定的分隔符 <code>delim</code>（默认为 <code>\n</code>），并将读取的内容存入 <code>str</code>。<strong>分隔符会被读取，但不会存入 <code>str</code>。</strong></td></tr>
<tr><td style="text-align: left"><code>std::getline(istream&amp; is, std::string&amp; str)</code></td><td style="text-align: left">使用默认的分隔符 <code>\n</code> 读取一行。</td></tr>
</tbody></table>
</div>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

std::string fullName;
std::cout &lt;&lt; "Enter your full name: ";
// 读取整行输入，直到遇到换行符
std::getline(std::cin, fullName);
std::cout &lt;&lt; "Welcome, " &lt;&lt; fullName &lt;&lt; std::endl;
</code></pre>
<h3 id="2-读取单个字符get"><a class="header" href="#2-读取单个字符get">2. 读取单个字符：<code>get()</code></a></h3>
<p><code>get()</code> 函数用于从流中读取单个字符，且<strong>不会跳过空白符</strong>。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">函数签名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>is.get(char&amp; ch)</code></td><td style="text-align: left">将流中的下一个字符存入 <code>ch</code>。</td></tr>
<tr><td style="text-align: left"><code>is.get()</code></td><td style="text-align: left">返回流中的下一个字符（作为 <code>int</code> 类型），或返回 <code>EOF</code>（文件结束）。</td></tr>
</tbody></table>
</div>
<pre><code class="language-cpp">char c1, c2;
std::cin.get(c1); // 读取第一个字符（可能是空格）
std::cin.get(c2); // 读取第二个字符
std::cout &lt;&lt; "c1: " &lt;&lt; c1 &lt;&lt; ", c2: " &lt;&lt; c2 &lt;&lt; std::endl;
</code></pre>
<h3 id="3-忽略流中字符ignore"><a class="header" href="#3-忽略流中字符ignore">3. 忽略流中字符：<code>ignore()</code></a></h3>
<p><code>ignore()</code> 函数常用于清除输入缓冲区中残余的字符，特别是在混合使用格式化输入（<code>&gt;&gt;</code>）和 <code>getline()</code> 时。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">函数签名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>is.ignore(streamsize count, char delim)</code></td><td style="text-align: left">从输入流中丢弃最多 <code>count</code> 个字符，直到遇到指定的分隔符 <code>delim</code>。<strong>分隔符也会被丢弃</strong>。</td></tr>
</tbody></table>
</div>
<pre><code class="language-cpp">int age;
char gender;

std::cin &gt;&gt; age;
// 假设用户输入 "25\n"
// `&gt;&gt; age` 读取了 25，但换行符 '\n' 仍留在缓冲区。

// 清除缓冲区中剩余的字符，直到遇到换行符
std::cin.ignore(10000, '\n');

std::cout &lt;&lt; "Enter gender (M/F): ";
std::cin.get(gender);
// 现在 `get()` 可以正确读取新的输入，而不是残留在缓冲区的 '\n'
</code></pre>
<blockquote>
<p><strong>注意：</strong> <code>10000</code> 是一个较大的数字，确保能够处理大多数行长度。</p>
</blockquote>
<h3 id="4-窥视下一个字符peek"><a class="header" href="#4-窥视下一个字符peek">4. 窥视下一个字符：<code>peek()</code></a></h3>
<p><code>peek()</code> 函数用于查看流中下一个可用的字符，但<strong>不会将其从流中移除</strong>。</p>
<pre><code class="language-cpp">// 假设流中下一个字符是 'H'
char nextChar = std::cin.peek();
// nextChar 是 'H'
// 'H' 仍然在输入流中，可供下次操作读取
</code></pre>
<h3 id="5-高级操作read-与-gcount"><a class="header" href="#5-高级操作read-与-gcount">5. 高级操作：<code>read()</code> 与 <code>gcount()</code></a></h3>
<p><code>read()</code> 是一个底层的非格式化输入函数，用于读取指定数量的原始字节数据，常用于处理二进制文件。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">函数签名</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>is.read(char* s, streamsize n)</code></td><td style="text-align: left">从流中读取 <code>n</code> 个字节到内存地址 <code>s</code> 开始的缓冲区。</td></tr>
</tbody></table>
</div>
<p>在调用 <code>read()</code> 或任何非格式化输入函数后，可以使用 <code>gcount()</code> 来获取<strong>最近一次非格式化输入操作实际读取的字符数量</strong>。</p>
<pre><code class="language-cpp">char buffer[10];
// 尝试从流中读取 10 个字节
std::cin.read(buffer, 10);
// 报告实际读取的字节数（可能小于 10，例如遇到文件末尾）
std::streamsize actualRead = std::cin.gcount();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="字符串流sstream"><a class="header" href="#字符串流sstream">字符串流（sstream）</a></h1>
<p>在 C++ 中，<strong>字符串流（String Streams）</strong> 是一种特殊的内存流，它将字符串抽象为输入输出流，从而允许程序像操作文件或控制台那样读写字符串。字符串流的核心头文件为 <code>&lt;sstream&gt;</code>，主要用于格式化文本、解析数据或在内存中临时缓存输出内容。相比直接操作字符串，字符串流提供了统一、可扩展且安全的接口。</p>
<h2 id="一字符串流的分类"><a class="header" href="#一字符串流的分类">一、字符串流的分类</a></h2>
<p>字符串流继承自标准流类体系，但其输入输出目标不是物理设备，而是内存中的字符串。C++ 提供三种主要类型的字符串流：</p>
<ol>
<li>
<p><strong><code>istringstream</code></strong>
面向输入的字符串流，用于从字符串中提取数据。它将字符串当作数据源，实现类似于从文件读取的行为。</p>
</li>
<li>
<p><strong><code>ostringstream</code></strong>
面向输出的字符串流，用于向字符串写入数据。它提供了格式化输出的能力，将数据以文本形式存储在内存字符串中。</p>
</li>
<li>
<p><strong><code>stringstream</code></strong>
同时支持输入和输出，可以在同一个字符串流对象上进行读写操作。适合需要在内存中反复解析和构建字符串的场景。</p>
</li>
</ol>
<p>这种设计与标准流对象保持一致，使得对内存字符串的操作与文件或控制台的操作具有统一的接口和方法。</p>
<h2 id="二基本用法"><a class="header" href="#二基本用法">二、基本用法</a></h2>
<p>使用字符串流时，通常的步骤包括创建流对象、向流中写入或从流中读取数据，然后获取最终字符串或解析结果。示例：</p>
<pre><code class="language-cpp">#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

std::ostringstream oss;
oss &lt;&lt; "Name: " &lt;&lt; "Alice" &lt;&lt; ", Age: " &lt;&lt; 30;
std::string result = oss.str();
std::cout &lt;&lt; result &lt;&lt; std::endl;  // 输出 "Name: Alice, Age: 30"
</code></pre>
<pre><code class="language-cpp">std::string data = "42 3.14 hello";
std::istringstream iss(data); // 从已有的字符串中建立字符流

int i;
double d;
std::string s;
iss &gt;&gt; i &gt;&gt; d &gt;&gt; s;  // 从字符串中提取整数、浮点数和字符串
</code></pre>
<p>通过这种方式，程序可以像处理标准流那样操作字符串，利用 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 运算符进行格式化输入输出。</p>
<h2 id="三流的格式化能力"><a class="header" href="#三流的格式化能力">三、流的格式化能力</a></h2>
<p>字符串流继承自标准流类，因此支持所有流的格式化特性：</p>
<ul>
<li>可以使用操纵符（<code>setw</code>, <code>setprecision</code>, <code>fixed</code> 等）控制输出格式。</li>
<li>可以通过 <code>setf()</code>、<code>unsetf()</code> 设置流的格式标志，实现对齐方式、数值进制或符号显示的控制。</li>
<li>可以链式调用输入输出操作，使字符串构建或解析更加简洁。</li>
</ul>
<p>示例：</p>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
std::ostringstream oss2;
double pi = 3.14159265;
oss2 &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; pi;
std::cout &lt;&lt; oss2.str();  // 输出 "3.14"
</code></pre>
<h2 id="四常见操作方法"><a class="header" href="#四常见操作方法">四、常见操作方法</a></h2>
<p>字符串流提供了丰富的成员函数，用于在内存字符串上实现精细控制：</p>
<ol>
<li>
<p><strong>获取内容</strong></p>
<ul>
<li><code>str()</code>：返回当前流中的字符串内容。</li>
<li><code>str(const std::string&amp;)</code>：设置或替换流的内容，为流重新赋值。</li>
</ul>
</li>
<li>
<p><strong>清空或重置流</strong></p>
<ul>
<li><code>clear()</code>：重置流的状态，使其可重新进行读写操作。</li>
<li><code>seekg()</code> / <code>seekp()</code>：调整读写位置，实现从特定位置开始读取或写入。</li>
</ul>
</li>
<li>
<p><strong>读取与写入</strong></p>
<ul>
<li>使用 <code>&gt;&gt;</code> 从字符串中提取数据，使用 <code>&lt;&lt;</code> 向流中插入数据。</li>
<li>可以使用 <code>getline()</code> 从字符串中逐行读取内容，与文件或控制台操作保持一致。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<pre><code class="language-cpp">std::stringstream ss("123 456");
int a, b;
ss &gt;&gt; a &gt;&gt; b;  // 提取两个整数
ss.str("");    // 清空流内容
ss.clear();    // 重置状态
ss &lt;&lt; "New content";
</code></pre>
<h2 id="五应用实例"><a class="header" href="#五应用实例">五、应用实例</a></h2>
<h3 id="1-解析数组"><a class="header" href="#1-解析数组">1. 解析数组</a></h3>
<p>解析<code>"[2,-1,3,0,12]"</code>这样的字符串为数组：</p>
<pre><code class="language-cpp">std::string s = "[2,-1,3,0,12]";
std::stringstream ss(s);
char ch;
std::vector&lt;int&gt; nums;
std::string temp;

// 读取第一个字符，应该是 '['
ss &gt;&gt; ch;
if (ch != '[') {
    std::cerr &lt;&lt; "Invalid input format!" &lt;&lt; std::endl;
    return 1;
}

while (ss &gt;&gt; ch) {
    if (ch == ',' || ch == ']') {
        if (!temp.empty()) {
            nums.push_back(std::stoi(temp)); // 转换字符串为整数
            temp.clear();
        }
        if (ch == ']') break; // 数组结束
    } else {
        temp += ch; // 累积数字字符，包括负号
    }
}

// 输出结果
std::cout &lt;&lt; "Numbers: ";
for (int n : nums) std::cout &lt;&lt; n &lt;&lt; " ";
std::cout &lt;&lt; std::endl;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript">
    // 获取当前页面的 URL
    var currentUrl = window.location.href;

    // 检查是否处于打印模式，防止在打印时触发跳转
    if (window.matchMedia("print").matches) {
        // 打印时不做任何操作
        console.log("Printing, redirect is disabled.");
    } else if (currentUrl.indexOf('/note.html') !== -1) {
        // 如果当前 URL 是 '/note.html'，则执行重定向
        window.location.href = "../index.html";
    }
</script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
