<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>基本数据类型 - Note of C++</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Note of C++</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DingWH03/note-c-plus-plus" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/DingWH03/note-c-plus-plus/edit/master/src/Basis/Types/Fundamental_Types.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="基本数据类型"><a class="header" href="#基本数据类型">基本数据类型</a></h1>
<h2 id="c-基本数据类型"><a class="header" href="#c-基本数据类型">C++ 基本数据类型</a></h2>
<div class="table-wrapper"><table><thead><tr><th>数据类型</th><th>描述</th><th>大小（字节）</th><th>范围/取值示例</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>布尔类型，表示真或假</td><td>1</td><td><code>true</code> 或 <code>false</code></td></tr>
<tr><td><code>char</code></td><td>字符类型，通常用于存储 ASCII 字符</td><td>1</td><td>-128 到 127 或 0 到 255（取决于有符号或无符号）</td></tr>
<tr><td><code>signed char</code></td><td>有符号字符类型</td><td>1</td><td>-128 到 127</td></tr>
<tr><td><code>unsigned char</code></td><td>无符号字符类型</td><td>1</td><td>0 到 255</td></tr>
<tr><td><code>wchar_t</code></td><td>宽字符类型，用于存储 Unicode 字符</td><td>2 或 4</td><td>取决于平台，通常 2 或 4 字节</td></tr>
<tr><td><code>char16_t</code></td><td>16 位 Unicode 字符类型（C++11）</td><td>2</td><td>0 到 65,535</td></tr>
<tr><td><code>char32_t</code></td><td>32 位 Unicode 字符类型（C++11）</td><td>4</td><td>0 到 4,294,967,295</td></tr>
<tr><td><code>short</code></td><td>短整型</td><td>2</td><td>-32,768 到 32,767</td></tr>
<tr><td><code>unsigned short</code></td><td>无符号短整型</td><td>2</td><td>0 到 65,535</td></tr>
<tr><td><code>int</code></td><td>整型</td><td>4</td><td>-2,147,483,648 到 2,147,483,647</td></tr>
<tr><td><code>unsigned int</code></td><td>无符号整型</td><td>4</td><td>0 到 4,294,967,295</td></tr>
<tr><td><code>long</code></td><td>长整型</td><td>4 或 8</td><td>取决于平台</td></tr>
<tr><td><code>unsigned long</code></td><td>无符号长整型</td><td>4 或 8</td><td>取决于平台</td></tr>
<tr><td><code>long long</code></td><td>长长整型（C++11）</td><td>8</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr>
<tr><td><code>unsigned long long</code></td><td>无符号长长整型（C++11）</td><td>8</td><td>0 到 18,446,744,073,709,551,615</td></tr>
<tr><td><code>float</code></td><td>单精度浮点数</td><td>4</td><td>约 ±3.4e±38（6-7 位有效数字）</td></tr>
<tr><td><code>double</code></td><td>双精度浮点数</td><td>8</td><td>约 ±1.7e±308（15 位有效数字）</td></tr>
<tr><td><code>long double</code></td><td>扩展精度浮点数</td><td>8、12 或 16</td><td>取决于平台</td></tr>
</tbody></table>
</div>
<h2 id="c-修饰符"><a class="header" href="#c-修饰符">C++ 修饰符</a></h2>
<div class="table-wrapper"><table><thead><tr><th>修饰符</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>signed</code></td><td>有符号类型（默认）</td><td><code>signed int x = -10;</code></td></tr>
<tr><td><code>unsigned</code></td><td>无符号类型</td><td><code>unsigned int y = 10;</code></td></tr>
<tr><td><code>short</code></td><td>短整型</td><td><code>short int z = 100;</code></td></tr>
<tr><td><code>long</code></td><td>长整型</td><td><code>long int a = 100000;</code></td></tr>
<tr><td><code>static</code></td><td>静态存储期，或内部链接，或类级别共享</td><td><code>static int count = 0;</code></td></tr>
<tr><td><code>const</code></td><td>常量，值不可修改</td><td><code>const int b = 5;</code></td></tr>
<tr><td><code>constexpr</code></td><td>编译期常量，值在编译时计算，可用于常量表达式和元编程</td><td><code>constexpr int size = 10;</code></td></tr>
<tr><td><code>volatile</code></td><td>变量可能被意外修改，禁止编译器优化</td><td><code>volatile int c = 10;</code></td></tr>
<tr><td><code>mutable</code></td><td>类成员可以在 <code>const</code> 对象中修改</td><td><code>mutable int counter;</code></td></tr>
<tr><td><code>extern</code></td><td>声明一个在其他源文件中定义的变量或函数，用于跨文件共享全局符号</td><td><code>extern int global_var;</code></td></tr>
<tr><td><code>register</code></td><td>建议编译器将变量存放在 CPU 寄存器中以提高访问速度（现代编译器多已自动优化）</td><td><code>register int counter = 0;</code></td></tr>
</tbody></table>
</div>
<h2 id="c11-新增数据类型"><a class="header" href="#c11-新增数据类型">C++11 新增数据类型</a></h2>
<div class="table-wrapper"><table><thead><tr><th>数据类型</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>auto</code></td><td>自动类型推断</td><td><code>auto x = 10;</code></td></tr>
<tr><td><code>decltype</code></td><td>获取表达式的类型</td><td><code>decltype(x) y = 20;</code></td></tr>
<tr><td><code>nullptr</code></td><td>空指针常量</td><td><code>int* ptr = nullptr;</code></td></tr>
<tr><td><code>std::initializer_list</code></td><td>初始化列表类型</td><td><code>std::initializer_list&lt;int&gt; list = {1, 2, 3};</code></td></tr>
<tr><td><code>std::tuple</code></td><td>元组类型，可以存储多个不同类型的值</td><td><code>std::tuple&lt;int, float, char&gt; t(1, 2.0, 'a');</code></td></tr>
</tbody></table>
</div>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<h3 id="宽字符类型-wchar_t"><a class="header" href="#宽字符类型-wchar_t"><strong>宽字符类型 (<code>wchar_t</code>)</strong></a></h3>
<p><code>wchar_t</code> 是 C++ 中用于存储宽字符的类型，广泛应用于需要处理 Unicode 字符集的程序中。与普通的 <code>char</code> 类型（通常用于存储 ASCII 字符）不同，<code>wchar_t</code> 的设计目的是为了支持更大的字符集，特别是 Unicode。由于 <code>wchar_t</code> 需要存储更多的字符信息，因此其大小取决于平台，通常在 2 或 4 字节之间。在一些平台上，<code>wchar_t</code> 被定义为 2 字节（16 位），在其他平台上则可能是 4 字节（32 位）。使用 <code>wchar_t</code> 可以轻松处理如中文、日文等非拉丁字符。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    wchar_t wide_char = L'我';  // 使用 wchar_t 存储一个 Unicode 字符
    std::wcout &lt;&lt; wide_char &lt;&lt; std::endl;  // 输出：我
    return 0;
}
</code></pre>
<h3 id="char16_t-和-char32_t"><a class="header" href="#char16_t-和-char32_t"><strong><code>char16_t</code> 和 <code>char32_t</code></strong></a></h3>
<p><code>char16_t</code> 和 <code>char32_t</code> 是 C++11 引入的专门用于存储 Unicode 字符的类型，分别表示 16 位和 32 位字符类型。<code>char16_t</code> 是为了支持 UTF-16 编码而设计的，而 <code>char32_t</code> 是为了支持 UTF-32 编码。<code>char16_t</code> 用 2 字节来存储一个字符，而 <code>char32_t</code> 用 4 字节存储一个字符。这两种类型能够直接表示 Unicode 字符，而无需进行额外的编码转换。</p>
<p><code>char16_t</code> 和 <code>char32_t</code> 提供了对更广泛字符集的支持，尤其适合那些需要处理全球化文本的应用程序。<code>char16_t</code> 和 <code>char32_t</code> 作为 Unicode 字符的表示方式，分别与 UTF-16 和 UTF-32 编码兼容，能够表示包括基本多语言平面（BMP）以及更高平面字符在内的所有 Unicode 字符。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    char16_t char16 = u'你';  // 使用 char16_t 存储一个 UTF-16 编码的字符
    char32_t char32 = U'你';  // 使用 char32_t 存储一个 UTF-32 编码的字符

    std::wcout &lt;&lt; "char16_t: " &lt;&lt; char16 &lt;&lt; std::endl;
    std::wcout &lt;&lt; "char32_t: " &lt;&lt; char32 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<h3 id="volatile"><a class="header" href="#volatile"><code>volatile</code></a></h3>
<p>在现代 CPU 中通常包含多个核心，每个核心都有独立的缓存。多个核心可能同时缓存了同一段主存的数据。一般情况下，缓存和主存的数据是一致的，但在多线程并发场景下，由于缓存写回策略的影响，数据的修改可能无法及时同步到主存，从而导致数据不一致的问题。</p>
<p><code>volatile</code> 关键字用于告诉编译器：某个变量的值可能随时被外部因素（如其他线程、硬件设备或中断）修改，因此缓存中的值并不可靠。出于这个原因，编译器在访问该变量时不会进行过度优化，而是强制每次都从内存中读取最新的值。</p>
<ol>
<li>
<p>可见性
<code>volatile</code> 保证变量的值在不同线程或不同硬件环境下始终是“最新可见”的。即使某个核心或寄存器中有缓存数据，访问 <code>volatile</code> 变量时也必须直接从内存或硬件中获取，而不是使用缓存副本。</p>
</li>
<li>
<p>不可优化
在编译阶段，为了提高执行效率，编译器会进行多种优化。例如：</p>
<pre><code class="language-cpp">int flag = 0;
while (flag == 0) {
    // 等待 flag 改变
}
</code></pre>
<p>若 <code>flag</code> 未被声明为 <code>volatile</code>，编译器可能认为 <code>flag</code> 始终等于 0，于是直接将循环优化为 <code>while(false)</code>，导致死循环。</p>
<p>使用 <code>volatile</code> 可以禁止类似的优化，包括 <strong>消除优化</strong>、<strong>传播优化</strong> 和 <strong>合并优化</strong>，从而保证变量的读写行为不会被错误简化。</p>
</li>
<li>
<p>顺序性
<code>volatile</code> 还会在一定程度上影响指令的顺序。编译器在处理 <code>volatile</code> 变量时，会保证读写操作不会因乱序优化而颠倒，从而维持必要的执行顺序。</p>
</li>
</ol>
<p><code>volatile</code> 在嵌入式编程和多线程编程中尤为重要：</p>
<ul>
<li><strong>多线程共享变量</strong>：确保不同线程读取到的值保持一致。</li>
<li><strong>中断处理</strong>：中断可能随时修改某个变量，主程序通过 <code>volatile</code> 保证能正确检测到变化。</li>
<li><strong>硬件寄存器访问</strong>：在嵌入式系统中，硬件寄存器的值可能在后台自动更新，必须通过 <code>volatile</code> 确保每次访问都直接读取硬件寄存器的当前值。</li>
</ul>
<p>尽管 <code>volatile</code> 在保证可见性、防止编译器优化、维持一定顺序性方面很有用，但它并不是并发编程的“万能钥匙”，主要局限性如下：</p>
<ol>
<li>
<p><strong>不保证原子性</strong></p>
<ul>
<li>
<p><code>volatile</code> 仅保证读写操作不会被优化和缓存，但不能保证复合操作的原子性。</p>
</li>
<li>
<p>例如：</p>
<pre><code class="language-cpp">volatile int counter = 0;
counter++; // 实际分解为：读取 -&gt; 修改 -&gt; 写回
</code></pre>
<p>在多线程环境下可能发生竞态条件，导致结果错误。</p>
</li>
</ul>
</li>
<li>
<p><strong>不等同于内存屏障（Memory Barrier）</strong></p>
<ul>
<li><code>volatile</code> 的“顺序性”只作用于编译器层面，防止指令在编译时被重排。</li>
<li>但在 CPU 的指令执行层面，仍然可能发生硬件乱序执行。若需要在多线程同步中严格保证内存访问顺序，还需要使用更强的同步原语（如 C++ 中的 <code>std::atomic</code> 或内存屏障指令）。</li>
</ul>
</li>
<li>
<p><strong>性能开销</strong></p>
<ul>
<li>每次访问 <code>volatile</code> 变量都要从内存中读取最新值，无法使用寄存器缓存，可能造成一定性能损失。</li>
</ul>
</li>
<li>
<p><strong>局限于特定场景</strong></p>
<ul>
<li>
<p><code>volatile</code> 更适合用于：</p>
<ul>
<li>标志位（如中断标志、任务完成标志）。</li>
<li>硬件寄存器访问。</li>
</ul>
</li>
<li>
<p>但在复杂的多线程共享数据同步场景下，仅依赖 <code>volatile</code> 是不够的，往往需要互斥锁、原子操作或更高级的同步机制。</p>
</li>
</ul>
</li>
</ol>
<h3 id="mutable"><a class="header" href="#mutable"><code>mutable</code></a></h3>
<p><code>mutable</code> 关键字是用来修饰类的成员变量的，意味着即使该对象是常量（<code>const</code>），这些成员变量也可以被修改。通常，<code>mutable</code> 用于那些希望在 <code>const</code> 方法中进行修改的成员变量，比如用于缓存的成员变量。通过 <code>mutable</code>，我们可以在 <code>const</code> 方法中修改这些成员，而不会破坏 <code>const</code> 对象的常量性。</p>
<p>以下示例展示了在 <code>const</code> 方法中修改 <code>mutable</code> 成员变量的情况：</p>
<pre><code class="language-cpp">class MyClass {
public:
    mutable int cache;  // 使用 mutable 修饰的成员变量

    MyClass() : cache(0) {}

    void updateCache() const {
        // 即使 updateCache 是 const 方法，cache 依然可以被修改
        cache++;
    }
};

int main() {
    const MyClass obj;
    obj.updateCache();  // 可在 const 对象上调用
    std::cout &lt;&lt; obj.cache &lt;&lt; std::endl;  // 输出：1
    return 0;
}
</code></pre>
<h3 id="decltype"><a class="header" href="#decltype"><code>decltype</code></a></h3>
<p><code>decltype</code> 是 C++11 引入的一个关键字，用于获取表达式的类型，而不需要显式地声明变量的类型。它通常用于模板编程中，或者当我们不确定某个表达式的类型时。<code>decltype</code> 可以非常方便地获取复杂类型，尤其是当类型通过复杂的表达式推导出来时。</p>
<p>例如，以下代码通过 <code>decltype</code> 获取了变量 <code>x</code> 的类型，并且通过 <code>auto</code> 使得代码更加简洁：</p>
<pre><code class="language-cpp">int x = 5;
decltype(x) y = 10;  // y 的类型是 int，因为 x 是 int

auto z = x + y;  // z 的类型由编译器推断，类型为 int
</code></pre>
<h3 id="stdinitializer_list"><a class="header" href="#stdinitializer_list"><code>std::initializer_list</code></a></h3>
<p><code>std::initializer_list</code> 是 C++11 引入的一个模板类，用于支持初始化列表。它允许在创建对象时通过花括号 <code>{}</code> 来传递多个值。<code>initializer_list</code> 主要用于支持类的构造函数接收不定数量的参数，或者将多个值传递给函数，特别适用于那些需要接收多个初始值的容器类型。</p>
<pre><code class="language-cpp">#include &lt;initializer_list&gt;
#include &lt;iostream&gt;

void printList(std::initializer_list&lt;int&gt; list) {
    for (auto i : list) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}

int main() {
    printList({1, 2, 3, 4, 5});  // 使用 initializer_list
    return 0;
}
</code></pre>
<h3 id="stdtuple"><a class="header" href="#stdtuple"><code>std::tuple</code></a></h3>
<p><code>std::tuple</code> 是 C++11 引入的一个模板类，允许存储多个不同类型的元素。与数组和 <code>std::vector</code> 不同，<code>tuple</code> 允许每个元素拥有不同的类型。<code>std::tuple</code> 是一个非常强大的工具，可以将多个不同类型的值打包在一起，并在需要时访问这些值。它常用于函数返回多个不同类型的值，或在需要将多种类型的参数组合起来时使用。</p>
<pre><code class="language-cpp">#include &lt;tuple&gt;
#include &lt;iostream&gt;

int main() {
    std::tuple&lt;int, double, char&gt; t(1, 3.14, 'A');

    std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; ", ";  // 1
    std::cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; ", ";  // 3.14
    std::cout &lt;&lt; std::get&lt;2&gt;(t) &lt;&lt; std::endl;  // A

    // 修改 tuple 的元素
    std::get&lt;0&gt;(t) = 42;
    std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; std::endl;  // 42

    return 0;
}
</code></pre>
<h3 id="static"><a class="header" href="#static"><code>static</code></a></h3>
<p><code>static</code> 关键字在 C++ 中有三种主要用途，取决于它所修饰的对象和作用域，而在C语言中由于不支持类从而只支持修饰<strong>局部静态变量</strong>和<strong>外部静态变量、函数</strong>。</p>
<h4 id="1-局部变量函数内--改变存储期"><a class="header" href="#1-局部变量函数内--改变存储期">1. 局部变量（函数内）- 改变存储期</a></h4>
<p>当 <code>static</code> 用于函数内的局部变量时，它改变了变量的<strong>存储期</strong>（Storage Duration）。</p>
<ul>
<li><strong>存储期</strong>：<code>static</code> 局部变量在程序运行期间<strong>只会被初始化一次</strong>，且生命周期与整个程序相同（静态存储期），但其<strong>作用域</strong>仍限定在定义它的函数内部。</li>
<li><strong>用途</strong>：用于记录函数被调用的次数，或者在多次调用中保持某个状态。</li>
</ul>
<!-- end list -->
<pre><code class="language-cpp">void func() {
    static int count = 0; // 只在程序启动时初始化一次
    count++;
    std::cout &lt;&lt; "Count: " &lt;&lt; count &lt;&lt; std::endl;
}
// 每次调用 func()，count 都会递增，而不是重置为 0
</code></pre>
<h4 id="2-全局变量和函数文件作用域--改变链接性"><a class="header" href="#2-全局变量和函数文件作用域--改变链接性">2. 全局变量和函数（文件作用域）- 改变链接性</a></h4>
<p>当 <code>static</code> 用于全局变量或普通函数时，它改变了它们的<strong>链接性</strong>（Linkage）。</p>
<ul>
<li><strong>链接性</strong>：将默认的<strong>外部链接</strong>（External Linkage，可以在其他源文件访问）改为<strong>内部链接</strong>（Internal Linkage）。</li>
<li><strong>用途</strong>：使变量或函数只在其定义的**当前翻译单元（源文件）**中可见和可用，避免与其他源文件中的同名标识符发生冲突。</li>
</ul>
<!-- end list -->
<pre><code class="language-cpp">// file1.cpp
static int global_data = 10; // 只能在 file1.cpp 中访问
static void helper_func() {  // 只能在 file1.cpp 中调用
    // ...
}
</code></pre>
<h4 id="3-类成员成员变量和成员函数--类级别共享"><a class="header" href="#3-类成员成员变量和成员函数--类级别共享">3. 类成员（成员变量和成员函数）- 类级别共享</a></h4>
<p>当 <code>static</code> 用于类内部的成员时，它使成员成为<strong>类级别</strong>的共享资源，而不是每个对象独有的资源。</p>
<ul>
<li><strong>静态成员变量</strong>：
<ul>
<li>该变量为<strong>所有</strong>类的对象所共享，<strong>只存在一个副本</strong>。</li>
<li>它必须在<strong>类外部</strong>进行定义和初始化（除非是 <code>const static</code> 整数类型）。</li>
<li>可以通过类名或对象访问。</li>
</ul>
</li>
<li><strong>静态成员函数</strong>：
<ul>
<li>它不依赖于任何特定的类对象。</li>
<li>它<strong>不能</strong>直接访问非静态的成员变量或成员函数（因为它没有 <code>this</code> 指针）。</li>
<li>通常用于访问和操作静态成员变量，或作为工具函数。</li>
</ul>
</li>
</ul>
<!-- end list -->
<pre><code class="language-cpp">class MyClass {
public:
    static int object_count; // 静态成员变量声明

    MyClass() {
        object_count++;
    }

    static int get_count() { // 静态成员函数
        return object_count;
    }
};

// 在类外定义和初始化静态成员
int MyClass::object_count = 0;

int main() {
    MyClass obj1;
    MyClass obj2;
    // 使用类名直接访问静态成员
    std::cout &lt;&lt; MyClass::get_count() &lt;&lt; std::endl; // 输出：2
    return 0;
}
</code></pre>
<h3 id="auto"><a class="header" href="#auto"><code>auto</code></a></h3>
<p><code>auto</code> 是 C++11 引入的一个关键字，允许编译器自动推导出变量的类型。<code>auto</code> 使得代码更加简洁，并且减少了显式指定类型的需求，尤其在处理复杂类型时非常有用。<code>auto</code> 通常用于变量声明时，让编译器根据赋值的表达式自动推断类型，这在迭代器和模板编程中尤其常见。</p>
<pre><code class="language-cpp">int main() {
    auto x = 10;  // x 的类型是 int
    auto y = 3.14;  // y 的类型是 double

    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<h3 id="const"><a class="header" href="#const"><code>const</code></a></h3>
<p>在 C 语言和 C++ 中，<code>const</code> 都用于限定变量为“只读”。
但是 C++ 对 <code>const</code> 的支持更为强大和灵活，它不仅影响编译器的检查机制，还会在类型系统中起作用。</p>
<ol>
<li>
<p>基本特性</p>
<ul>
<li>
<p>在 C 中，<code>const</code> 修饰的变量默认是只读存储（readonly），但本质上仍然是变量，而不是常量。</p>
<pre><code class="language-c">const int x = 10;
int *p = (int*)&amp;x; // 通过强制转换依然能修改
*p = 20;           // UB（未定义行为）
</code></pre>
</li>
<li>
<p>在 C++ 中，<code>const</code> 更严格，编译器会将其视为类型的一部分。</p>
<pre><code class="language-cpp">const int x = 10;
x = 20;  // 编译错误，禁止修改
</code></pre>
</li>
</ul>
</li>
<li>
<p>修饰位置</p>
<p><code>const</code> 可以修饰不同对象，表达不同含义：</p>
<ul>
<li>
<p>修饰变量：值不可修改。</p>
</li>
<li>
<p>修饰指针：</p>
<pre><code class="language-cpp">const int *p;  // 指向常量的指针（*p 不可改，p 可改）
int *const p;  // 常量指针（p 不可改，*p 可改）
const int *const p; // 指向常量的常量指针
</code></pre>
</li>
<li>
<p>修饰函数参数：保证函数体内不会修改该参数。</p>
</li>
<li>
<p>修饰成员函数：表示该成员函数不会修改对象的成员变量，本质上是修饰<strong>this指针</strong>。</p>
</li>
</ul>
</li>
<li>
<p>作用域与链接</p>
<ul>
<li>在 C 中，<code>const</code> 全局变量默认是 <strong>外部链接</strong>，除非显式加 <code>static</code>使得在本文件可见。</li>
<li>在 C++ 中，<code>const</code> 全局变量默认是 <strong>内部链接</strong>（只在本翻译单元内可见），若要在多个文件共享，需加 <code>extern</code>。</li>
</ul>
</li>
<li>
<p>局限性</p>
<ul>
<li><code>const</code> 并不保证编译期求值，它仅仅保证“运行时不能被修改”。</li>
<li>如果需要编译期常量（如数组大小、模板参数），在 C++11 之前通常使用 <code>#define</code> 或 <code>enum hack</code>。</li>
</ul>
</li>
</ol>
<h3 id="constexpr"><a class="header" href="#constexpr"><code>constexpr</code></a></h3>
<p><code>constexpr</code> 是 C++11 引入的关键字，用于声明“编译期常量表达式”。它不仅意味着值不可变，更重要的是：
编译器必须在编译期对其进行求值（只要表达式满足常量表达式要求）。</p>
<ol>
<li>
<p>基本特性</p>
<ul>
<li>
<p><code>constexpr</code> 变量一定是常量，并且能在编译期被计算：</p>
<pre><code class="language-cpp">constexpr int size = 10;
int arr[size]; // 合法
</code></pre>
</li>
<li>
<p>与 <code>const</code> 不同，<code>constexpr</code> 要求初始化表达式必须是编译期可计算的常量。</p>
</li>
</ul>
</li>
<li>
<p>函数支持</p>
<ul>
<li>
<p><code>constexpr</code> 还可以修饰函数：</p>
<pre><code class="language-cpp">constexpr int square(int x) {
    return x * x;
}
int arr[square(5)]; // 在编译期计算为 25
</code></pre>
</li>
<li>
<p>这样的函数可以在编译期使用，也可以在运行时调用（若传入非常量参数）。</p>
</li>
</ul>
</li>
<li>
<p>类与构造函数</p>
<ul>
<li>C++11 起，<code>constexpr</code> 可以修饰构造函数，表示该类的对象可以在编译期生成常量。</li>
<li>C++14/17 对 <code>constexpr</code> 的限制逐步放宽，例如允许有分支、循环，更接近普通函数。</li>
</ul>
</li>
<li>
<p>区别于 <code>const</code></p>
<ul>
<li><code>const</code>：运行期常量（只读），初始化表达式可以是运行时值，可以使用<code>const_cast</code>去除限定。</li>
<li><code>constexpr</code>：编译期常量，初始化表达式必须在编译期可求值。</li>
</ul>
<p>对比示例：</p>
<pre><code class="language-cpp">const int a = std::time(nullptr); // 合法，运行期决定
constexpr int b = std::time(nullptr); // 错误，不能在编译期求值
</code></pre>
</li>
</ol>
<h3 id="extern"><a class="header" href="#extern"><code>extern</code></a></h3>
<p><code>extern</code> 关键字用于<strong>声明</strong>而非定义变量或函数。
它通常出现在多文件项目中，用于在一个文件中访问另一个文件定义的全局变量或函数。</p>
<ul>
<li>
<p>作用：</p>
<ul>
<li>告诉编译器“该变量或函数在别处定义”；</li>
<li>不会为其分配存储空间（除非在定义处）；</li>
<li>避免重复定义全局符号。</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">// file1.cpp
int count = 10;  // 定义全局变量

// file2.cpp
#include &lt;iostream&gt;
extern int count;  // 声明外部变量（非定义）
int main() {
    std::cout &lt;&lt; count &lt;&lt; std::endl;  // 输出 10
    return 0;
}
</code></pre>
<ul>
<li>
<p>在C++中：</p>
<p>C++ 默认情况下，<code>const</code> 全局变量具有内部链接（<code>internal linkage</code>），也就是仅在本文件内可见。
若希望跨文件共享一个常量变量，必须结合 <code>extern</code> 使用：</p>
<pre><code class="language-cpp">// file1.cpp
extern const int BUFFER_SIZE = 1024;

// file2.cpp
extern const int BUFFER_SIZE;  // 声明外部常量
</code></pre>
</li>
<li>
<p>与函数结合使用：</p>
<p>对于函数来说，<code>extern</code> 是默认属性，即所有非 <code>static</code> 函数都具有外部链接性，因此通常可省略：</p>
<pre><code class="language-cpp">extern void foo();  // 与 void foo(); 等价
</code></pre>
</li>
</ul>
<h3 id="register"><a class="header" href="#register"><code>register</code></a></h3>
<p><code>register</code> 是早期 C/C++ 时代用于<strong>提升变量访问速度</strong>的关键字，提示编译器将变量存储在 CPU 寄存器中，而非内存中。</p>
<ul>
<li>
<p>特点：</p>
<ul>
<li>变量可能被存放在 CPU 寄存器中，而非内存；</li>
<li>不能对 <code>register</code> 变量使用取地址操作符 <code>&amp;</code>；</li>
<li>仅能修饰局部变量或函数参数；</li>
<li>在现代编译器中通常<strong>被自动优化机制取代</strong>，因此多用于教学或历史理解。</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    register int i;  // 建议编译器将 i 放入寄存器中
    for (i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<ul>
<li>
<p><strong>局限性：</strong></p>
<ul>
<li>编译器不保证一定会将其放入寄存器；</li>
<li>不能取地址（即 <code>&amp;i</code> 是非法的）；</li>
<li>在现代 C++ 中几乎没有实际性能提升，优化器会自动选择合适的寄存器分配策略。</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../Basis/Types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../Basis/Types/Derived_Types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../Basis/Types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../Basis/Types/Derived_Types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
