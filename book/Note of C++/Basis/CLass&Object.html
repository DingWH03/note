<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>类与对象 - Note of C++</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Note of C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DingWH03/note-c-plus-plus" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/DingWH03/note-c-plus-plus/edit/master/src/Basis/CLass&amp;Object.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="类与对象"><a class="header" href="#类与对象">类与对象</a></h1>
<p>C++ 是一种支持面向对象编程（Object-Oriented Programming, OOP）的语言。
在面向对象的设计思想中，类（Class）是 C++ 的核心特性之一，常被称为用户自定义的数据类型（user-defined type）。</p>
<p>类用于定义对象的结构与行为，是一种将数据与操作这些数据的函数封装在一起的抽象描述。
在类中，用于存储数据的部分称为成员变量（Member Variables），而用于操作这些数据的函数称为成员函数（Member Functions）。</p>
<p>类本质上是一种模板（Template）或蓝图（Blueprint），通过它可以创建出多个具有相同属性和行为的具体<strong>实例</strong>，这些实例被称为对象（Objects）。每个对象都拥有属于自己的成员变量副本，并可以通过成员函数来执行特定的操作。</p>
<h2 id="一类的结构"><a class="header" href="#一类的结构">一、类的结构</a></h2>
<p>在 C++ 中，<strong>类（Class）<strong>是一种由用户定义的数据类型（User-defined Data Type），
它将</strong>数据（成员变量）<strong>与</strong>操作数据的函数（成员函数）<strong>有机地结合在一起，
从而实现</strong>封装（Encapsulation）<strong>与</strong>抽象（Abstraction）</strong>。</p>
<p>一个类的基本结构如下：</p>
<pre><code class="language-cpp">class ClassName {
private:
    // 私有成员（数据与函数）
protected:
    // 受保护成员
public:
    // 公有成员
};
</code></pre>
<h3 id="1-类的基本组成"><a class="header" href="#1-类的基本组成">1. 类的基本组成</a></h3>
<p>类由以下几个主要部分构成：</p>
<div class="table-wrapper"><table><thead><tr><th>组成部分</th><th>说明</th></tr></thead><tbody>
<tr><td>类名（Class Name）</td><td>类的标识符，用于定义和引用该类。</td></tr>
<tr><td>成员变量（Member Variables）</td><td>用于存储对象状态的数据。</td></tr>
<tr><td>成员函数（Member Functions）</td><td>用于操作数据或定义对象行为的函数。</td></tr>
<tr><td>访问控制符（Access Specifiers）</td><td>控制外部对类成员的访问权限：<code>private</code>、<code>protected</code>、<code>public</code>。</td></tr>
<tr><td>构造函数与析构函数（Constructor &amp; Destructor）</td><td>对象创建与销毁时自动调用的特殊成员函数。</td></tr>
<tr><td>静态成员（Static Members）</td><td>属于类本身而非某个对象的成员。</td></tr>
<tr><td>友元（Friend）</td><td>特殊访问权限，允许外部函数或类访问私有成员。</td></tr>
</tbody></table>
</div>
<h3 id="2-访问控制符access-specifiers"><a class="header" href="#2-访问控制符access-specifiers">2. 访问控制符（Access Specifiers）</a></h3>
<p>访问控制符用于限定类成员的可见性和访问范围：</p>
<div class="table-wrapper"><table><thead><tr><th>控制符</th><th>访问范围</th><th>典型用途</th></tr></thead><tbody>
<tr><td><code>private</code></td><td>仅类内可访问</td><td>封装内部实现细节</td></tr>
<tr><td><code>protected</code></td><td>类内和子类可访问</td><td>继承时保留部分访问权限</td></tr>
<tr><td><code>public</code></td><td>任何地方都可访问</td><td>提供对外接口</td></tr>
</tbody></table>
</div>
<p>示例：</p>
<pre><code class="language-cpp">class Example {
private:
    int secret;          // 私有成员
protected:
    int semi_secret;     // 受保护成员
public:
    int visible;         // 公有成员
};
</code></pre>
<blockquote>
<p>默认情况下，<code>class</code> 的成员默认是 <strong>private</strong>，
而 <code>struct</code> 的成员默认是 <strong>public</strong>。</p>
</blockquote>
<h3 id="3-成员变量member-variables"><a class="header" href="#3-成员变量member-variables">3. 成员变量（Member Variables）</a></h3>
<p>成员变量用于存储对象的状态。
每个对象都会拥有独立的一份成员变量副本。</p>
<pre><code class="language-cpp">class Student {
private:
    std::string name;
    int age;
};
</code></pre>
<blockquote>
<p>成员变量可以是基本类型、对象、指针、引用、数组、容器等。</p>
</blockquote>
<p>也可以为成员变量提供默认初始值（C++11 起支持）：</p>
<pre><code class="language-cpp">class Point {
    int x = 0;
    int y = 0;
};
</code></pre>
<h3 id="4-成员函数member-functions"><a class="header" href="#4-成员函数member-functions">4. 成员函数（Member Functions）</a></h3>
<p>成员函数用于定义对象的行为，通常用于访问和修改成员变量。</p>
<pre><code class="language-cpp">class Student {
private:
    std::string name;
    int age;

public:
    void setInfo(const std::string&amp; n, int a) {
        name = n;
        age = a;
    }

    void display() {
        std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; std::endl;
    }
};
</code></pre>
<p>也可以在类外定义成员函数：</p>
<pre><code class="language-cpp">void Student::display() {
    std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; std::endl;
}
</code></pre>
<h3 id="5-构造函数constructor"><a class="header" href="#5-构造函数constructor">5. 构造函数（Constructor）</a></h3>
<p>构造函数在对象创建时自动执行，用于初始化成员变量。
它与类同名，无返回值。</p>
<pre><code class="language-cpp">class Student {
private:
    std::string name;
    int age;

public:
    // 构造函数
    Student(const std::string&amp; n, int a) : name(n), age(a) {
        std::cout &lt;&lt; "Constructor called." &lt;&lt; std::endl;
    }
};
</code></pre>
<p>构造函数的种类包括：</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody>
<tr><td>默认构造函数</td><td>无参版本</td><td><code>Student()</code></td></tr>
<tr><td>有参构造函数</td><td>初始化时传参</td><td><code>Student("张三", 20)</code></td></tr>
<tr><td>拷贝构造函数</td><td>用已有对象创建新对象</td><td><code>Student(const Student&amp; s)</code></td></tr>
</tbody></table>
</div>
<p>构造函数支持多态，可以使用多个参数不同的构造函数，在使用时会自动匹配。</p>
<h3 id="6-析构函数destructor"><a class="header" href="#6-析构函数destructor">6. 析构函数（Destructor）</a></h3>
<p>析构函数在对象销毁时自动调用，用于资源释放或清理。</p>
<pre><code class="language-cpp">class Student {
public:
    ~Student() {
        std::cout &lt;&lt; "Destructor called." &lt;&lt; std::endl;
    }
};
</code></pre>
<blockquote>
<p>析构函数名以 <code>~</code> 开头，无参、无返回值，每个类最多有一个析构函数。</p>
</blockquote>
<h3 id="7-this-指针"><a class="header" href="#7-this-指针">7. this 指针</a></h3>
<p><code>this</code> 是一个隐含指针，指向调用成员函数的<strong>当前对象</strong>。
它可用于区分成员变量与同名参数：</p>
<pre><code class="language-cpp">class Student {
private:
    std::string name;

public:
    Student(const std::string&amp; name) {
        this-&gt;name = name; // 区分成员变量与参数
    }
};
</code></pre>
<h3 id="8-静态成员static-members"><a class="header" href="#8-静态成员static-members">8. 静态成员（Static Members）</a></h3>
<p>静态成员属于类本身，而非具体对象。
所有对象共享同一份静态数据。</p>
<p>静态成员分为两类：</p>
<ol>
<li>静态成员变量（Static Member Variables）</li>
<li>静态成员函数（Static Member Functions）</li>
</ol>
<h4 id="1静态成员变量"><a class="header" href="#1静态成员变量">(1)静态成员变量</a></h4>
<p>静态成员变量在所有对象之间共享同一份存储空间。
它不依赖于任何对象存在，无论创建多少个对象，这个变量都只有一份。</p>
<p>因此，静态成员变量常用于表示类级别的公共信息，例如计数器、配置、全局状态等。</p>
<pre><code class="language-cpp">class Counter {
public:
    static int count;
    Counter() { count++; }
};

int Counter::count = 0;
</code></pre>
<h4 id="2静态函数变量"><a class="header" href="#2静态函数变量">(2)静态函数变量</a></h4>
<p>静态成员函数同样属于类本身，而不是对象。
它的主要特征是：</p>
<ul>
<li>不依赖任何对象实例</li>
<li>无法访问非静态成员变量或函数（因为没有具体对象可供操作）</li>
<li>通常用于类级别的操作，如访问静态数据或执行与对象无关的逻辑。</li>
<li>没有 <code>this</code> 指针，因为它不属于任何对象</li>
</ul>
<pre><code class="language-cpp">class Counter {
private:
    static int count;

public:
    Counter() { count++; }

    // 静态成员函数
    static void showCount() {
        std::cout &lt;&lt; "Current count: " &lt;&lt; count &lt;&lt; std::endl;
    }
};

// 类外定义静态变量
int Counter::count = 0;

int main() {
    Counter a, b;
    Counter::showCount();  // 通过类名访问
    a.showCount();         // 也可通过对象访问
}
</code></pre>
<h3 id="9-常成员const-members"><a class="header" href="#9-常成员const-members">9. 常成员（const Members）</a></h3>
<ul>
<li><strong>常成员函数</strong>：在函数后加 <code>const</code>，表示不修改成员变量。</li>
<li><strong>常对象</strong>：对象一旦定义，其状态不可更改。</li>
</ul>
<pre><code class="language-cpp">class Point {
private:
    int x, y;

public:
    void display() const {
        std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
    }
};
</code></pre>
<h3 id="10-友元friend"><a class="header" href="#10-友元friend">10. 友元（Friend）</a></h3>
<p>友元函数或友元类可以访问类的私有成员。
这在<strong>操作符重载</strong>、类间紧密协作时非常有用。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Box {
private:
    int width;
public:
    void set_width(int val){
        width = val;
    }
    friend void printWidth(Box b);
};

void printWidth(Box b) {
    std::cout &lt;&lt; "Width: " &lt;&lt; b.width &lt;&lt; std::endl;
}

int main(){
    Box a;
    a.set_width(20);
    printWidth(a);
}
</code></pre>
<blockquote>
<p>友元会破坏封装性，应谨慎使用。</p>
<p>友元函数不是成员函数，不能用 对象.函数() 方式调用。它只是可以访问类私有成员的普通函数，调用方式与普通函数相同。</p>
</blockquote>
<h3 id="11-类的组合与嵌套"><a class="header" href="#11-类的组合与嵌套">11. 类的组合与嵌套</a></h3>
<p>一个类可以将另一个类作为成员，这种关系称为组合（Composition）。</p>
<pre><code class="language-cpp">class Address {
public:
    std::string city;
};

class Person {
public:
    std::string name;
    Address addr;  // 组合
};
</code></pre>
<blockquote>
<p>当对象销毁时，其组合成员也会自动销毁。</p>
</blockquote>
<h2 id="二对象"><a class="header" href="#二对象">二、对象</a></h2>
<p>在 C++ 中，对象（Object）是类的实例（Instance）。
当我们定义了一个类后，这个类本身只是一个抽象的模板或蓝图，
而对象才是真正占用内存、可操作的具体实体。</p>
<p>类定义了“事物的共性”，对象体现了“事物的个性”。</p>
<h3 id="1-对象的创建与定义"><a class="header" href="#1-对象的创建与定义">1. 对象的创建与定义</a></h3>
<p>定义一个类对象与定义普通变量非常相似：</p>
<pre><code class="language-cpp">class Student {
public:
    std::string name;
    int age;
};

int main() {
    Student s1;  // 创建对象 s1
    s1.name = "张三";
    s1.age = 20;

    Student s2;  // 再创建一个对象 s2
    s2.name = "李四";
    s2.age = 21;
}
</code></pre>
<blockquote>
<p>每个对象都有<strong>独立的成员变量副本</strong>，互不影响。</p>
</blockquote>
<p>例如：</p>
<pre><code class="language-cpp">s1.age = 20;
s2.age = 21;
// 修改 s1 的 age 不会影响 s2
</code></pre>
<h3 id="2-对象的初始化"><a class="header" href="#2-对象的初始化">2. 对象的初始化</a></h3>
<p>当类中定义了构造函数时，对象可以在定义时直接初始化：</p>
<pre><code class="language-cpp">class Point {
private:
    int x, y;

public:
    Point(int a, int b) {  // 构造函数
        x = a;
        y = b;
    }

    void show() {
        std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
    }
};

int main() {
    Point p1(1, 2);  // 调用构造函数
    Point p2 = Point(3, 4); // 另一种写法
    p1.show();
    p2.show();
}
</code></pre>
<blockquote>
<p>注意：对象创建时，构造函数会被自动调用；对象销毁时，析构函数会被自动调用。</p>
</blockquote>
<h3 id="3-对象的作用域与生命周期"><a class="header" href="#3-对象的作用域与生命周期">3. 对象的作用域与生命周期</a></h3>
<p>对象的生命周期与其<strong>定义的位置</strong>有关。</p>
<div class="table-wrapper"><table><thead><tr><th>定义位置</th><th>生命周期说明</th></tr></thead><tbody>
<tr><td>局部对象（栈上）</td><td>作用域结束时自动销毁</td></tr>
<tr><td>全局对象</td><td>程序结束时销毁</td></tr>
<tr><td>静态对象</td><td>程序结束时销毁</td></tr>
<tr><td>动态对象（堆上）</td><td>需要手动释放（使用 <code>new</code> / <code>delete</code>）</td></tr>
</tbody></table>
</div>
<p>示例：</p>
<pre><code class="language-cpp">class Example {
public:
    Example() { std::cout &lt;&lt; "Constructed\n"; }
    ~Example() { std::cout &lt;&lt; "Destructed\n"; }
};

int main() {
    Example local;            // 局部对象
    static Example global;    // 静态对象
    Example* ptr = new Example();  // 动态对象

    delete ptr; // 手动释放
}
</code></pre>
<p>输出顺序体现了不同对象的生命周期管理。</p>
<h3 id="4-对象数组"><a class="header" href="#4-对象数组">4. 对象数组</a></h3>
<p>可以定义一个包含多个对象的数组：</p>
<pre><code class="language-cpp">class Point {
public:
    int x, y;
    Point(int a = 0, int b = 0) : x(a), y(b) {}
};

int main() {
    Point arr[3] = { {1,2}, {3,4}, {5,6} };
    for (auto&amp; p : arr)
        std::cout &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")\n";
}
</code></pre>
<blockquote>
<p>若类中没有默认构造函数，则必须在定义对象数组时显式提供初始化参数。</p>
</blockquote>
<h3 id="5对象的指针与引用"><a class="header" href="#5对象的指针与引用">5.对象的指针与引用</a></h3>
<h4 id="1对象指针"><a class="header" href="#1对象指针">(1)对象指针</a></h4>
<p>和基本类型类似，可以使用指针指向对象。</p>
<pre><code class="language-cpp">Student s1;
Student* ptr = &amp;s1;
ptr-&gt;name = "王五";
ptr-&gt;age = 22;
</code></pre>
<blockquote>
<p>使用 <code>-&gt;</code> 运算符访问对象的成员。</p>
</blockquote>
<p>也可以使用 <code>new</code> 创建动态对象：</p>
<pre><code class="language-cpp">Student* stu = new Student;
stu-&gt;name = "赵六";
stu-&gt;age = 18;
delete stu; // 释放内存
</code></pre>
<h4 id="2对象引用"><a class="header" href="#2对象引用">(2)对象引用</a></h4>
<p>引用可以直接操作已有对象：</p>
<pre><code class="language-cpp">Student s1;
Student&amp; ref = s1;
ref.name = "张三";
</code></pre>
<blockquote>
<p>引用不会创建新对象，只是为已有对象取别名。</p>
</blockquote>
<h3 id="6-对象的拷贝与赋值"><a class="header" href="#6-对象的拷贝与赋值">6. 对象的拷贝与赋值</a></h3>
<p>当我们用一个对象初始化另一个对象时，会自动调用<strong>拷贝构造函数</strong>。</p>
<pre><code class="language-cpp">class Box {
public:
    int width;
    Box(int w) : width(w) {}
    Box(const Box&amp; b) { // 拷贝构造函数
        width = b.width;
        std::cout &lt;&lt; "Copy constructor called\n";
    }
};

int main() {
    Box b1(10);
    Box b2 = b1; // 调用拷贝构造函数
}
</code></pre>
<p>赋值操作调用的是<strong>赋值运算符（operator=）</strong>，而不是拷贝构造。</p>
<h3 id="7-const-对象"><a class="header" href="#7-const-对象">7. const 对象</a></h3>
<p>可以将对象声明为常量，使其内容不可被修改：</p>
<pre><code class="language-cpp">class Point {
public:
    int x, y;
    void show() const {
        std::cout &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; std::endl;
    }
};

int main() {
    const Point p = {1, 2};
    p.show();
    // p.x = 5; // 错误：常对象不可修改成员
}
</code></pre>
<blockquote>
<p>常对象只能调用常成员函数（即声明为 <code>void func() const</code> 的函数）。</p>
</blockquote>
<h3 id="8-对象之间的比较与赋值"><a class="header" href="#8-对象之间的比较与赋值">8. 对象之间的比较与赋值</a></h3>
<p>对象可以相互赋值：</p>
<pre><code class="language-cpp">Student s1, s2;
s1.name = "A";
s2 = s1; // 成员变量逐个拷贝
</code></pre>
<p>但若希望对象间的比较（==、&lt; 等）有意义，需要<strong>重载运算符</strong>（进阶内容，后续讲述）。</p>
<h3 id="9-对象与内存模型"><a class="header" href="#9-对象与内存模型">9. 对象与内存模型</a></h3>
<p>每个对象在内存中都有<strong>独立的成员变量副本</strong>：</p>
<pre><code class="language-text">Student s1 ──► name="张三", age=20
Student s2 ──► name="李四", age=21
</code></pre>
<p>而静态成员在所有对象间共享。</p>
<h2 id="三完整示例"><a class="header" href="#三完整示例">三、完整示例</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Student {
public:
    string name;
    int age;

    Student(string n = "未知", int a = 0) : name(n), age(a) {
        cout &lt;&lt; "Constructed: " &lt;&lt; name &lt;&lt; endl;
    }

    ~Student() {
        cout &lt;&lt; "Destructed: " &lt;&lt; name &lt;&lt; endl;
    }

    void show() const {
        cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; endl;
    }
};

int main() {
    Student s1("张三", 20);
    Student s2("李四", 21);

    s1.show();
    s2.show();

    Student* p = new Student("王五", 22);
    p-&gt;show();
    delete p;  // 手动释放动态对象
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="language-text">Constructed: 张三
Constructed: 李四
Constructed: 王五
Name: 张三, Age: 20
Name: 李四, Age: 21
Name: 王五, Age: 22
Destructed: 王五
Destructed: 李四
Destructed: 张三
</code></pre>
<h2 id="四面向对象的三大特征"><a class="header" href="#四面向对象的三大特征">四、面向对象的三大特征</a></h2>
<p>面向对象编程（OOP）的核心思想可以概括为<strong>三大特征</strong>：封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism）。这三大特征是 C++ 类与对象设计的基础，也是理解和应用面向对象程序设计的关键。</p>
<blockquote>
<p>继承与多态的内容属于C++<a href="../Advance/Object.html">面向对象进阶</a>内容。</p>
</blockquote>
<h3 id="1-封装encapsulation"><a class="header" href="#1-封装encapsulation">1. 封装（Encapsulation）</a></h3>
<p>封装是面向对象最基本的特征之一，也是类和对象概念的核心。</p>
<p>封装的核心思想是将对象的状态（数据）和行为（函数）组合到一个整体——类中，并通过访问控制机制对外部可见性进行限制和保护，对受保护的私有数据仅可以使用成员函数进行操作。</p>
<p><strong>作用</strong>：</p>
<ol>
<li>对内部数据进行保护，只允许可信的方法或对象访问；</li>
<li>隐藏实现细节，使类的使用者无需了解内部工作原理；</li>
<li>提供统一接口，提高模块化和可维护性。</li>
</ol>
<p>示例：</p>
<pre><code class="language-cpp">class Student {
private:
    std::string name; // 私有成员，外部无法直接访问
    int age;

public:
    void setInfo(const std::string&amp; n, int a) { // 提供接口修改数据
        name = n;
        age = a;
    }

    void display() const { // 提供接口访问数据
        std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; std::endl;
    }
};
</code></pre>
<p>在上例中，<code>name</code> 和 <code>age</code> 仅能通过 <code>setInfo</code> 和 <code>display</code> 访问和修改，这就是封装的典型应用。</p>
<p>封装就是把客观事物封装成抽象类，并控制外部访问权限，保护数据安全并提高代码可维护性。</p>
<h3 id="2-继承inheritance"><a class="header" href="#2-继承inheritance">2. 继承（Inheritance）</a></h3>
<p>继承是面向对象中的第二大特征，它允许新建的类<strong>复用</strong>已有类的属性和行为，并在此基础上进行扩展或修改。</p>
<p>被继承的类称为基类（Base Class）或父类，从基类继承的类称为派生类（Derived Class）或子类。</p>
<p><strong>作用</strong>：</p>
<ol>
<li>代码复用：无需重复编写已有功能；</li>
<li>构建类层次：形成“父类-子类”的组织结构；</li>
<li>支持多态：继承是实现运行时多态的前提。</li>
</ol>
<p><strong>实现方式</strong>：</p>
<ul>
<li>公有继承（public inheritance）：基类公有成员在派生类中仍为公有</li>
<li>保护继承（protected inheritance）：基类公有/保护成员在派生类中变为保护</li>
<li>私有继承（private inheritance）：基类公有/保护成员在派生类中变为私有</li>
<li>组合（Composition）：在类中包含另一个类对象作为成员，用于实现“has-a”关系</li>
</ul>
<p>示例：</p>
<pre><code class="language-cpp">class Person {
protected:
    std::string name;
public:
    void setName(const std::string&amp; n) { name = n; }
};

class Student : public Person { // Student 继承 Person
private:
    int grade;
public:
    void setGrade(int g) { grade = g; }
    void showInfo() const {
        std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Grade: " &lt;&lt; grade &lt;&lt; std::endl;
    }
};
</code></pre>
<blockquote>
<p><code>Student</code> 继承了 <code>Person</code> 的 <code>name</code>，同时扩展了 <code>grade</code>，这就是继承的典型应用。
如果需要类间关系更紧密，还可以通过组合在类中嵌套其他类。</p>
</blockquote>
<p>继承是在无需重写已有类功能的前提下扩展功能，实现类复用与层次化管理。</p>
<h3 id="3-多态polymorphism"><a class="header" href="#3-多态polymorphism">3. 多态（Polymorphism）</a></h3>
<p>多态是面向对象的第三大特征，允许同一个操作作用于不同对象表现出不同的行为。</p>
<p>多态允许父类指针或引用指向子类对象，并根据对象实际类型执行不同操作。</p>
<blockquote>
<p>英文 polymorphism 来自“多形性”，意为“一个接口，多种形态”。</p>
</blockquote>
<p><strong>类型</strong>：</p>
<ol>
<li>
<p>编译时多态（静态多态）：</p>
<ul>
<li>通过函数重载、运算符重载实现</li>
<li>在编译阶段就确定调用哪个函数</li>
</ul>
</li>
<li>
<p>运行时多态（动态多态）：</p>
<ul>
<li>通过虚函数（virtual）实现</li>
<li>在程序运行时根据实际对象类型决定调用哪个函数</li>
</ul>
</li>
</ol>
<p>实现方式：</p>
<ul>
<li>覆盖（Override）：派生类重新定义基类的虚函数，运行时根据实际对象调用</li>
<li>重载（Overload）：同名函数参数不同，编译时决定调用哪个函数</li>
</ul>
<p>示例（运行时多态）：</p>
<pre><code class="language-cpp">class Animal {
public:
    virtual void speak() const { std::cout &lt;&lt; "Animal sound" &lt;&lt; std::endl; }
};

class Dog : public Animal {
public:
    void speak() const override { std::cout &lt;&lt; "Woof!" &lt;&lt; std::endl; }
};

int main() {
    Animal* a = new Dog();
    a-&gt;speak(); // 输出 "Woof!"，根据实际对象类型调用
    delete a;
}
</code></pre>
<blockquote>
<p><code>speak</code> 被声明为虚函数，父类指针调用时根据子类实际类型执行函数，这就是运行时多态。</p>
</blockquote>
<p>多态使得<strong>统一接口处理不同对象成为可能</strong>，提高了程序的灵活性和可扩展性。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Basis/Functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Basis/Template.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Basis/Functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Basis/Template.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
